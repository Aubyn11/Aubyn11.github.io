<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>力扣0001——两数之和</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30001%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/two-sum/">两数之和</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong><code>target</code>的那 <strong>两个</strong> 整数，并返回它们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>
你可以按任意顺序返回答案。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [2,7,11,15], target = 9<br>
<strong>输出</strong>：[0,1]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p>输入：nums = [3,2,4]，target = 6<br>
输出：[1,2]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p>输入：nums = [3,3]，target = 6<br>
输出：[0,1]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>直接遍历数组，获取所有的和，找出符合条件的两个数的下标然后直接输出</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">9</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] ints = solution.TwoSum(nums, target);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> x <span class="keyword">in</span> ints)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; nums.Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.Exception(<span class="string">&quot;Failure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0002——两数相加</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30002%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/add-two-numbers/">两数相加</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。<br>
请你将两个数相加，并以相同形式返回一个表示和的链表。<br>
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0002_1.jpg" alt="图片示例"></p>
<blockquote>
<p><strong>输入</strong>：l1 = [2,4,3], l2 = [5,6,4]<br>
<strong>输出</strong>：[7,0,8]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：l1 = [0], l2 = [0]<br>
<strong>输出</strong>：[0]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>
<strong>输出</strong>：[8,9,9,9,0,0,0,1]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>因为两个链表中的数都是逆序排列的，所以两个链表中的数字可以直接相加，如果两个链表的长度不同，则可以认为长度短的链表的后面跟了若干个 0<br>
逐位求和并与当前的进位值相加</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val; </span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        l1.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        l1.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        l2.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        l3 = AddTwoNumbers(l1, l2);</span><br><span class="line">        ListNode tail = l3;</span><br><span class="line">        <span class="keyword">while</span> (tail != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(tail.val);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">AddTwoNumbers</span>(<span class="params">ListNode l1, ListNode l2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode head = <span class="literal">null</span>, tail = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> n1 = l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> n2 = l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                head = tail = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0003——无重复字符的最长字串</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30003%E2%80%94%E2%80%94%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “abcabcbb”<br>
<strong>输出</strong>：3</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “bbbbb”<br>
<strong>输出</strong>：1</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “pwwkew”<br>
<strong>输出</strong>：3</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>定义哈希集合，记录每一个字符是否出现过，然后根据两个指针<code>left</code>，<code>right</code>的移动来对整个字符串来进行窗口移动</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;pwwkew&quot;</span>;</span><br><span class="line">        <span class="built_in">int</span> max = LengthOfLongestSubstring(s);</span><br><span class="line">        Console.WriteLine(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">LengthOfLongestSubstring</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;<span class="built_in">char</span>&gt; letter = <span class="keyword">new</span> HashSet&lt;<span class="built_in">char</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> length = s.Length;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!letter.Contains(s[right]))</span><br><span class="line">            &#123;</span><br><span class="line">                letter.Add(s[right]);</span><br><span class="line">                right++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                letter.Remove(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.Max(max, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0004——寻找两个正序数组的中位数</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30004%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a>难度：<strong>困难</strong></h1>
<h2 id="题目描述">题目描述</h2>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。<br>
算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums1 = [1,3], nums2 = [2]<br>
<strong>输出</strong>：2.00000</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums1 = [1,2], nums2 = [3,4]<br>
<strong>输入</strong>：2.50000</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>将两个数组合并到一个<code>List</code>表中，通过<code>Sort</code>来对它进行排序，并获得两个数组的长度的和<code>len</code>，如果和为奇数就可以直接返回<code>List</code>中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">len / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 的值，如果为偶数，就返回<code>List</code>中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">len / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">len / 2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的和的平均值</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums1 = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] nums2 = &#123; <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        Console.WriteLine(FindMedianSortedArrays(nums1,nums2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">FindMedianSortedArrays</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = nums1.Length;</span><br><span class="line">        <span class="built_in">int</span> n = nums2.Length;</span><br><span class="line">        <span class="built_in">int</span> len = m + n;</span><br><span class="line">        <span class="keyword">var</span> resultIndex = len / <span class="number">2</span>;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(nums1);</span><br><span class="line">        list.AddRange(nums2);</span><br><span class="line">        list.Sort();</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (list[resultIndex - <span class="number">1</span>] + list[resultIndex]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list[resultIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0005——最长回文子串</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30005%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。<br>
如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “babad”<br>
<strong>输出</strong>：“bab”</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “cbbd”<br>
<strong>输出</strong>：“bb”</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>滑动窗口法，遍历每一个字符，每次遍历用<code>left</code>和<code>right</code>来记录当前窗口然后向右滑动知道超出数组或者和下标数不相等就停止，最后向两边滑动窗口判断回文，直到不相等或超过边界。记录最长的子串</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;babad&quot;</span>;</span><br><span class="line">        Console.WriteLine(LongestPaildrome(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">LongestPaildrome</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> left;</span><br><span class="line">        <span class="built_in">int</span> right;</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> count;</span><br><span class="line">        <span class="built_in">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> resultleft = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            right = left = index;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span> (right &gt;= s.Length || s[right] != s[left])</span><br><span class="line">                &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &gt;= s.Length || s[left] != s[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count = right - left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; count)</span><br><span class="line">            &#123;</span><br><span class="line">                max = count;</span><br><span class="line">                resultleft = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.Substring(resultleft, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0006——N字形变换</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30006%E2%80%94%E2%80%94N%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/zigzag-conversion/">N字形变换</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。<br>
比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。<br>
请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “PAYPALISHIRING”, numRows = 3<br>
<strong>输出</strong>：“PAHNAPLSIIGYIR”</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “PAYPALISHIRING”, numRows = 4<br>
<strong>输出</strong>：“PINALSIGYAHRPI”</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “A”, numRows = 1<br>
<strong>输出</strong>：“A”</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>对每一个字符进行标记，将所得的字符所对应的行数记录到一个数组中，创建一个字典，对每一行存储的字符串进行拼接，之后输出</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;PAYPALISHIRING&quot;</span>;</span><br><span class="line">        Console.WriteLine(Convert(s,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">int</span> numRows</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> len = s.Length;</span><br><span class="line">        <span class="built_in">int</span>[] row = <span class="keyword">new</span> <span class="built_in">int</span>[len];</span><br><span class="line">        <span class="built_in">int</span> k = <span class="number">1</span>, f = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            row[cnt++] = k;</span><br><span class="line">            k += f;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span> || k == numRows) f *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dictionary&lt;<span class="built_in">int</span>, StringBuilder&gt; map = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, StringBuilder&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.ContainsKey(row[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                map.Add(row[i], <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            map[row[i]].Append(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> map)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.Append(i.Value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0007——整数反转</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30007%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/reverse-integer/">整数反转</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。<br>
如果反转后整数超过 32 位的有符号整数的范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mtext>−</mtext><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[−2^{31}, 2^{31}− 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，就返回 0。<br>
<strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：x = 123<br>
<strong>输出</strong>：321</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：x = -123<br>
<strong>输出</strong>：-321</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：x = 120<br>
<strong>输出</strong>：21</p>
</blockquote>
<h2 id="示例4">示例4</h2>
<blockquote>
<p><strong>输入</strong>：x = 0<br>
<strong>输出</strong>：0</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>先定义两个常量，一个最大<code>MAX</code>，一个最小<code>MIN</code>，因为要反转，所以要判断是否会越界，最大值为<code>2147483647</code>，最小值为<code>-2147483648</code>，所以当反转的时候要注意不要越界</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MAX = <span class="built_in">int</span>.MaxValue / <span class="number">10</span>, MIN = <span class="built_in">int</span>.MinValue / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">4321</span>;</span><br><span class="line">        Console.WriteLine(Reverse(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Reverse</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> reversed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> lastDigit = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (reversed &gt; MAX || reversed &lt; MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (reversed == MAX &amp;&amp; lastDigit &gt; <span class="number">7</span> || reversed == MIN &amp;&amp; lastDigit &lt; <span class="number">-8</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reversed = reversed * <span class="number">10</span> + lastDigit;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reversed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0008——字符串转换整数</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30008%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/string-to-integer-atoi/">字符串转换整数</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。<br>
函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，“123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mtext>−</mtext><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[−2^{31}, 2^{31}− 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>−</mtext><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">−2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 的整数应该被固定为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>−</mtext><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">−2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ，大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}− 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 的整数应该被固定为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}− 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>
</ul>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = &quot;   -42&quot;<br>
<strong>输出</strong>：-42</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “42”<br>
<strong>输出</strong>：42</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “4193 with words”<br>
<strong>输出</strong>：4193</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>先遍历字符，将空格过滤，之后判断是否将字符串遍历完，如果遍历到最后一位，则返回0。如果没有遍历完，就继续像下面比对，若没有数字，则返回0。如果有数字，则对它进行进位运算，如果之后有最大值上越界，则返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，若下越界，则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">- 2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，如果没有，则可以直接计算后返回</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;4193 with words&quot;</span>;</span><br><span class="line">        Console.WriteLine(MyAtoi(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MyAtoi</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = s.Length;</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; s[index] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[index] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[index] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">int</span> MAX = <span class="built_in">int</span>.MaxValue / <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; <span class="built_in">char</span>.IsDigit(s[index]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> digit = s[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; MAX || num &lt; -MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? <span class="built_in">int</span>.MaxValue : <span class="built_in">int</span>.MinValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign &gt; <span class="number">0</span> &amp;&amp; digit &gt; <span class="number">7</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">int</span>.MaxValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sign &lt; <span class="number">0</span> &amp;&amp; digit &gt; <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">int</span>.MinValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + digit;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0009——回文数</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30009%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/palindrome-number/">回文数</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br>
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>
</ul>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：x = 121<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：x = -121<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：x = 10<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>对这个数先进行判断，如果这个数是小于0或者末尾为零（不包括0）的数，那么直接返回false，如果为其他的数，就可以正常按照倒序，然后比对是否为回文</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">121</span>;</span><br><span class="line">        Console.WriteLine(IsPalindrome(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span>) == <span class="number">0</span> &amp;&amp; x !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; num)</span><br><span class="line">        &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x == num || x == num / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0010——正则表达式匹配</title>
    <url>/2023/11/18/%E5%8A%9B%E6%89%A30010%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目要求">题目要求</h2>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p>
<ul>
<li><code>'.'</code> 匹配任意单个字符</li>
<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖<strong>整个</strong>字符串 <code>s</code>的，而不是部分字符串。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “aa”, p = “a”<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “aa”, p = “a*”<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “ab”, p = “.*”<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="题解">题解</h2>
<p><img src="/images/ltc_0010_1.png" alt="图片来自于LeetCode题解"></p>
<p>分析以上表table： s串为 “abbbc&quot;在图的最左侧一列， p串为&quot;abbc” 在图的上面一行。</p>
<p>红色对勾表示true, table[0,0] 为true，表示s[0:0]=“a” 与 p[0:0]=“a” 是匹配；table[4,4]为true，表示s[0:4]=“abbbc” 与p[0:4]=“ab<em>bc&quot;是匹配的; table[4,6] 为 true 则表示 s[0:4]=“abbbc” 与 p[0,6]= &quot;ab</em>bc*.” 是匹配的 。即table[i,j]为true，表示s[0:i]与p[0:j] 是匹配的.</p>
<p>table[0,0]=true表示s与p是匹配的，而且在table种我们可以得到一条通路from右下角to左上角（忽略2个星列），这条通路的走向有3种：</p>
<ol>
<li>格星左跳一位，例如table[4,6]到table[4,4],  【A】</li>
<li>向上走一位，例如tble[3,1]到table[2,1], 【B】</li>
<li>向左上走一位，例如 table[1,1]到 table[0,0] , 【C】</li>
</ol>
<p>这三种走向可以与方法二的回溯法种的ABC三个递归分支分别对应，而求解table的方法也与回溯法类似，但相比回溯法，多了一个table用做备忘录，避免重复计算。</p>
<p>计算上面table每个格子的值时，先令 table[5,7]=true ，并依次计算格子值，最终若table[0,0]=true，则表示s与p匹配。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> p = <span class="string">&quot;a*&quot;</span>;</span><br><span class="line">        Console.WriteLine(IsMatch(s,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsMatch</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span>[,] dp = <span class="keyword">new</span> <span class="built_in">bool</span>[s.Length + <span class="number">1</span>, p.Length + <span class="number">1</span>];</span><br><span class="line">        dp[s.Length, p.Length] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = s.Length; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = p.Length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bool</span> first_macth = (i &lt; s.Length &amp;&amp; (p[j] == s[i] || p[j] == <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.Length &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i, j] = dp[i, j + <span class="number">2</span>] || first_macth &amp;&amp; dp[i + <span class="number">1</span>, j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i, j] = first_macth &amp;&amp; dp[i + <span class="number">1</span>, j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0011——盛最多水的容器</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30011%E2%80%94%E2%80%94%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。<br>
找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。<br>
返回容器可以储存的最大水量。<br>
**说明：**你不能倾斜容器。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0011_1.jpg" alt="图示"></p>
<blockquote>
<p><strong>输入</strong>：[1,8,6,2,5,4,8,3,7]<br>
<strong>输出</strong>：49</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：height = [1,1]<br>
<strong>输出</strong>：1</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>用两个指针直接指向两个边界，循环，进行两个边界的对比，取最小值然后乘以长度，得出面积，如果右边高度比左边高度要高，那么左边的下标加一，反之则是右边下标减一</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    public <span class="type">static</span> <span class="type">void</span> <span class="title function_">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] height = &#123; <span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        Console.WriteLine(MaxArea(height));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">static</span> <span class="type">int</span> <span class="title function_">MaxArea</span><span class="params">(<span class="type">int</span>[] height)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, i = <span class="number">0</span>, j = height.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            max = Math.Max((j - i) * Math.Min(height[j], height[i]), max);</span><br><span class="line">            <span class="keyword">if</span> (height[j] &gt; height[i])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0012——整数转罗马数字</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30012%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/integer-to-roman/">整数转罗马数字</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。<br>
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给你一个整数，将其转为罗马数字。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：num = 3<br>
<strong>输出</strong>：“III”</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：num = 4<br>
<strong>输出</strong>：“IV”</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：num = 9<br>
<strong>输出</strong>：“IX”</p>
</blockquote>
<h2 id="示例4">示例4</h2>
<blockquote>
<p><strong>输入</strong>：num = 58<br>
<strong>输出</strong>：“LVIII”</p>
</blockquote>
<h2 id="示例5">示例5</h2>
<blockquote>
<p><strong>输入</strong>：num = 1994<br>
<strong>输出</strong>：“MCMXCIV”</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>使用贪心算法，将每种情况存入到字典中，然后对当前数字进行遍历，如果当前字典索引中的值小于所给的整数，那么就将这个字符添加到StringBuilder中去，并将整数减去当前字典索引中的值，如此循环，直到最后所给数字为0</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = <span class="number">1994</span>;</span><br><span class="line">        Console.WriteLine(IntToRoman(num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">IntToRoman</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">        dic.Add(<span class="string">&quot;M&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;CM&quot;</span>, <span class="number">900</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;D&quot;</span>, <span class="number">500</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;CD&quot;</span>, <span class="number">400</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;C&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;XC&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;L&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;XL&quot;</span>, <span class="number">40</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;X&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;IX&quot;</span>, <span class="number">9</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;V&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;IV&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        dic.Add(<span class="string">&quot;I&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> dic)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= i.Value)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.Append(i.Key);</span><br><span class="line">                num -= i.Value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0013——罗马数字转整数</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30013%E2%80%94%E2%80%94%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/roman-to-integer/">罗马数字转整数</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。<br>
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “III”<br>
<strong>输出</strong>：3</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “IV”<br>
<strong>输出</strong>：4</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “IX”<br>
<strong>输出</strong>：9</p>
</blockquote>
<h2 id="示例4">示例4</h2>
<blockquote>
<p><strong>输入</strong>：s = “LVIII”<br>
<strong>输出</strong>：58</p>
</blockquote>
<h2 id="示例5">示例5</h2>
<blockquote>
<p><strong>输入</strong>：s = “MCMXCIV”<br>
<strong>输出</strong>：1994</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>将各种情况存入字典之中，对当前字符串进行遍历，如果当前字符代表的数字比后面一个字符代表的数字小，那么就直接减去当前数字，否则就加上当前数字，同时，因为要防止越界，要在循环结束之后加上最后一个元素的值</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;IV&quot;</span>;</span><br><span class="line">        Console.WriteLine(RomanToInt(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">RomanToInt</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; &#123; &#123;<span class="string">&quot;I&quot;</span>, <span class="number">1</span>&#125; , &#123; <span class="string">&quot;V&quot;</span>, <span class="number">5</span> &#125;, &#123; <span class="string">&quot;X&quot;</span>, <span class="number">10</span> &#125;, &#123; <span class="string">&quot;L&quot;</span>, <span class="number">50</span> &#125;, &#123; <span class="string">&quot;C&quot;</span>, <span class="number">100</span> &#125;, &#123; <span class="string">&quot;D&quot;</span>, <span class="number">500</span> &#125;, &#123; <span class="string">&quot;M&quot;</span>, <span class="number">1000</span> &#125; &#125;;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.Length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dic[s[i].ToString()] &lt; dic[s[i + <span class="number">1</span>].ToString()])</span><br><span class="line">            &#123;</span><br><span class="line">                result -= dic[s[i].ToString()];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result += dic[s[i].ToString()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result += dic[s[s.Length - <span class="number">1</span>].ToString()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0014——最长公共前缀</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30014%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/longest-common-prefix/">最长公共前缀</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>
如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：strs = [“flower”,“flow”,“flight”]<br>
<strong>输出</strong>：“fl”</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：strs = [“dog”,“racecar”,“car”]<br>
<strong>输出</strong>：&quot;&quot;</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>对第一个字符串进行遍历，作为第一层遍历，之后对每一个字符串对应的位置进行对比作为第二层遍历，如果不相同直接返回，如果相同则将当前字符加入结果中并继续循环</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>[] strs = &#123; <span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span> &#125;;</span><br><span class="line">        Console.WriteLine(LongestCommonPrefix(strs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">LongestCommonPrefix</span>(<span class="params"><span class="built_in">string</span>[] strs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> count = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; strs.Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; (strs[j].Length - <span class="number">1</span>) || strs[j][i] != strs[<span class="number">0</span>][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count += strs[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0015——三数之和</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30015%E2%80%94%E2%80%94%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/3sum/">三数之和</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请<br>
你返回所有和为 <code>0</code> 且不重复的三元组。<br>
<strong>注意</strong>：答案中不可以包含重复的三元组。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [-1,0,1,2,-1,-4]<br>
<strong>输出</strong>：[[-1,-1,2],[-1,0,1]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [0,1,1]<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：nums = [0,0,0]<br>
<strong>输出</strong>：[[0,0,0]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>先排序，从数组第一个元素开始遍历，遍历到倒数第三个元素，定义一个左指针和一个右指针，左指针为第一层循环值 + 1，右指针为最后一个元素下标，定义三数之和为当前循环数组元素，左指针下标代表元素，右指针代表元素，当左指针小于右指针时，如果和为零，那么就将结果添加到列表中，如果和小于零，左指针自增，如果大于零，右指针自减。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; list = ThreeSum(nums);</span><br><span class="line">        <span class="keyword">foreach</span> (IList&lt;<span class="built_in">int</span>&gt; i <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">@&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> j <span class="keyword">in</span> i)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.Write(<span class="string">@&quot;]&quot;</span>);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ThreeSum(<span class="built_in">int</span>[] nums)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; result = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">        <span class="built_in">int</span> len = nums.Length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Array.Sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; nums[i], nums[left], nums[right] &#125;);</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0016——最接近的三数之和</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30016%E2%80%94%E2%80%94%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/3sum-closest/">最接近的三数之和</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目要求">题目要求</h2>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。<br>
返回这三个数的和。<br>
假定每组输入只存在恰好一个解。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [-1,2,1,-4], target = 1<br>
<strong>输出</strong>：2</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [0,0,0], target = 1<br>
<strong>输出</strong>：0</p>
</blockquote>
<h2 id="题解：">题解：</h2>
<p>先对数组进行排序，从数组第一个元素开始遍历，遍历到倒数第三个元素，定义一个左指针和一个右指针，左指针为第一层循环值 + 1，右指针为最后一个元素下标，定义三数之和为当前循环数组元素，左指针下标代表元素，右指针代表元素，当左指针小于右指针时，如果和与目标值相等，直接返回目标值，如果比目标值大，右指针自减，如果比目标值小，左指针自增</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-4</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">1</span>;</span><br><span class="line">        Console.WriteLine(ThreeSumClosest(nums,target));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ThreeSumClosest</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Array.Sort(nums);</span><br><span class="line">        <span class="built_in">int</span> res = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> right = nums.Length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> sum = nums[left] + nums[right] + nums[i];</span><br><span class="line">                <span class="keyword">if</span> (sum == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Math.Abs(sum - target) &lt; Math.Abs(res - target))</span><br><span class="line">                &#123;</span><br><span class="line">                    res = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0017——电话号码的字母组合</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30017%E2%80%94%E2%80%94%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。<br>
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/images/ltc_0017_1.png" alt="示例"></p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：digits = “23”<br>
<strong>输出</strong>：[“ad”,“ae”,“af”,“bd”,“be”,“bf”,“cd”,“ce”,“cf”]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：digits = “”<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：digits = “2”<br>
<strong>输出</strong>：[“a”,“b”,“c”]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>利用回溯法，将每一个数字字符对应的字符串添加到字典当中，之后设定回溯，定义一个空的字符串，定义一个中间元素Temp使其与每一次回溯的字典中索引的值相同，如果字符串的长度和给定的字符长度相同，将字符串加入到一个List中并直接return，如果不满足，进行循环，每一次让空字符串加上temp的一个字符，然后进行回溯，退出回溯之后去除字符串中的最后一个元素</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> digits = <span class="string">&quot;23&quot;</span>;</span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; list = LetterCombinations(digits);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> s <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IList&lt;<span class="built_in">string</span>&gt; <span class="title">LetterCombinations</span>(<span class="params"><span class="built_in">string</span> digits</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">string</span>&gt;();</span><br><span class="line">        dic.Add(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        dic.Add(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        dic.Add(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        dic.Add(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        dic.Add(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        dic.Add(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        dic.Add(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        dic.Add(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Recall(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,digits,dic,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Recall</span>(<span class="params"><span class="built_in">int</span> index, <span class="built_in">string</span> str, <span class="built_in">string</span> digits, Dictionary&lt;<span class="built_in">char</span>, <span class="built_in">string</span>&gt; dic, List&lt;<span class="built_in">string</span>&gt; list</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.Length == digits.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            list.Add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> temp = dic[digits[index]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; temp.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str += temp[i];</span><br><span class="line">            Recall(index + <span class="number">1</span>, str, digits, dic, list);</span><br><span class="line">            str = str.Remove(str.Length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0018——四数之和</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30018%E2%80%94%E2%80%94%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/4sum/">四数之和</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d&amp;nbsp;&lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,0,-1,0,-2,2], target = 0<br>
<strong>输出</strong>：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [2,2,2,2,2], target = 8<br>
<strong>输出</strong>：[[2,2,2,2]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>根据三数之和演变而来，可以在三数之和外面再次嵌套一个循环，内部的基本逻辑不变，依然是左右两个指针进行移动</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">0</span>;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; list = FourSum(nums, target);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> y <span class="keyword">in</span> x)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(y + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; FourSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; res = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        Array.Sort(nums);</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= nums.Length - <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt;= nums.Length - <span class="number">4</span> + <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">int</span> right = nums.Length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[j] &gt; <span class="number">0</span> &amp;&amp; nums[left] &gt; <span class="number">0</span> &amp;&amp; nums[right] &gt; <span class="number">0</span> &amp;&amp; sum &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        res.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; nums[i], nums[j], nums[left], nums[right] &#125;);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0019——删除链表的倒数第N个结点</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30019%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第N个结点</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0019_1.jpg" alt="示例图片"></p>
<blockquote>
<p><strong>输入</strong>：head = [1,2,3,4,5], n = 2<br>
<strong>输出</strong>：[1,2,3,5]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：head = [1], n = 1<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：head = [1,2], n = 1<br>
<strong>输出</strong>：[1]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>采用快慢指针，让快指针先走<code>n</code>步，然后快慢指针一起走，直到快指针为空，那么这个时候慢指针对应的元素就是要删除的元素</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val; </span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode list = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        list.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        list.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode list2 = RemoveNthFromEnd(list, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(list2.val);</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">RemoveNthFromEnd</span>(<span class="params">ListNode head, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode temp = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = slow;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.next = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0020——有效的括号</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30020%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。<br>
有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “()”<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “()[]{}”<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “(]”<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>利用栈可以轻松的做出这道题，当遍历到左括号的时候，入栈相对应的右括号，当遍历到右括号的时候，如果栈内没有元素或者出栈的元素不是对应的右括号，直接返回false；如果最后栈内仍有元素，那么也返回false</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = Console.ReadLine();</span><br><span class="line">        Console.WriteLine(IsValid(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> len = s.Length;</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">char</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.Push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.Push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.Push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.Count == <span class="number">0</span> || stack.Pop() != s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0021——合并两个有序链表</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30021%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0021_1.jpg" alt="示例图片"></p>
<blockquote>
<p><strong>输入</strong>：l1 = [1,2,4], l2 = [1,3,4]<br>
<strong>输出</strong>：[1,1,2,3,4,4]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：l1 = [], l2 = []<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：l1 = [], l2 = [0]<br>
<strong>输出</strong>：[0]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>直接使用递归方法，如果第一个<code>list1</code>的值小于<code>list2</code>，就将<code>list1</code>作为主链，然后将<code>list1</code>变为<code>list1.next</code>加入递归，返回<code>list1</code>，否则，与上述操作相反，返回<code>list2</code></p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode list1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        list1.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        list1.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode list2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        list2.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        list2.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode list = MergeTwoLists(list1, list2);</span><br><span class="line">        <span class="keyword">while</span> (list != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(list.val);</span><br><span class="line">            Console.Write(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">            list = list.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">MergeTwoLists</span>(<span class="params">ListNode list1, ListNode list2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list1.val &lt;= list2.val)</span><br><span class="line">        &#123;</span><br><span class="line">            list1.next = MergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            list2.next = MergeTwoLists(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0022——括号生成</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30022%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的 **括号组合。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：n = 3<br>
<strong>输出</strong>：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：n = 1<br>
<strong>输出</strong>：[&quot;()&quot;]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>用回溯法来实现这个函数，如果左边小于<code>n</code>，那么<code>left</code>加一并给字符串加上<code>‘('</code>，如果右边小于<code>n</code>，则相反，如果右大于左，直接返回，如果左右都等于<code>n</code>，则可以将字符串加入到结果中</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">3</span>;</span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; list = GenerateParenthesis(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IList&lt;<span class="built_in">string</span>&gt; <span class="title">GenerateParenthesis</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        ReTrack(n, result, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReTrack</span>(<span class="params"><span class="built_in">int</span> n,IList&lt;<span class="built_in">string</span>&gt; result,<span class="built_in">int</span> right,<span class="built_in">int</span> left,<span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == n &amp;&amp; right == n)</span><br><span class="line">        &#123;</span><br><span class="line">            result.Add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            ReTrack(n,result,right,left + <span class="number">1</span>,s + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            ReTrack(n, result,right + <span class="number">1</span>, left,s + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0023——合并K个升序链表</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30023%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个链表数组，每个链表都已经按升序排列。<br>
请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：lists = [[1,4,5],[1,3,4],[2,6]]<br>
<strong>输出</strong>：[1,1,2,3,4,4,5,6]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：lists = []<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：lists = [[]]<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>利用优先队列，将数组中每一个链表都加入优先队列中，如果队列中的元素大于<code>0</code>，就将队列内每一个链表的元素加入到新的链表之中，最后返回从第二个节点开始的链表，因为第一个节点为0；</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode[] lists = <span class="keyword">new</span> ListNode[<span class="number">2</span>];</span><br><span class="line">        lists[<span class="number">0</span>] = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        lists[<span class="number">0</span>].next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        lists[<span class="number">0</span>].next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        lists[<span class="number">1</span>] = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        lists[<span class="number">1</span>].next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        lists[<span class="number">1</span>].next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        lists[<span class="number">2</span>] = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        lists[<span class="number">2</span>].next = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        ListNode list = MergeKLists(lists);</span><br><span class="line">        <span class="keyword">while</span> (list != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(list.val);</span><br><span class="line">            list = list.next;</span><br><span class="line">            Console.Write(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">MergeKLists</span>(<span class="params">ListNode[] lists</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PriorityQueue&lt;ListNode, <span class="built_in">int</span>&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;ListNode, <span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> node <span class="keyword">in</span> lists)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.Enqueue(node, node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode ans = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode d = ans;</span><br><span class="line">        <span class="keyword">while</span> (pq.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode t = pq.Dequeue();</span><br><span class="line">            d.next = t;</span><br><span class="line">            d = d.next;</span><br><span class="line">            <span class="keyword">if</span> (t.next != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.Enqueue(t.next, t.next.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0024——两两交换链表中的结点</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30024%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0024_1.jpg" alt="示例图片"></p>
<blockquote>
<p><strong>输入</strong>：head = [1,2,3,4]<br>
<strong>输出</strong>：[2,1,4,3]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：head = []<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：head = [1]<br>
<strong>输出</strong>：[1]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>以交换的两个节点来说，交换的次序为</p>
<ul>
<li>将第一个要交换的节点的<code>next</code>变为第二个要交换的节点的<code>next</code></li>
<li>将第二个要交换的节点的<code>next</code>变为第一个要交换的节点</li>
<li>将第一个要交换的节点之前的节点的<code>next</code>变为哥第二个要交换的节点</li>
<li>如果只有一个节点或为空直接返回</li>
<li>如果有两个节点以上就让第二个节点当作头节点返回</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next = <span class="keyword">new</span> ListNode(<span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    next = <span class="keyword">new</span> ListNode(<span class="number">4</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ListNode list1 = SwapPairs(head);</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(list1.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">SwapPairs</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = <span class="literal">null</span>;</span><br><span class="line">        head = cur.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode node = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">                node.next = cur;</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">null</span>)</span><br><span class="line">                    pre.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0025——K个一组翻转链表</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30025%E2%80%94%E2%80%94K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K个一组翻转链表</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<br>
<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0025_1.jpg" alt="示例图片_1"></p>
<blockquote>
<p><strong>输入</strong>：head = [1,2,3,4,5], k = 2<br>
<strong>输出</strong>：[2,1,4,3,5]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0025_2.jpg" alt="示例图片_2"></p>
<blockquote>
<p><strong>输入</strong>：head = [1,2,3,4,5], k = 3<br>
<strong>输出</strong>：[3,2,1,4,5]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>利用回溯法解题，在方法内定义一个<code>List</code>，再定义一个链表来接收头节点，然后对传进来的链表进行<code>k</code>次循环，如果此时链表内元素已经为空，那么直接返回接受头结点的链表，如果不为空，就将链表内元素加入到<code>List</code>中，完成循环之后对<code>List</code>进行循环，让List的指向反向，然后让<code>List</code>中的第一个元素指向回溯方法，最后返回<code>List</code>中的最后一个元素</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next = <span class="keyword">new</span> ListNode(<span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    next = <span class="keyword">new</span> ListNode(<span class="number">4</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        next = <span class="keyword">new</span> ListNode(<span class="number">5</span>) </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> k = <span class="number">2</span>;</span><br><span class="line">        ListNode reListNode = ReverseKGroup(head, k);</span><br><span class="line">        <span class="keyword">while</span> (reListNode != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(reListNode.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            reListNode = reListNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">ReverseKGroup</span>(<span class="params">ListNode head, <span class="built_in">int</span> k</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> List&lt;ListNode&gt;();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.Add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list[i].next = list[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list[<span class="number">0</span>].next = ReverseKGroup(head, k);</span><br><span class="line">        <span class="keyword">return</span> list[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0026——删除有序数组中的重复项</title>
    <url>/2023/11/19/%E5%8A%9B%E6%89%A30026%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>原地</strong></a>删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。<br>
考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,1,2]<br>
<strong>输出</strong>：2, nums = [1,2,_]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [0,0,1,1,1,2,2,3,3,4]<br>
<strong>输出</strong>：5, nums = [0,1,2,3,4]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>利用快慢指针解题，让慢指针指向第一个元素，快指针指向第二个，如果快指针比数组长度小则进行循环，如果两个指针指向的元素不相等，就让慢指针自增，并让数组中慢指针指向的元素等于快指针的元素，之后，让快指针自增，最后返回慢指针+1即为有效数量</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> x = RemoveDuplicates(nums);</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">RemoveDuplicates</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[slow])</span><br><span class="line">            &#123;</span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0027——移除元素</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30027%E2%80%94%E2%80%94%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/remove-element/">移除元素</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>原地</strong></a> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>原地</strong></a> 修改输入数组。<br>
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [3,2,2,3], val = 3<br>
<strong>输出</strong>：2, nums = [2,2]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [0,1,2,2,3,0,4,2], val = 2<br>
<strong>输出</strong>：5, nums = [0,1,4,0,3]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>利用快慢指针，当快指针指向的元素下标小于数组长度进行循环，如果快指针指向的元素不等于<code>val</code>的数值，就让慢指针指向的元素等于快指针指向的元素，慢指针自增，判断结束之后快指针自增，最后返回慢指针的值</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> val = <span class="number">2</span>;</span><br><span class="line">        Console.WriteLine(RemoveElement(nums,val));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(nums[i] + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">RemoveElement</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> val</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0028——找出字符串中第一个匹配项的下标</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30028%E2%80%94%E2%80%94%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回  <code>-1</code>。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：haystack = “sadbutsad”, needle = “sad”<br>
<strong>输出</strong>：0</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：haystack = “leetcode”, needle = “leeto”<br>
<strong>输出</strong>：-1</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>直接使用KMP算法即可，但是需要加上两个判定条件，如果<code>needle</code>为空就返回0，如果<code>needle</code>的长度大于<code>haystack</code>的长度或者<code>haystack</code>为空，就返回-1</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">StrStr</span>(<span class="params"><span class="built_in">string</span> haystack, <span class="built_in">string</span> needle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(needle))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needle.Length &gt; haystack.Length || <span class="built_in">string</span>.IsNullOrEmpty(haystack))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> KMP(haystack, needle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">KMP</span>(<span class="params"><span class="built_in">string</span> haystack, <span class="built_in">string</span> needle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] next = GetNext(needle);</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; haystack.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; haystack.Length &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span>[] <span class="title">GetNext</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] next = <span class="keyword">new</span> <span class="built_in">int</span>[str.Length];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == str[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                next[i] = j;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    next[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0029——两数相除</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30029%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/divide-two-integers/">两数相除</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算。<br>
整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> 。<br>
返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的 <strong>商</strong> 。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：dividend = 10, divisor = 3<br>
<strong>输出</strong>：3</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：dividend = 7, divisor = -3<br>
<strong>输出</strong>：-2</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>首先，判断以下三种情况：</p>
<ul>
<li>如果 dividend = 0，那么直接返回0</li>
<li>如果 divisor = 1，那么直接返回被除数本身</li>
<li>如果 dividend = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 并且 divisor = -1，那么商是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，超出有符号整数范围，所以返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ul>
<p>其余的情况，首先判断符号的正负，之后将被除数和除数都变成负数，计算商的绝对值。因为不能够使用乘除，所以要用位运算代替<br>
首先将除数左移，使得在除数的绝对值不超过被除数的绝对值的情况下，将除数的绝对值最大化。假设除数左移了 k 位之后变成<code>currDivisor</code>，则<code>currDivisor</code> = divisor x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>，<code>currDivisor</code>除以<code>divisor</code>的商是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，将<code>dividend</code>的值减去<code>currDivisor</code>，然后对剩余的<code>dividend</code>继续计算商</p>
<p>当<code>dividend</code>的值减去<code>currDivisor</code>之后，如果<code>dividend</code>的绝对值小于<code>currDivisor</code>的绝对值，就需要将<code>currDivisor</code>右移，直到<code>dividend</code>的绝对值大于<code>currDivisor</code>的绝对值</p>
<p>重复计算商的操作，计算两数相除的结果，当<code>dividend</code>的绝对值小于<code>divisor</code>的绝对值时，商的剩余部分是<code>0</code>，到这里，计算结束，得到两数相除的结果的绝对值，之后根据商的正负来的到最终结果并返回</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Numerics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> dividend = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> divisor = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> result = Divide(dividend, divisor);</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Divide</span>(<span class="params"><span class="built_in">int</span> dividend, <span class="built_in">int</span> divisor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="built_in">int</span>.MinValue &amp;&amp; divisor == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> negative = dividend &lt; <span class="number">0</span> ^ divisor &lt; <span class="number">0</span>;</span><br><span class="line">        dividend = dividend != <span class="built_in">int</span>.MinValue ? -Math.Abs(dividend) : dividend;</span><br><span class="line">        divisor = divisor != <span class="built_in">int</span>.MinValue ? -Math.Abs(divisor) : divisor;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> quotient = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> currDiviser = divisor, factor = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (dividend &gt;&gt; <span class="number">1</span> &lt; currDiviser)</span><br><span class="line">        &#123;</span><br><span class="line">            currDiviser &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            factor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (dividend &lt;= divisor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (dividend &gt; currDiviser)</span><br><span class="line">            &#123;</span><br><span class="line">                currDiviser &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                factor &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            quotient += factor;</span><br><span class="line">            dividend -= currDiviser;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (negative)</span><br><span class="line">        &#123;</span><br><span class="line">            quotient = -quotient;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quotient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0030——串联所有单词的子串</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30030%E2%80%94%E2%80%94%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">串联所有单词的子串</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个字符串 <code>s</code>和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。<br>
<code>s</code>中的 <strong>串联子串</strong> 是指一个包含  <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p>
<ul>
<li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li>
</ul>
<p>返回所有串联子串在 <code>s</code>中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “barfoothefoobarman”, words = [“foo”,“bar”]<br>
<strong>输出</strong>：[0,9]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “wordgoodgoodgoodbestword”, words = [“word”,“good”,“best”,“word”]<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “barfoofoobarthefoobarman”, words = [“bar”,“foo”,“the”]<br>
<strong>输出</strong>：[6,9,12]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>采用滑动窗口法，用<code>sLength</code>表示字符串<code>s</code>的长度，用<code>wordLength</code>表示数组<code>words</code>中的每个单词的长度，用<code>wordCount</code>表示数组<code>words</code>的长度即数组中的单词个数，对于由数组<code>words</code>中的单词串联形成的子串，其长度为wordLenth X wordCount，因此可以使用定长滑动窗口寻找串联所有单词的子串，滑动窗口的大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>i</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo>=</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>∗</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">widows = wordLength * wordCount</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></p>
<p>对于降低时间复杂度，应将滑动窗口看成<code>wordCount</code>个单词，每个单词的长度是<code>wordLength</code>。每次将滑动窗口向右移动<code>wordLength</code>位，则有一个单词移出滑动窗口，有一个单词移入滑动窗口，滑动窗口中的其余单词出现的次数不变</p>
<p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">i &gt;= wordLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>时，以下标<code>i</code>作为开始的滑动窗口都可以通过以下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">i - wordLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>作为开始的窗口滑动依次得到，所以，只需要考虑首个滑动窗口的开始下标位于范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,wordLength - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中的情况。由于范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,wordLength - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中的每个下标都可能做为首个滑动窗口的下标，因此需要分别考虑<code>wordLength</code>个开始下标</p>
<p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">0 &lt;= i &lt; wordLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>时，以下标<code>i</code>作为开始的滑动窗口，其下标范围是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,i + window - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mo>−</mo><mn>1</mn><mo>&gt;</mo><mi>s</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">i + window - 1 &gt; sLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>那么就不存在以下标<code>i</code>作为开始的滑动窗口</p>
<p>一个滑动窗口中的子串是串联所有单词的子串，等价于每个单词在滑动窗口中的出现次数和在数组words中的出现次数相等，因此需要使用哈希表记录每个单词在滑动窗口中的出现次数和在数组<code>words</code>中的出现次数之差，出现次数之差等于<code>0</code>表示出现次数相等</p>
<p>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">0 &lt;= i &lt; wordLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>的每个下标<code>i</code>，执行以下操作：</p>
<ul>
<li>创建哈希表记录每个单词在滑动窗口中的出现次数和在数组<code>words</code>中的出现次数之差。将数组<code>words</code>中的每个单词在哈希表中的出现次数减<code>1</code></li>
<li>用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo separator="true">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[start,end]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>表示滑动窗口的下标范围，初始时<em>start = i</em>，<em>end = i + window - 1</em>。对于下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,i + window - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的滑动窗口，将其中的每个单词的出现次数加<code>1</code>，如果哈希表中的每个单词的出现次数之差都是<code>0</code>，则将下标<code>i</code>添加到答案中</li>
<li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi><mo>+</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>+</mo><mn>1</mn><mo>&lt;</mo><mi>s</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">end + wordLength + 1 &lt; sLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>时，将<code>start</code>和<code>end</code>各向右移动<code>wordLength</code>位，使用移出滑动窗口的单词和移入滑动窗口的单词更新哈希表。如果哈希表中的每个单词出现次数之差都是<code>0</code>，则将下标<code>start</code>添加到答案中</li>
</ul>
<p>遍历所有下标<code>i</code>之后，就可以得到每个串联子串的开始下标</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;barfoothefoobarman&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span>[] words = &#123; <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; list = FindSubstring(s, words);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">FindSubstring</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span>[] words</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; substrings = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> sLength = s.Length, wordLength = words[<span class="number">0</span>].Length, wordCount = words.Length;</span><br><span class="line">        <span class="built_in">int</span> window = wordLength * wordCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; wordLength &amp;&amp; i + window &lt;= sLength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; counts = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">string</span> word <span class="keyword">in</span> words)</span><br><span class="line">            &#123;</span><br><span class="line">                counts.TryAdd(word, <span class="number">0</span>);</span><br><span class="line">                counts[word]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> start = i, end = i + window - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = start; j &lt;= end; j += wordLength)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> word = s.Substring(j, wordLength);</span><br><span class="line">                counts.TryAdd(word, <span class="number">0</span>);</span><br><span class="line">                counts[word]++;</span><br><span class="line">                <span class="keyword">if</span> (counts[word] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counts.Remove(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (counts.Count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                substrings.Add(start);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (end + wordLength + <span class="number">1</span> &lt;= sLength)</span><br><span class="line">            &#123;</span><br><span class="line">                start += wordLength;</span><br><span class="line">                end += wordLength;</span><br><span class="line">                <span class="built_in">string</span> prev = s.Substring(start - wordLength, wordLength);</span><br><span class="line">                <span class="built_in">string</span> next = s.Substring(end - wordLength + <span class="number">1</span>, wordLength);</span><br><span class="line">                counts.TryAdd(prev, <span class="number">0</span>);</span><br><span class="line">                counts[prev]--;</span><br><span class="line">                <span class="keyword">if</span> (counts[prev] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counts.Remove(prev);</span><br><span class="line">                &#125;</span><br><span class="line">                counts.TryAdd(next, <span class="number">0</span>);</span><br><span class="line">                counts[next]++;</span><br><span class="line">                <span class="keyword">if</span> (counts[next] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counts.Remove(next);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (counts.Count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    substrings.Add(start);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> substrings;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0031——下一个排列</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30031%E2%80%94%E2%80%94%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/next-permutation/">下一个排列</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。<br>
必须<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>原地</strong></a>修改，只允许使用额外常数空间。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,2,3]<br>
<strong>输出</strong>：[1,3,2]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [3,2,1]<br>
<strong>输出</strong>：[1,2,3]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,1,5]<br>
<strong>输出</strong>：[1,5,1]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>如果数组存在更大的排列，那么一定存在一个下标<code>i</code>和<code>j</code>满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]&lt;nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，为了找到下一个更大的排列，应该选取符合要求的最大下标<code>i</code>，在<code>nums[i]</code>右侧寻找大于<code>nums[i]</code>的最小元素并将该元素与<code>nums[i]</code>交换，之后将<code>nums[i]</code>右侧的全部元素按照升序排列，就可以得到下一个排列</p>
<p>如果数组<code>nums</code>不存在更大的排列，就将整个数组反转得到单调递增的数组。就可以得到下一个排列</p>
<p>做法如下：</p>
<ul>
<li>反向遍历数组<code>nums</code>，找到符合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[index_1]&lt;nums[index_1+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的最大下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">index_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。如果没有找到符合条件的下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">index_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index_1=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">index_1\geq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则找到符合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[index_1]&lt;nums[index_2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 的最大下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">index_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么一定有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">index_1&lt;index_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[index_1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[index_2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 交换，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">index_1&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则不执行</li>
<li>将数组<code>nums</code>从下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index_1+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到末尾的子数组反转（如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index_1=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 就将整个数组反转），最后就可以得到下一个排列</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        NextPermutation(nums);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> x <span class="keyword">in</span> nums)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(x + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NextPermutation</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = nums.Length;</span><br><span class="line">        <span class="built_in">int</span> index1 = length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> &amp;&amp; nums[index1] &gt;= nums[index1 + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            index1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index1 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index2 = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[index1] &gt;= nums[index2])</span><br><span class="line">            &#123;</span><br><span class="line">                index2--;</span><br><span class="line">            &#125;</span><br><span class="line">            Swap(nums, index1, index2);</span><br><span class="line">        &#125;</span><br><span class="line">        Reverse(nums, index1 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> index1, <span class="built_in">int</span> index2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reverse</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> start</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = start, j = nums.Length - <span class="number">1</span>; i &lt; j; i++, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            Swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0032——最长有效括号</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30032%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “(()”<br>
<strong>输出</strong>：2</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “)()())”<br>
<strong>输出</strong>：4</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “”<br>
<strong>输出</strong>：0</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>任意的有效括号字符串满足以下条件：</p>
<ul>
<li>有效括号字符串中的左括号个数与右括号个数相等</li>
<li>从左到右遍历有效括号字符串的过程中，任何时候遍历到左括号的个数都不会大于右括号的个数</li>
<li>从右到左遍历有效括号字符串的过程中，任何时候遍历到右括号的个数倒不会大于左括号的个数</li>
</ul>
<p>所以，可以从两个方向来遍历字符串并计算出最长有效括号</p>
<p>从左到右遍历的时候，维护左括号和右括号的计数：</p>
<ul>
<li>如果左括号与右括号的个数相等，则使用左右括号的计数之和来更新最大值</li>
<li>如果右括号的个数大于左括号的个数，那么不可能是有效括号字符串，需要将左右括号的计数全部清零</li>
</ul>
<p>从右到左遍历的时候，维护左括号和右括号的计数：</p>
<ul>
<li>如果右括号和左括号的个数相等，则使用左右括号的计数之和来更新最大值</li>
<li>如果左括号的个数大于右括号的个数，那么不可能是有效括号字符串，需要将左右括号的计数全部清零</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution sln = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;)()())&quot;</span>;</span><br><span class="line">        <span class="built_in">int</span> n = sln.LongestValidParentheses(s);</span><br><span class="line">        Console.WriteLine(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LongestValidParentheses</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> maxLength1 = GetMaxLength(s, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="built_in">int</span> maxLength2 = GetMaxLength(s, s.Length - <span class="number">1</span>, <span class="number">-1</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.Max(maxLength1, maxLength2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetMaxLength</span>(<span class="params">String s, <span class="built_in">int</span> start, <span class="built_in">int</span> direction, <span class="built_in">char</span> ch</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> n = s.Length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = start, j = <span class="number">0</span>; j &lt; n; i += direction, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == ch)</span><br><span class="line">            &#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count1 == count2)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLength = Math.Max(maxLength, count1 + count2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count1 &lt; count2)</span><br><span class="line">            &#123;</span><br><span class="line">                count1 = <span class="number">0</span>;</span><br><span class="line">                count2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0033——搜索旋转排序数组</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30033%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。<br>
在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。<br>
给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。<br>
你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [4,5,6,7,0,1,2], target = 0<br>
<strong>输出</strong>：4</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [4,5,6,7,0,1,2], target = 3<br>
<strong>输出</strong>：-1</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1], target = 0<br>
<strong>输出</strong>：-1</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>采用二分法可以解决这道题，如果数组经过旋转，那么旋转之后的数组首元素一定大于数组最后一个元素，所以，对于任意一个元素来说，都可以根据其与首元素或尾元素的大小比较来确定它在哪一个子序列中</p>
<p>用<code>low</code>和<code>high</code>分别表示二分查找的下标范围的上界和下界，初始时<code>low</code>和<code>high</code>分别为数组的最小和最大下标，每次查找的时候，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>可能是一个有序子数组或者两个有序子数组，取<code>mid</code>为<code>low</code>和<code>high</code>的平均数向下取整，判断该数是否等于目标值以及位于哪个子数组中，调整查找范围</p>
<p>具体步骤为：</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]=target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，则找到目标值，返回下标<code>mid</code></li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[low]\leq nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>，则下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中有一个或者有两个有序子数组，下标<code>mid</code>位于以下标<code>low</code>开始的有序子数组中，此时将目标值与<code>nums[low]</code>和<code>nums[mid]</code>比较，调整查找的下标范围
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo>≤</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[low] \leq target &lt; nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>，则如果目标值存在，一定位于下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,mid-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,mid-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中继续查找</li>
<li>如果不在上述范围内，那么一定位于下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[mid+1,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[mid+1,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中继续查找</li>
</ul>
</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[low]&gt;nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>，则下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中有两个有序子数列，下标<code>mid</code>位于以下标<code>high</code>结束的有序子数组中，此时将目标值与<code>nums[high]</code>和<code>nums[mid]</code>进行比较，调整查找的下标范围
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[mid]&lt;target\leq nums[high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>，则如果目标值存在，一定位于下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[mid+1,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[mid+1,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中继续查找</li>
<li>如果不在上述范围内，那么一定位于下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,mid-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,mid-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中继续查找</li>
</ul>
</li>
<li>如果查找的过程中出现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>&gt;</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">low&gt;high</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span></span></span></span>，那么目标值不存在，返回-1</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> res = Search(nums, target);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> low = <span class="number">0</span>, high = nums.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[low] &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[low] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= nums[high] &amp;&amp; target &gt; nums[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0034——在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30034%E2%80%94%E2%80%94%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。<br>
如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。<br>
你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [5,7,7,8,8,10], target = 8<br>
<strong>输出</strong>：[3,4]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [5,7,7,8,8,10], target = 6<br>
<strong>输出</strong>：[-1,-1]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：nums = [], target = 0<br>
<strong>输出</strong>：[-1,-1]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>利用二分查找，分别找到开始位置和结束位置</p>
<p>用<code>low</code>和<code>high</code>分别表示二分查找的下标范围的上界和下界，初始时<code>low</code>和<code>high</code>分别为数组的最小下标和最大下标。每次查找时，取<code>mid</code>为<code>low</code>和<code>high</code>的平均数，判断下标<code>mid</code>处的数和目标值的大小关系，调整查找的下标范围</p>
<p>查找目标值<code>target</code>的开始位置时，每次查找取<code>mid</code>为<code>low</code>和<code>high</code>的平均数<strong>向下</strong>取整，执行如下操作：</p>
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>≥</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid] \geq target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，则如果目标值存在，其开始位置小于等于<code>mid</code>，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>中继续查找</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，则如果目标值存在，其开始位置大于mid，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[mid+1,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中继续查找</li>
<li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>=</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">low=high</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span></span></span></span>时，查找结束，查找结束之后，如果下标<code>low</code>在数组下标范围中且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[low]=target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，则<code>low</code>时目标值的开始位置，返回<code>low</code>，否则数组中不存在目标值，返回<code>-1</code></li>
</ul>
<p>查找目标值<code>target</code>的结束位置时，每次查找取<code>mid</code>为<code>low</code>和<code>high</code>的平均数<strong>向上</strong>取整，执行如下操作：</p>
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>≤</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]\leq target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，则如果目标值存在，其开始位置大于等于<code>mid</code>，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[mid,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中继续查找</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，则如果目标值存在，其开始位置小于<code>mid</code>因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,mid-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中继续查找</li>
<li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>=</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">low=high</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span></span></span></span>时，查找结束。查找结束之后，如果下标<code>low</code>时目标值的结束位置，返回<code>low</code>，否则数组中不存在目标值，返回<code>-1</code></li>
</ul>
<p>得到目标值的开始位置结束位置之后（如果目标值不存在则开始位置和结束位置都是−1），返回目标值的开始位置和结束位置。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">int</span>[] res = SearchRange(nums, target);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(x + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">SearchRange</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> start = SearchStart(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> end = SearchEnd(nums, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; start, end &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SearchStart</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> low = <span class="number">0</span>, high = nums.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low &lt; nums.Length &amp;&amp; nums[low] == target ? low : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SearchEnd</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> low = <span class="number">0</span>, high = nums.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = low + (high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low &lt; nums.Length &amp;&amp; nums[low] == target ? low : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0035——搜索插入位置</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30035%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>
请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,3,5,6], target = 5<br>
<strong>输出</strong>：2</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,3,5,6], target = 2<br>
<strong>输出</strong>：1</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,3,5,6], target = 7<br>
<strong>输出</strong>：4</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>由题所要求的必须使用时间复杂度为<code>O(log n)</code>的算法，所以要采用二分查找<br>
用<code>low</code>和<code>high</code>分别表示二分查找的下标范围的上界和下界，初始时<code>low</code>和<code>high</code>分别为数组的最小下标和最大下标。每次查找时，取<code>mid</code>为<code>low</code>和<code>high</code>的平均数，判断下标<code>mid</code>处的数和目标值的大小关系，调整查找的下标范围</p>
<p>查找目标值<code>target</code>的时，执行如下操作：</p>
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，则如果目标值存在，其位置小于等于<code>mid</code>，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[low,mid-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中继续查找</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，则如果目标值存在，其位置大于<code>mid</code>，因此在下标范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[mid+1,high]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">]</span></span></span></span>中继续查找</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]==target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，直接返回<code>mid</code></li>
<li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>=</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">low=high</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span></span></span></span>时，查找结束，查找结束之后，如果数组中存在目标值，返回<code>mid</code>，否则数组中不存在目标值，返回<code>mid + 1</code></li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">9</span>;</span><br><span class="line">        <span class="built_in">int</span> res = SearchInsert(nums, target);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SearchInsert</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> low = <span class="number">0</span>, high = nums.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0036——有效的数独</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30036%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/valid-sudoku/">有效的数独</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要** 根据以下规则** ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>空白格用 <code>'.'</code> 表示。</li>
</ul>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0036_1.png" alt="示例图片"></p>
<blockquote>
<p><strong>输入</strong>：board =<br>
[[“5”,“3”,&quot;.&quot;,&quot;.&quot;,“7”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]<br>
,[“6”,&quot;.&quot;,&quot;.&quot;,“1”,“9”,“5”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]<br>
,[&quot;.&quot;,“9”,“8”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”,&quot;.&quot;]<br>
,[“8”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“3”]<br>
,[“4”,&quot;.&quot;,&quot;.&quot;,“8”,&quot;.&quot;,“3”,&quot;.&quot;,&quot;.&quot;,“1”]<br>
,[“7”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“2”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”]<br>
,[&quot;.&quot;,“6”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“2”,“8”,&quot;.&quot;]<br>
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“4”,“1”,“9”,&quot;.&quot;,&quot;.&quot;,“5”]<br>
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“8”,&quot;.&quot;,&quot;.&quot;,“7”,“9”]]<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：board =<br>
[[“8”,“3”,&quot;.&quot;,&quot;.&quot;,“7”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]<br>
,[“6”,&quot;.&quot;,&quot;.&quot;,“1”,“9”,“5”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]<br>
,[&quot;.&quot;,“9”,“8”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”,&quot;.&quot;]<br>
,[“8”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“3”]<br>
,[“4”,&quot;.&quot;,&quot;.&quot;,“8”,&quot;.&quot;,“3”,&quot;.&quot;,&quot;.&quot;,“1”]<br>
,[“7”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“2”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”]<br>
,[&quot;.&quot;,“6”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“2”,“8”,&quot;.&quot;]<br>
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“4”,“1”,“9”,&quot;.&quot;,&quot;.&quot;,“5”]<br>
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“8”,&quot;.&quot;,&quot;.&quot;,“7”,“9”]]<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>可以直接使用二位数组来进行一次遍历</p>
<p>创建二维数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>分别记录数独的每一行和每一列中的数字的出现次数，创建三维数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>b</mi><mi>o</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">subbox</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span></span></span></span>记录数度中每一个小宫格的数字的出现次数，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo><mtext>，</mtext><mi>c</mi><mi>o</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>s</mi><mi>u</mi><mi>b</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">[</mo><mo stretchy="false">[</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>i</mi><mn>3</mn></mfrac></mstyle><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>j</mi><mn>3</mn></mfrac></mstyle><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">row[i][index]，col[j][index],subbox[[\dfrac{i}{3}],[\dfrac{j}{3}],index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.02252em;vertical-align:-0.686em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>分别表示数独的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>行第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>列的单元格所在的行、列和小九宫格中，数字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>出现的次数，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>&lt;</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\leq index&lt;9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>，对应的数字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">1\leq index+1 \leq 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span></p>
<p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">board[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>填入了数字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mtext>、</mtext><mi>c</mi><mi>o</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">row[i][n-1]、col[j][n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo stretchy="false">[</mo><mo stretchy="false">[</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>i</mi><mn>3</mn></mfrac></mstyle><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>j</mi><mn>3</mn></mfrac></mstyle><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">subbox[[\dfrac{i}{3}],[\dfrac{j}{3}],index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.02252em;vertical-align:-0.686em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>各加一，则不符合有效的数独条件，返回false</p>
<p>如果遍历结束之后没有出现计数大于一的情况，则符合有效的数独的条件，返回true</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[][] board =<span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">9</span>][]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;3&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;5&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span> &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">bool</span> res = IsValidSudoku(board);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsValidSudoku</span>(<span class="params"><span class="built_in">char</span>[][] board</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[,] row = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">9</span>,<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">int</span>[,] col = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">9</span>,<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">int</span>[,,] subbox = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>, <span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">char</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> index = c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    row[i, index]++;</span><br><span class="line">                    col[j, index]++;</span><br><span class="line">                    subbox[i / <span class="number">3</span>, j / <span class="number">3</span>, index]++;</span><br><span class="line">                    <span class="keyword">if</span> (row[i, index] &gt; <span class="number">1</span> || col[j, index] &gt; <span class="number">1</span> || subbox[i / <span class="number">3</span>, j / <span class="number">3</span>, index] &gt; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0037——解数独</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30037%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/sudoku-solver/">解数独</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>编写一个程序，通过填充空格来解决数独问题。<br>
数独的解法需** 遵循如下规则**：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0036_1.png" alt="示例图片"></p>
<blockquote>
<p><strong>输入</strong>：board = [[“5”,“3”,&quot;.&quot;,&quot;.&quot;,“7”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[“6”,&quot;.&quot;,&quot;.&quot;,“1”,“9”,“5”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,“9”,“8”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”,&quot;.&quot;],[“8”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“3”],[“4”,&quot;.&quot;,&quot;.&quot;,“8”,&quot;.&quot;,“3”,&quot;.&quot;,&quot;.&quot;,“1”],[“7”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“2”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“6”],[&quot;.&quot;,“6”,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“2”,“8”,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“4”,“1”,“9”,&quot;.&quot;,&quot;.&quot;,“5”],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,“8”,&quot;.&quot;,&quot;.&quot;,“7”,“9”]]<br>
<strong>输出</strong>：[[“5”,“3”,“4”,“6”,“7”,“8”,“9”,“1”,“2”],[“6”,“7”,“2”,“1”,“9”,“5”,“3”,“4”,“8”],[“1”,“9”,“8”,“3”,“4”,“2”,“5”,“6”,“7”],[“8”,“5”,“9”,“7”,“6”,“1”,“4”,“2”,“3”],[“4”,“2”,“6”,“8”,“5”,“3”,“7”,“9”,“1”],[“7”,“1”,“3”,“9”,“2”,“4”,“8”,“5”,“6”],[“9”,“6”,“1”,“5”,“3”,“7”,“2”,“8”,“4”],[“2”,“8”,“7”,“4”,“1”,“9”,“6”,“3”,“5”],[“3”,“4”,“5”,“2”,“8”,“6”,“1”,“7”,“9”]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>使用递归算法，创建三个字典列表，分别为<code>liRow</code>，<code>liCol</code>，<code>liBox</code>，分别表示九行，九列和九个格子，再定义一个用来临时存储结果的二维数组<code>boardAllres</code></p>
<p>主要步骤如下：</p>
<ul>
<li>先判断一开始总共由多少个数字：
<ul>
<li>创建一个字典<code>dicAllTemp</code>来存储数字是否出现过</li>
<li>先对<code>dicAllTemp</code>赋初始值为false，然后将对应的字典索引值添加到<code>liRow</code>，<code>liCol</code>，<code>liBox</code>中</li>
<li>对整个集合进行遍历，如果当前元素的值不为<code>'.'</code>，那么就将当前单元格所对应的三个字典列表全部设置为<code>True</code>，并让计数<code>hasNumCount</code>自增</li>
</ul>
</li>
<li>之后就要完成回溯函数
<ul>
<li>先进行判断，如果计数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>N</mi><mi>u</mi><mi>m</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>=</mo><mo>=</mo><mn>81</mn></mrow><annotation encoding="application/x-tex">hasNumCount == 81</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">1</span></span></span></span>，那么直接将结果存储到<code>boardAllres</code>中并返回</li>
<li>遍历当前集合，如果当前元素为<code>'.'</code>，那么就查出该行还未使用过的数字，判断它位于哪一个格子，将<code>hasNumCount</code>自增，并将此单元格再三个字典列表对应的值设置为<code>True</code>并将结果存储到传入的二维数组<code>board</code>中</li>
<li>对回溯函数本身进行递归，如果符合要求就返回<code>True</code>，不符合要求就撤回当前操作</li>
</ul>
</li>
<li>当函数遍历完成，就可以将<code>boardAllres</code>的结果赋值给最终结果</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; liRow = <span class="keyword">new</span> List&lt;Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt;();</span><br><span class="line">    List&lt;Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; liCol = <span class="keyword">new</span> List&lt;Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt;();</span><br><span class="line">    List&lt;Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; liBox = <span class="keyword">new</span> List&lt;Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt;();</span><br><span class="line">    <span class="built_in">char</span>[][] boardAllres = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[][] board = <span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">9</span>][]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;3&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;5&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        solution.SolveSudoku(board);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> board)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SolveSudoku</span>(<span class="params"><span class="built_in">char</span>[][] board</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dic.Add(i, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            liRow.Add(<span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;(dic));</span><br><span class="line">            liCol.Add(<span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;(dic));</span><br><span class="line">            liBox.Add(<span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;(dic));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; board.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> temp = board[i][j] - <span class="number">48</span>;</span><br><span class="line">                    liRow[i][temp] = <span class="literal">true</span>;</span><br><span class="line">                    liCol[j][temp] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">int</span> acount = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                    liBox[acount][temp] = <span class="literal">true</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReCursive(board, count, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        board = boardAllres;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ReCursive</span>(<span class="params"><span class="built_in">char</span>[][] board, <span class="built_in">int</span> acount, <span class="built_in">int</span> i, <span class="built_in">int</span> j</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (acount == <span class="number">81</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            boardAllres = board;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; board.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;<span class="built_in">int</span>&gt; liRes = liRow[i].Where(e =&gt; e.Value == <span class="literal">false</span>).Select(e =&gt; e.Key).ToList();</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> liRes)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">int</span> count = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">if</span> (liCol[j][item] == <span class="literal">false</span> &amp;&amp; liBox[count][item] == <span class="literal">false</span> &amp;&amp; liRow[i][item] == <span class="literal">false</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            acount++;</span><br><span class="line">                            liRow[i][item] = <span class="literal">true</span>;</span><br><span class="line">                            liCol[j][item] = <span class="literal">true</span>;</span><br><span class="line">                            liBox[count][item] = <span class="literal">true</span>;</span><br><span class="line">                            board[i][j] = (<span class="built_in">char</span>)(item + <span class="number">48</span>);</span><br><span class="line">                            <span class="keyword">if</span> (ReCursive(board, acount, i, <span class="number">0</span>))</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            acount--;</span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                            liRow[i][item] = <span class="literal">false</span>;</span><br><span class="line">                            liCol[j][item] = <span class="literal">false</span>;</span><br><span class="line">                            liBox[count][item] = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0038——外观数列</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30038%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/count-and-say/">外观数列</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。<br>
「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。<br>
你可以将其视作是由递归公式定义的数字字符串序列：</p>
<ul>
<li><code>countAndSay(1) = &quot;1&quot;</code></li>
<li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li>
</ul>
<p>前五项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">第一项是数字 1 </span><br><span class="line">描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;</span><br><span class="line">描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;</span><br><span class="line">描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;</span><br><span class="line">描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</span><br></pre></td></tr></table></figure>
<p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p>
<p>例如，数字字符串 <code>&quot;3322251&quot;</code> 的描述如下图：</p>
<p><img src="/images/ltc0038_1.png" alt="示例图片"></p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：n = 1<br>
<strong>输出</strong>：“1”</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：n = 4<br>
<strong>输出</strong>：“1211”</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>直接进行遍历，定义字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示<em>countAndSay(i)</em>，如果要求得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则需要求出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，然后按照上述的方法生成，即从左到右依次扫描字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>中连续相同的字符的最大数目，然后将字符的统计数目转化为数字字符再连接上对应的字符，已知<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为<code>&quot;1&quot;</code>，就可以依次生成其他</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">string</span> res = CountAndSay(n);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">CountAndSay</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (pos &lt; str.Length &amp;&amp; str[pos] == str[start])</span><br><span class="line">                &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.Append(pos - start).Append(str[start]);</span><br><span class="line">                start = pos;</span><br><span class="line">            &#125;</span><br><span class="line">            str = sb.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0039——组合总数</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30039%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/combination-sum/">组合总数</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。<br>
<code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>
对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：candidates = [2,3,6,7], target = 7<br>
<strong>输出</strong>：[[2,2,3],[7]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：candidates = [2,3,5], target = 8<br>
<strong>输出</strong>：[[2,2,2,2],[2,3,3],[3,5]]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：candidates = [2], target = 1<br>
<strong>输出</strong>：[]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>直接利用回溯法，先用一个数取尽，再取下一个数，如果下一个数无法取得，就取出一个数继续尝试，直到最后的值减到0</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; res = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] candidates = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">7</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; result = solution.CombinationSum(candidates, target);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; CombinationSum(<span class="built_in">int</span>[] candidates, <span class="built_in">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        Recall(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Recall</span>(<span class="params"><span class="built_in">int</span>[] cadidates, <span class="built_in">int</span> target, <span class="built_in">int</span> start</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = start; i &lt; cadidates.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.Add(cadidates[i]);</span><br><span class="line">            Recall(cadidates,target - cadidates[i], start);</span><br><span class="line">            list.RemoveAt(list.Count - <span class="number">1</span>);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0040——组合总数II</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30040%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和 II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<br>
<code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。<br>
<strong>注意</strong>：解集不能包含重复的组合。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：candidates = [10,1,2,7,6,1,5], target = 8,<br>
<strong>输出</strong>：<br>
[<br>
[1,1,6],<br>
[1,2,5],<br>
[1,7],<br>
[2,6]<br>
]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：candidates = [2,5,2,1,2], target = 5,<br>
<strong>输出</strong>：<br>
[<br>
[1,2,2],<br>
[5]<br>
]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>使用回溯法，先声名一个<code>List</code>数组存放<code>dandidates</code>中的不同数字的val和出现的次数，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">target&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，用<code>target</code>除以当前<code>pos</code>位置的<code>curList[pos][0]</code>的<code>val</code>，比较获取应该减去的次数，开始循环，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo>+</mo><mn>1</mn><mtext>，</mtext><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>−</mo><mi>c</mi><mi>u</mi><mi>r</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mtext>，</mtext><mi>r</mi><mi>e</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>A</mi><mi>d</mi><mi>d</mi><mo stretchy="false">(</mo><mi>c</mi><mi>u</mi><mi>r</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">pos+1，target-curList[pos][0]，reList.Add(curList[pos][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>，通过这个<code>list</code>数组记录<code>val</code>和出现次数</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">    IList&lt;IList&lt;int&gt;&gt; res = new List&lt;IList&lt;int&gt;&gt;();</span><br><span class="line">    IList&lt;int&gt; list = new List&lt;int&gt;();</span><br><span class="line">    IList&lt;int[]&gt; curList = new List&lt;int[]&gt;();</span><br><span class="line"></span><br><span class="line">    public static void Main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int[] candidates = &#123; 2, 5, 2, 1, 2 &#125;;</span><br><span class="line">        int target = 5;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        IList&lt;IList&lt;int&gt;&gt; result = solution.CombinationSum2(candidates, target);</span><br><span class="line">        foreach (var a in result)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var b in a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IList&lt;IList&lt;int&gt;&gt; CombinationSum2(int[] candidates, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        Array.Sort(candidates);</span><br><span class="line">        int len = candidates.Length;</span><br><span class="line">        for (int i = 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (curList.Count == 0 || curList[curList.Count - 1][0] != candidates[i])</span><br><span class="line">            &#123;</span><br><span class="line">                curList.Add(new int[] &#123; candidates[i], 1 &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ++curList[curList.Count - 1][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Recall(target, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Recall(int target, int pos)</span><br><span class="line">    &#123;</span><br><span class="line">        if (target == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            res.Add(new List&lt;int&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pos &gt;= curList.Count || target &lt; curList[pos][0])</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Recall(target, pos + 1);</span><br><span class="line">        int min = Math.Min(target / curList[pos][0], curList[pos][1]);</span><br><span class="line">        for (int i = 1; i &lt;= min; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.Add(curList[pos][0]);</span><br><span class="line">            Recall(target - i * curList[pos][0], pos + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= min; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.RemoveAt(list.Count - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0041——缺失的第一个正数</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30041%E2%80%94%E2%80%94%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/first-missing-positive/">缺失的第一个正数</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。<br>
请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,2,0]<br>
<strong>输出</strong>：3</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [3,4,-1,1]<br>
<strong>输出</strong>：2</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：nums = [7,8,9,11,12]<br>
<strong>输出</strong>：1</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>先过滤负数和零，然后进行升序排列，得到的数列如果都大于<code>1</code>，那么直接返回<code>1</code>，其他的情况就是集合内相邻的两个数相减，如果结果大于<code>1</code>，就说明缺失的正数在这两个数之间，返回小值加一即可，如果上述条件都不符合，就返回最大值加一</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> res = solution.FirstMissingPositive(nums);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FirstMissingPositive</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> li = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(nums).Where(c =&gt; c &gt; <span class="number">0</span>).ToList();</span><br><span class="line">        <span class="keyword">if</span> (li.Count &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        li.Sort();</span><br><span class="line">        <span class="keyword">if</span> (li.First() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; li.Count - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> c = li[i + <span class="number">1</span>] - li[i];</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> li[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> li[li.Count - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0042——接雨水</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30042%E2%80%94%E2%80%94%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0042_1.png" alt="示例图片"></p>
<blockquote>
<p><strong>输入</strong>：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>
<strong>输出</strong>：6</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：height = [4,2,0,3,2,5]<br>
<strong>输出</strong>：9</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 处的雨水能达到的高度等于其两边的最大高度的最小值，下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 处的雨水能达到的高度与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">height[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 之差即为下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 处的雨水量</p>
<p>创建两个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">leftHeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rightHeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mtext>，</mtext><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">0\leq i&lt;n，leftHeight[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">height</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 在下标范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 内的最大元素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">rightHeight[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 在下标范围内 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 内的最大元素</p>
<p>计算方法如下：</p>
<ul>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">leftHeight,leftHeight[0]=height[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0\leq i&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">leftHeight[i]=max(leftHeight[i-1],height[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，从左到右依次计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">leftHeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 的值</li>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">rightHeight,rightHeight[n-1]=height[n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，当  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\leq i&lt;n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">rightHeight[i]=max(rightHeight[i+1],height[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，从右到左依次计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rightHeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 的值</li>
</ul>
<p>最后数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">leftHeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rightHeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 之后，即可计算每个下标的雨水量，下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 处的雨水能达到的高度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">min(leftHeight[i],rightHeight[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>，因此下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 处的雨水量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>−</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">min(leftHeight[i],rightHeight[i])-height[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。遍历每一个下标，计算每个下标的雨水量，即可得到能接的雨水总量</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] height = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> res = solution.Trap(height);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Trap</span>(<span class="params"><span class="built_in">int</span>[] height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = height.Length;</span><br><span class="line">        <span class="built_in">int</span>[] leftHeight = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        leftHeight[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            leftHeight[i] = Math.Max(leftHeight[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span>[] rightHeight = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        rightHeight[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            rightHeight[i] = Math.Max(rightHeight[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> amout = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            amout += Math.Min(leftHeight[i], rightHeight[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> amout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0043——字符串相乘</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30043%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/multiply-strings/">字符串相乘</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。<br>
**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：num1 = “2”, num2 = “3”<br>
<strong>输出</strong>：“6”</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：num1 = “123”, num2 = “456”<br>
<strong>输出</strong>：“56088”</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>创建一个字符串构造器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>，内部初始值为<code>'0'</code>，长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">num1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">num2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">2</span></span></span></span>的和，对两个字符串从右到左遍历。</p>
<p>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的位置赋值：</p>
<ul>
<li>定义一个 <code>next=sum[i+j+1]-'0'+(num1[i]-'0')*(num2[j]-'0')</code>，因为两个字符串内的单个元素为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">char</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，所以需要减去一个<code>'0'</code>来讲他转换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">int</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 类型</li>
<li>将 <code>next\%10+'0'</code> 的值转换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">char</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 类型之后将结果存入到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum[i+j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的位置进行赋值</p>
<ul>
<li>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi mathvariant="normal">/</mi><mn>10</mn></mrow><annotation encoding="application/x-tex">next/10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span></span></span></span>的值转换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">char</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 类型之后将结果存入到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum[i+j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 中</li>
</ul>
<p>最后定义一个字符串<code>res</code>，将sum从头删除为<code>'0'</code>的元素之后转换为字符串<br>
如果<code>res</code>的长度为0，那么直接返回<code>&quot;0&quot;</code>，否则直接返回<code>res</code></p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> num1 = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> num2 = <span class="string">&quot;987654321&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> res = solution.Multiply(num1, num2);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">string</span> num1, <span class="built_in">string</span> num2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sum = <span class="keyword">new</span> StringBuilder(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&#x27;0&#x27;</span>, num1.Length + num2.Length));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = num1.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = num2.Length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> next = sum[i + j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                sum[i + j + <span class="number">1</span>] = (<span class="built_in">char</span>)(next % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                sum[i + j] += (<span class="built_in">char</span>)(next / <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res = sum.ToString().TrimStart(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.Length == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0044——通配符匹配</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30044%E2%80%94%E2%80%94%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/wildcard-matching/">通配符匹配</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个输入字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，请你实现一个支持 <code>'?'</code> 和 <code>'*'</code> 匹配规则的通配符匹配：</p>
<ul>
<li><code>'?'</code> 可以匹配任何单个字符。</li>
<li><code>'*'</code> 可以匹配任意字符序列（包括空字符序列）。</li>
</ul>
<p>判定匹配成功的充要条件是：字符模式必须能够 <strong>完全匹配</strong> 输入字符串（而不是部分匹配）。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：s = “aa”, p = “a”<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：s = “aa”, p = “*”<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：s = “cb”, p = “?a”<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是否匹配，需要分别考虑 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的每个前缀，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 分别表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的长度。对于满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\leq j\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\leq i\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的每个下标对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，需要分别计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个字符和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个字符是否匹配</p>
<p>创建 <code>(m+1)*(n+1)</code> 的二维数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>，其中 <code>dp[i][j]</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个字符和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个字符是否匹配</p>
<p>当 <code>j=0</code> 时，模式为空，只有空字符串可以匹配，因此动态规划的结果：当 <code>i=0</code> 时，<code>dp[i][j]=true</code>；当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，<code>dp[i][0]=false</code></p>
<p>当 <code>j&gt;0</code> 时，动态规划的状态转移方程如下：</p>
<ul>
<li>当 <code>i=0</code> 且 <code>j&gt;0</code> 时，如果 <code>p[j-1]='*'</code>且 <code>dp[i][j-1]=true</code> 则 <code>dp[i][j]=true</code>，否则 <code>dp[i][j]=false</code></li>
<li>当 <code>i&gt;0</code> 且 <code>j&gt;0</code> 时，考虑以下情况
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><msup><mo mathvariant="normal">≠</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mo>∗</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p[j-1]\neq &#x27;*&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0862319999999999em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.836232em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mbin">∗</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> ，则当 <code>dp[i-1][j-1]=true</code> 且 <code>s[i-1]，p[j-1]</code> 满足字符匹配时 <code>dp[i][j]=true</code>，否则<code>dp[i][j]=false</code></li>
<li>如果 <code>p[j-1]='*'</code> ，则当 <code>dp[i][j-1]=true</code> 或 <code>dp[i-1][j]=true</code> 时 <code>dp[i][j]=true</code>，否则 <code>dp[i][j]=false</code></li>
</ul>
</li>
</ul>
<p>根据动态规划的状态转移方程，计算 <code>dp[i][j]</code> 的顺序为从小到大遍历每一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 从小到大遍历每一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>。计算得到 <code>dp[i][j]</code></p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> p = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">bool</span> res = solution.IsMatch(s,p);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsMatch</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = s.Length, n = p.Length;</span><br><span class="line">        <span class="built_in">bool</span>[] dp = <span class="keyword">new</span> <span class="built_in">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span>[] dpNew = <span class="keyword">new</span> <span class="built_in">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">char</span> c1 = s[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">char</span> c2 = p[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (c2 != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dpNew[j] = dp[j - <span class="number">1</span>] &amp;&amp; IsCharacterMatch(c1, c2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dpNew[j] = dpNew[j - <span class="number">1</span>] || dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = dpNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsCharacterMatch</span>(<span class="params"><span class="built_in">char</span> c1, <span class="built_in">char</span> c2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c1 == c2 || c2 == <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0045——跳跃游戏II</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30045%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。<br>
每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code></li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [2,3,1,1,4]<br>
<strong>输出</strong>：2</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [2,3,0,1,4]<br>
<strong>输出</strong>：2</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>使用贪心算法计算到达下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的最小跳跃次数</p>
<p>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">currentJumps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 表示当前跳跃次数，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">currentMaxPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nextMaxPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span> 分别表示跳跃次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">currentJumps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 能够到达的最远距离和跳跃次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">currentJumps+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 可以到达的最远距离，初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi><mo>=</mo><mn>0</mn><mtext>，</mtext><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mn>0</mn><mtext>，</mtext><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">currentJumps=0，currentMaxPosition=0，nextMaxPosition=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>从左到右遍历数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，对每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0\leq i&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，执行如下操作：</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">i&gt;currentMaxPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>，则下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 超出跳跃次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">currentJumps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 可以到达的下标，因此到达下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的最小跳跃次数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">currentJumps+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，需要更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">currentJumps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">currentMaxPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span> 的值；将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">currentJumps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 的值加<code>1</code>，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">currentMaxPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span> 的值更新为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nextMaxPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≤</mo><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">i\leq currentMaxPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>，则不执行更新操作</li>
<li>从下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 可以到达的最大下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i+nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。由于跳跃次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">currentJumps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 可以到达下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，因此跳跃次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">currentJumps+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 可以到达下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i+nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，跳跃次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">currentJumps+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 可以到达的最大下标不小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i+nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i+nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nextMaxPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span> 的值</li>
</ul>
<p>遍历结束之后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">currentJumps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span> 即为到达下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的最小跳跃次数</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> res = solution.Jump(nums);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Jump</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> currentJumps = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> currentMaxPosition = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> nextMaxPosition = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> len = nums.Length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; currentMaxPosition)</span><br><span class="line">            &#123;</span><br><span class="line">                currentJumps++;</span><br><span class="line">                currentMaxPosition = nextMaxPosition;</span><br><span class="line">            &#125;</span><br><span class="line">            nextMaxPosition = Math.Max(nextMaxPosition, nums[i] + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentJumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0046——全排列</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30046%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/permutations/">全排列</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 所有可能的全排列 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,2,3]<br>
<strong>输出</strong>：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [0,1]<br>
<strong>输出</strong>：[[0,1],[1,0]]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1]<br>
<strong>输出</strong>：[[1]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 表示数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 的长度，创建列表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span> 用于存储当前排列，将数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 中每个元素依次加入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span>，然后根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span> 生成全排列</p>
<p>为了得到数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 的全排列，需要依次确定排列中的每个位置的元素，可以通过交换 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span> 中的元素实现，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0\leq index&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，按照下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span></span></span></span> 从小到大的顺序依次确定每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 的值，即能得到一个排列</p>
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">index=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，可以将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 和任意一个元素交换（包括和自身交换），经过一次交换之后即可确定当前排列中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 的值</li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">index&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，如果当前排列中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[index-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的值都已经确定，则可以将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 和任意一个下标大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span></span></span></span> 的元素交换，经过一次交换之后即可确定当前排列中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 的值</li>
</ul>
<p>通过上述分析，可以利用回溯法，步骤如下：</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">index=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，则当前排列中的所有元素都已经确定，则将当前排列添加到结果列表中</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">index&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，则对于每一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">index\leq i&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，执行如下操作：
<ul>
<li>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的值交换，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 作为当前下标继续搜索</li>
<li>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">temp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的值再次交换，恢复到交换之前的状态</li>
</ul>
</li>
</ul>
<p>当每个下标对应的所有可能的值都遍历结束之后，就可以得到数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 的全排列</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; permutations = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">    IList&lt;<span class="built_in">int</span>&gt; temp = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="built_in">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; res = solution.Permute(nums);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; Permute(<span class="built_in">int</span>[] nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> nums)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.Add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        n = nums.Length;</span><br><span class="line">        BackTrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> permutations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == n)</span><br><span class="line">        &#123;</span><br><span class="line">            permutations.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = index; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(temp,index,i);</span><br><span class="line">                BackTrack(index+<span class="number">1</span>);</span><br><span class="line">                Swap(temp, index, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params">IList&lt;<span class="built_in">int</span>&gt; temp, <span class="built_in">int</span> index1, <span class="built_in">int</span> index2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> cur = temp[index1];</span><br><span class="line">        temp[index1] = temp[index2];</span><br><span class="line">        temp[index2] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0047——全排列II</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30047%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/permutations-ii/">全排列II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,1,2]<br>
<strong>输出</strong>：<br>
[[1,1,2],<br>
[1,2,1],<br>
[2,1,1]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1,2,3]<br>
<strong>输出</strong>：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 表示数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 的长度，创建列表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span> 用于存储当前排列，生成排列的做法是将数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 中的每个元素按照特定顺序依次加入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span>，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span> 中的元素个数等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 时，即可得到一个排列</p>
<p>在排列后的数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 中遍历到下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 时，一下两种情况不应将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 加入当前排列</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 已经加入当前数列，则不能多次加入当前排列</li>
<li>如果当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]=nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 未加入当前数列，则不能将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 加入当前数列</li>
</ul>
<p>其余情况下，执行如下操作</p>
<ul>
<li>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 加入当前排列，并将该元素的状态更新为已经加入当前排列，然后继续回溯</li>
<li>将当前排列末尾元素（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> ）移除，并将该元素的状态更新为未加入当前排列，恢复到原始状态</li>
</ul>
<p>遍历结束之后，即可得到数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 的无重复全排列</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; permutations = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">    IList&lt;<span class="built_in">int</span>&gt; temp = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="built_in">int</span>[] nums;</span><br><span class="line">    <span class="built_in">int</span> n;</span><br><span class="line">    <span class="built_in">bool</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; res = solution.PermuteUnique(nums);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; PermuteUnique(<span class="built_in">int</span>[] nums)</span><br><span class="line">    &#123;</span><br><span class="line">        Array.Sort(nums);</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">this</span>.n = nums.Length;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="built_in">bool</span>[n];</span><br><span class="line">        Backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> permutations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Backtrack</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == n)</span><br><span class="line">        &#123;</span><br><span class="line">            permutations.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.Add(nums[i]);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                Backtrack(index + <span class="number">1</span>);</span><br><span class="line">                temp.RemoveAt(index);</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0048——旋转图像</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30048%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个 n × n 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。<br>
你必须在<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>原地</strong></a>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0048_1.jpg" alt="示例图片_1"></p>
<blockquote>
<p><strong>输入</strong>：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>
<strong>输出</strong>：[[7,4,1],[8,5,2],[9,6,3]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0048_2.jpg" alt="示例图片_2"></p>
<blockquote>
<p><strong>输入</strong>：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>
<strong>输出</strong>：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>将最外圈进行旋转，左上转右上，以此类推，之后再旋转内圈即可</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[][] matrix = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        solution.Rotate(matrix);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> matrix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> j <span class="keyword">in</span> i)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rotate</span>(<span class="params"><span class="built_in">int</span>[][] matrix</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>].Length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">int</span> r = <span class="number">0</span>, c = matrix.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; matrix.Length / <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; (c - r); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = matrix[r][r + j];</span><br><span class="line">                matrix[r][r + j] = matrix[c - j][r];</span><br><span class="line">                matrix[c - j][r] = matrix[c][c - j];</span><br><span class="line">                matrix[c][c - j] = matrix[r + j][c];</span><br><span class="line">                matrix[r + j][c] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            c--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0049——字母异位词分组</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30049%E2%80%94%E2%80%94%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。<br>
<strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>
<strong>输出</strong>：[[“bat”],[“nat”,“tan”],[“ate”,“eat”,“tea”]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：strs = [&quot;&quot;]<br>
<strong>输出</strong>：[[&quot;&quot;]]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：strs = [“a”]<br>
<strong>输出</strong>：[[“a”]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>将字符串排序之后的有序字符串作为同一组字母异位词的标志，使用哈希表存储每个标志对应的所有字符串，则哈希表中的每个键值对表示一组字母异位词，其中关键字表示该组字母异位词的标志，值表示属于该组字母异位词的所有字符串组成的列表。<br>
遍历字符串数组，对于每个字符串，得到其所在的一组字母异位词的标志，将该字符串添加到该组中。遍历结束之后，返回哈希表的所有键值对中的值组成的列表。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>[] strs = &#123; <span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; res = solution.GroupAnagrams(strs);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; GroupAnagrams(<span class="built_in">string</span>[] strs)</span><br><span class="line">    &#123;</span><br><span class="line">        IDictionary&lt;<span class="built_in">string</span>,IList&lt;<span class="built_in">string</span>&gt;&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> str <span class="keyword">in</span> strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span>[] arr = str.ToCharArray();</span><br><span class="line">            Array.Sort(arr);</span><br><span class="line">            <span class="built_in">string</span> key = <span class="keyword">new</span> <span class="built_in">string</span>(arr);</span><br><span class="line">            dic.TryAdd(key,<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">            dic[key].Add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt;(dic.Values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0050——Pow(x,n)</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30050%E2%80%94%E2%80%94Pow-x-n/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/powx-n/">Pow(x,n)</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(x, n)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code>^^）。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：x = 2.00000, n = 10<br>
<strong>输出</strong>：1024.00000</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：x = 2.10000, n = 3<br>
<strong>输出</strong>：9.26100</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：x = 2.00000, n = -2<br>
<strong>输出</strong>：0.25000</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>将一个数 x 的 n 次方拆分成多个数的乘积，其中这些数可以通过对 x 的平方递归得到。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> x = <span class="number">2.1</span>;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">3</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">double</span> res = solution.MyPow(x, n);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">MyPow</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = n; i != <span class="number">0</span>; i /= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0051——N皇后</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30051%E2%80%94%E2%80%94N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/n-queens/">N皇后</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>
<strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>
给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。<br>
每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0051_1.jpg" alt="示例图片"></p>
<blockquote>
<p><strong>输入</strong>：n = 4<br>
<strong>输出</strong>：[[&quot;.Q…&quot;,&quot;…Q&quot;,“Q…”,&quot;…Q.&quot;],[&quot;…Q.&quot;,“Q…”,&quot;…Q&quot;,&quot;.Q…&quot;]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：n = 1<br>
<strong>输出</strong>：[[“Q”]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>使用回溯法，定义列表元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 来接受最后的结果</p>
<p>步骤如下：</p>
<ul>
<li>定义一个二位数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">board</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> ，大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，遍历每一个二维数组元素，将所有的元素的初始值都定义为<code>&quot;.&quot;</code>，之后进行回溯
<ul>
<li>如果行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的值等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">board</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 的长度，那么直接将结果添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 中</li>
<li>如果行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的值小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">board</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 的长度，执行如下操作
<ul>
<li>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为列数，对行内的每一个元素进行循环，如果当前行有<code>&quot;Q&quot;</code>，那么直接跳出本次循环，如果当前元素的左上或右上有<code>&quot;Q&quot;</code>，那么直接跳出本次循环</li>
<li>对当前元素赋值为<code>&quot;Q&quot;</code>，并继续进行回溯，如果最后的结果无法成立，那么回退此次操作</li>
<li>最后将结果传入到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 中，即可得到最终结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">4</span>;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; result = solution.SolveNQueens(n);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;\&quot;&quot;</span> + b + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; SolveNQueens(<span class="built_in">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">        <span class="built_in">char</span>[][] board = <span class="keyword">new</span> <span class="built_in">char</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) board[i] = <span class="keyword">new</span> <span class="built_in">char</span>[n];</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">char</span>[] chars <span class="keyword">in</span> board)</span><br><span class="line">        &#123;</span><br><span class="line">            Array.Fill(chars, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span>(<span class="params"><span class="built_in">char</span>[][] board, <span class="built_in">int</span> row</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == board.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            res.Add(charToString(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> n = board[row].Length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> col = <span class="number">0</span>; col &lt; n; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, row, col)) <span class="keyword">continue</span>;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backTrack(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">isValid</span>(<span class="params"><span class="built_in">char</span>[][] board, <span class="built_in">int</span> row, <span class="built_in">int</span> col</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> rows = board.Length;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">char</span>[] chars <span class="keyword">in</span> board)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; rows; i--, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">charToString</span>(<span class="params"><span class="built_in">char</span>[][] array</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; result = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">char</span>[] chars <span class="keyword">in</span> array) result.Add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0052——N皇后II</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30052%E2%80%94%E2%80%94N%E7%9A%87%E5%90%8EII/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/n-queens-ii/">N皇后II</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>
给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0051_1.jpg" alt="示例图片"></p>
<blockquote>
<p><strong>输入</strong>：n = 4<br>
<strong>输出</strong>：2</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：n = 1<br>
<strong>输出</strong>：1</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>使用回溯法，定义列表元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ilist</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span> ，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ilist.Count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 来接受最终结果</p>
<p>步骤如下：</p>
<ul>
<li>定义一个二位数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">board</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> ，大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，遍历每一个二维数组元素，将所有的元素的初始值都定义为<code>&quot;.&quot;</code>，之后进行回溯
<ul>
<li>如果行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的值等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">board</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 的长度，那么直接将结果添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ilist</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span> 中</li>
<li>如果行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的值小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">board</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 的长度，执行如下操作
<ul>
<li>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为列数，对行内的每一个元素进行循环，如果当前行有<code>&quot;Q&quot;</code>，那么直接跳出本次循环，如果当前元素的左上或右上有<code>&quot;Q&quot;</code>，那么直接跳出本次循环</li>
<li>对当前元素赋值为<code>&quot;Q&quot;</code>，并继续进行回溯，如果最后的结果无法成立，那么回退此次操作</li>
<li>最后将结果传入到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ilist</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span> 中，返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ilist.Count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 即为最终结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; ilist = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">4</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> res = solution.TotalNQueens(n);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">TotalNQueens</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[][] board = <span class="keyword">new</span> <span class="built_in">char</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            board[i] = <span class="keyword">new</span> <span class="built_in">char</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> ch <span class="keyword">in</span> board)</span><br><span class="line">            Array.Fill(ch, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        BackTrack(n, <span class="number">0</span>, board);</span><br><span class="line">        <span class="keyword">return</span> ilist.Count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params"><span class="built_in">int</span> n, <span class="built_in">int</span> row, <span class="built_in">char</span>[][] board</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ilist.Add(ToIList(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> col = <span class="number">0</span>; col &lt; n; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(row, col, n, board))</span><br><span class="line">            &#123;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                BackTrack(n, row + <span class="number">1</span>, board);</span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">ToIList</span>(<span class="params"><span class="built_in">char</span>[][] board</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        System.Text.StringBuilder sb = <span class="keyword">new</span> System.Text.StringBuilder();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> chess <span class="keyword">in</span> board)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> ch <span class="keyword">in</span> chess)</span><br><span class="line">                sb.Append(ch);</span><br><span class="line">            list.Add(sb.ToString());</span><br><span class="line">            sb.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">isValid</span>(<span class="params"><span class="built_in">int</span> row, <span class="built_in">int</span> col, <span class="built_in">int</span> n, <span class="built_in">char</span>[][] board</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= n - <span class="number">1</span>; i--, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0053——最大子数组和</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30053%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>
<strong>子数组</strong>是数组中的一个连续部分。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>
<strong>输出</strong>：6</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [1]<br>
<strong>输出</strong>：1</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p><strong>输入</strong>：nums = [5,4,-1,7,8]<br>
<strong>输出</strong>：23</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>直接使用动态规划，规划方程如下：</p>
<ul>
<li><em>f(i) = max{f(i - 1) + nums[i], nums[i]}</em></li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> res = solution.MaxSubArray(nums);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxSubArray</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> x <span class="keyword">in</span> nums)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = Math.Max(pre + x, x);</span><br><span class="line">            maxAns = Math.Max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0054——螺旋矩阵</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30054%E2%80%94%E2%80%94%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0054_1.jpg" alt="image"></p>
<blockquote>
<p><strong>输入</strong>：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>
<strong>输出</strong>：[1,2,3,6,9,8,7,4,5]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0054_2.jpg" alt="image"></p>
<blockquote>
<p><strong>输入</strong>：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>
<strong>输出</strong>：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>直接按层遍历，可以忽略记录每个元素是否被访问</p>
<p>具体步骤如下：</p>
<ul>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m * n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">matrix</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span></span></span></span>，定义矩阵的待遍历部分的上边界、下边界、左边界和右边界分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">top,bottom,left,right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi><mo>=</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">top=0,bottom=m-1,left=0,left=0,right=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。每一层遍历方法如下：
<ul>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，依次遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[top][col]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span>，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span> 的值加<code>1</code></li>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">bottom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span></span></span></span>，依次遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[row][right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 的值减<code>1</code></li>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span>，依次遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">matrix[bottom][col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 的值减<code>1</code></li>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">bottom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span>，依次遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[row][left]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span> 的值加<code>1</code></li>
</ul>
</li>
</ul>
<p>每次遍历一层之后，四个边界都向中间移动一步。当遍历的元素个数等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m×n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 时，矩阵中的所有元素遍历结束。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] matrix =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; res = solution.SpiralOrder(matrix);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">SpiralOrder</span>(<span class="params"><span class="built_in">int</span>[][] matrix</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; order = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> m = matrix.Length, n = matrix[<span class="number">0</span>].Length;</span><br><span class="line">        <span class="built_in">int</span> remain = m * n;</span><br><span class="line">        <span class="built_in">int</span> top = <span class="number">0</span>, bottom = m - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> col = left; col &lt;= right &amp;&amp; remain &gt; <span class="number">0</span>; col++)</span><br><span class="line">            &#123;</span><br><span class="line">                order.Add(matrix[top][col]);</span><br><span class="line">                remain--;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> row = top; row &lt;= bottom &amp;&amp; remain &gt; <span class="number">0</span>; row++)</span><br><span class="line">            &#123;</span><br><span class="line">                order.Add(matrix[row][right]);</span><br><span class="line">                remain--;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> col = right; col &gt;= left &amp;&amp; remain &gt; <span class="number">0</span>; col--)</span><br><span class="line">            &#123;</span><br><span class="line">                order.Add(matrix[bottom][col]);</span><br><span class="line">                remain--;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> row = bottom; row &gt;= top &amp;&amp; remain &gt; <span class="number">0</span>; row--)</span><br><span class="line">            &#123;</span><br><span class="line">                order.Add(matrix[row][left]);</span><br><span class="line">                remain--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0055——跳跃游戏</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30055%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>
判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：nums = [2,3,1,1,4]<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：nums = [3,2,1,0,4]<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>采用动态规划，具体步骤如下：</p>
<ul>
<li>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> 为数组长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">maxLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span> 为当前所能到达的最大下标</li>
<li>进行循环，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">i &lt;len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> <em>&amp;&amp;</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>&lt;</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">maxLength&lt;n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时循环继续</li>
<li>如果下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">i&gt;maxLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span> 时，说明无法达到目标下标，返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">maxLength</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span> 变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">maxLength,nums[i]+i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的最大值</li>
<li>最后返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span></li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">bool</span> res = solution.CanJump(nums);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanJump</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> len = nums.Length;</span><br><span class="line">        <span class="built_in">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; maxLength &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxLength)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.Max(maxLength, nums[i] + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0056——合并区间</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30056%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><msub><mi>t</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>e</mi><mi>n</mi><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">intervals[i] = [start_i, end_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p><strong>输入</strong>：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>
<strong>输出</strong>：[[1,6],[8,10],[15,18]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p><strong>输入</strong>：intervals = [[1,4],[4,5]]<br>
<strong>输出</strong>：[[1,5]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>基于区间左边界完成数组升序排序<br>
遍历数组：若区间右边界小于后继区间左边界，直接将当前区间添加到结果数组中，否则更新后继区间的左边界为当前区间左边界，若当前区间右边界小于后继区间右边界，继续循环；否则更新当前区间右边界为后继区间的右边界<br>
将数组最后一个区间添加到数组中。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] intervals =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">2</span>, <span class="number">6</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">8</span>, <span class="number">10</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">15</span>, <span class="number">18</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[][] res = solution.Merge(intervals);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> j <span class="keyword">in</span> i)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[][] Merge(<span class="built_in">int</span>[][] intervals)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals = intervals.OrderBy(p =&gt; p[<span class="number">0</span>]).ToArray();</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="built_in">int</span>[]&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intervals.Length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt;= intervals[i + <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                intervals[i + <span class="number">1</span>][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt;= intervals[i + <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    intervals[i + <span class="number">1</span>][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                list.Add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.Add(intervals[intervals.Length - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[][] result = list.ToArray();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0057——插入区间</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30057%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/insert-interval/">插入区间</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目要求">题目要求</h2>
<p>给你一个 <strong>无重叠的</strong>，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]<br>
输出：[[1,5],[6,9]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>
输出：[[1,2],[3,10],[12,16]]</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p>输入：intervals = [], newInterval = [5,7]<br>
输出：[[5,7]]</p>
</blockquote>
<h2 id="示例4">示例4</h2>
<blockquote>
<p>输入：intervals = [[1,5]], newInterval = [2,3]<br>
输出：[[1,5]]</p>
</blockquote>
<h2 id="示例5">示例5</h2>
<blockquote>
<p>输入：intervals = [[1,5]], newInterval = [2,7]<br>
输出：[[1,7]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<blockquote>
<p>直接遍历数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">intervals</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span></span></span></span> 完成插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">newInterval</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 的操作</p>
<p>遍历数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">interval</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 的过程中，使用列表存储插入操作后的结果区间，应确保遍历所有区间（包括已有的区间和新区间）的顺序是按照开始位置升序的顺序，依次将每个遍历到的区间添加到列表，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">curr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 表示当前遍历到的区间，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">newInterval</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 尚未插入且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>≥</mo><mi>n</mi><mi>e</mi><mi>w</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">curr[0] \geq newInterval[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>，则将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">curr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 添加到列表之前，首先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">newInterval</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 添加到列表</p>
<p>每次将区间添加到列表的同时，判断新添加的区间是否和列表中已有的区间存在重叠，如果存在重叠则执行合并操作。由于遍历区间的顺序是按照开始位置升序的顺序，且列表中已有的区间互不重叠，因此当列表不为空时，只需要将新添加的区间和列表中的最后一个区间比较即可。具体操作如下。</p>
<ul>
<li>如果列表不为空且当前区间的开始位置小于等于列表中的最后一个区间的结束位置，则将当前区间与列表中的最后一个区间合并，将列表中的最后一个区间的结束位置更新为两个区间的结束位置中的最大值。</li>
<li>如果列表为空或当前区间的开始位置大于列表中的最后一个区间的结束位置，则将当前区间添加到列表中。</li>
</ul>
<p>当遍历结束之后，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">newInterval</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 仍未插入，则将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>w</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">newInterval</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 添加到列表</p>
<p>最后将列表转换为数组并返回</p>
</blockquote>
<p><strong>想法代码</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] intervals =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">5</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">6</span>, <span class="number">7</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">8</span>, <span class="number">10</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">12</span>, <span class="number">16</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] newInterval = &#123; <span class="number">4</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[][] res = solution.Insert(intervals, newInterval);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[][] Insert(<span class="built_in">int</span>[][] intervals, <span class="built_in">int</span>[] newInterval)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>[]&gt; intervalList = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>[]&gt;();</span><br><span class="line">        <span class="built_in">bool</span> inserted = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">int</span> length = intervals.Length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] curr = intervals[i];</span><br><span class="line">            <span class="keyword">if</span> (!inserted &amp;&amp; curr[<span class="number">0</span>] &gt;= newInterval[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                InsertInterval(intervalList, newInterval);</span><br><span class="line">                inserted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            InsertInterval(intervalList, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!inserted)</span><br><span class="line">        &#123;</span><br><span class="line">            InsertInterval(intervalList, newInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervalList.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertInterval</span>(<span class="params">IList&lt;<span class="built_in">int</span>[]&gt; intervalList, <span class="built_in">int</span>[] interval</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> merged = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (intervalList.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] prev = intervalList[intervalList.Count - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &lt;= prev[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                prev[<span class="number">1</span>] = Math.Max(prev[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">                merged = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!merged)</span><br><span class="line">        &#123;</span><br><span class="line">            intervalList.Add(interval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0058——最后一个单词的长度</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30058%E2%80%94%E2%80%94%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/length-of-last-word/">最后一个单词的长度</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目要求">题目要求</h2>
<p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p>
<p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p>输入：s = “Hello World”<br>
输出：5</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p>输入：s = &quot;   fly me   to   the moon  &quot;<br>
输出：4</p>
</blockquote>
<h2 id="示例3">示例3</h2>
<blockquote>
<p>输入：s = “luffy is still joyboy”<br>
输出：6</p>
</blockquote>
<h2 id="题解">题解</h2>
<blockquote>
<p>题目要求得到字符串中最后一个单词的长度，可以反向遍历字符串，寻找最后一个单词并计算其长度。</p>
<p>由于字符串中至少存在一个单词，因此字符串中一定有字母。首先找到字符串中的最后一个字母，该字母即为最后一个单词的最后一个字母。</p>
<p>从最后一个字母开始继续反向遍历字符串，直到遇到空格或者到达字符串的起始位置。遍历到的每个字母都是最后一个单词中的字母，因此遍历到的字母数量即为最后一个单词的长度。</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;   fly me   to   the moon  &quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> res = solution.LengthOfLastWord(s);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LengthOfLastWord</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> index = s.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[index] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> wordLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            wordLength++;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0059——螺旋矩阵II</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30059%E2%80%94%E2%80%94%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II</a></h1>
<p>难度：<strong>中等</strong><br>
题目要求：<br>
给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<h2 id="示例1">示例1</h2>
<blockquote>
<p>输入：n = 3<br>
输出：[[1,2,3],[8,9,4],[7,6,5]]</p>
</blockquote>
<h2 id="示例2">示例2</h2>
<blockquote>
<p>输入：n = 1<br>
输出：[[1]]</p>
</blockquote>
<h2 id="题解">题解</h2>
<blockquote>
<p>依据按层遍历的思想遍历矩阵</p>
<p>定义矩阵中的每个位置所在的层数为该位置到矩阵边界的最近距离，当遍历到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 层时，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[k][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 开始按顺时针的顺序依次遍历第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 层的全部位置</p>
<p>具体做法如下：</p>
<ul>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">matrix</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span></span></span></span>，定义矩阵的待遍历部分的上、下、左、右边界分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">top,bottom,left,right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">top=0,bottom=n-1,left=0,right=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，遍历方法如下
<ul>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，依次遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[top][col]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 并填入元素，并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span> 的值加<code>1</code></li>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">bottom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span></span></span></span>，依次遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[row][right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span> 并填入元素，并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 的值减<code>1</code></li>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span>，依次遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[bottom][col]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 并填入元素，并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">bottom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span></span></span></span> 的值减<code>1</code></li>
<li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">bottom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span>，依次遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">matrix[row][left]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span> 并填入元素，并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span> 的值加<code>1</code></li>
</ul>
</li>
</ul>
<p>遍历结束之后，直接返回结果即可</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">3</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[][] res = solution.GenerateMatrix(n);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> y <span class="keyword">in</span> x)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(y + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[][] GenerateMatrix(<span class="built_in">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] matrix = <span class="keyword">new</span> <span class="built_in">int</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i] = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> total = n * n;</span><br><span class="line">        <span class="built_in">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> top = <span class="number">0</span>, bottom = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= total)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> col = left; col &lt;= right &amp;&amp; num &lt;= total; col++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[top][col] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> row = top; row &lt;= bottom &amp;&amp; num &lt;= total; row++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[row][right] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> col = right; col &gt;= left &amp;&amp; num &lt;= total; col--)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[bottom][col] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> row = bottom; row &gt;= top &amp;&amp; num &lt;= total; row--)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[row][left] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0060——排列序列</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30060%E2%80%94%E2%80%94%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/permutation-sequence/">排列序列</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。<br>
按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, k = 3</span><br><span class="line">输出：&quot;213&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 9</span><br><span class="line">输出：&quot;2314&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例3">示例3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, k = 1</span><br><span class="line">输出：&quot;123&quot;</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>假设n=5,k=35, n为5的全排列就是首位为1-5的如下排列的所有1,2,3,4,5,每个各有24个排列，组成12345的全排列。由于k=35&lt;48,也就是说第35个肯定在首位为2的全排列里边,所以第一个取2。 接下来就是考虑剩下1345这四个数的全排列里边取第k=35-24=11个，3,4,5,每个各有6个排列，组成1345的全排列，由于k=11&lt;12,也就是说第11个肯定在首位为3的全排列里边，所以第二个数取3接下来就是考虑剩下145这三个数的全排列里边取第k=11-6=5个，1,4,5,_每个各有2个排列，组成145的全排列。由于k=5&lt;6,也就是说第5个肯定在首位为5的全排列里边，所以第三个数取5。接下来就是考虑剩下14这两个数的排列里边取第k=5-4=1个。1，4每个各有1个排列，组成14的排列，由于k=1,所以第四个数取1。最后加上剩下的最后一个4，结果就是23514结束。</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> k = <span class="number">3</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> res = solution.GetPermutation(n,k);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">jiechen</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> n * jiechen(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPermutation</span>(<span class="params"><span class="built_in">int</span> n, <span class="built_in">int</span> k</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; leftlist = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            leftlist.Add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> forreturn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftlist.Count &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> jiechenval = jiechen(n - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">double</span> shang = k * <span class="number">1.0</span> / jiechenval;</span><br><span class="line">            <span class="keyword">if</span> (shang % <span class="number">1</span> != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                shang = <span class="number">1</span> + Math.Truncate(shang);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> removeindex = (<span class="built_in">int</span>)shang - <span class="number">1</span>;</span><br><span class="line">            forreturn += leftlist[removeindex];</span><br><span class="line">            leftlist.RemoveAt(removeindex);</span><br><span class="line">            k = k - removeindex * jiechenval;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        forreturn += leftlist[<span class="number">0</span>].ToString();</span><br><span class="line">        <span class="keyword">return</span> forreturn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0061——旋转链表</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30061%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/rotate-list/">旋转链表</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0061_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[4,5,1,2,3]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0061_2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [0,1,2], k = 4</span><br><span class="line">输出：[2,0,1]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>最简单的算法，直接用指针遍历，将链表分成两段之后重新拼接</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val; </span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next = <span class="keyword">new</span> ListNode(<span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    next = <span class="keyword">new</span> ListNode(<span class="number">4</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        next = <span class="keyword">new</span> ListNode(<span class="number">5</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">int</span> k = <span class="number">2</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode res = solution.RotateRight(head, k);</span><br><span class="line">        <span class="keyword">while</span> (res != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(res.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">RotateRight</span>(<span class="params">ListNode head, <span class="built_in">int</span> k</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode counter = head;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode node1 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode s = node;</span><br><span class="line">        ListNode temp = node1;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (counter != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            counter = counter.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k % count==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; (count - (k + count) % count); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            node1.next = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node.next = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">            node = node.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = temp.next;</span><br><span class="line">        node.next = temp;</span><br><span class="line">        <span class="keyword">return</span> s.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0062——不同路径</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30062%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/unique-paths">不同路径</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>
问总共有多少条不同的路径？</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0062_1.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h2 id="示例3">示例3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>
<h2 id="示例4">示例4</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>直接使用数学方法，总共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次向下和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次向右，所以，总次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m+n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次中挑取向下和向右的次数中较少的次数，进行数学公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C^{n-1}_{m+n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.324639em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C^{m-1}_{m+n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.324639em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">7</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> res = solution.UniquePaths(m,n);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">UniquePaths</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">long</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> temp = m; </span><br><span class="line">            m = n; </span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = m + n - <span class="number">2</span>, j = <span class="number">1</span>; j &lt; n; j++, i--)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">            res /= j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0063——不同路径II</title>
    <url>/2023/11/20/%E5%8A%9B%E6%89%A30063%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/unique-paths-ii/">不同路径II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>
网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0063_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0063_2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>由于每次只能向下或者向右移动，因此对于网格中的每个位置，到达该位置的路径数目需要通过相邻元素的路径数目计算得到。可以使用动态规划计算路径数目。</p>
<p>如果左上角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>l</mi><mi>e</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">obstacleGrid[0][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 或右上角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>l</mi><mi>e</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">obstacleGrid[m-1][n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>  为<code>1</code>时直接返回<code>0</code></p>
<p>动态规划步骤如下</p>
<ul>
<li>创建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的二维数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0,j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 上只有一个位置，路径数目为<code>1</code>，所以边界情况为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[0][0]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0,j&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，需要考虑如下方面
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0,j&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，只能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 向右移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>l</mi><mi>e</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">obstacleGrid[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>l</mi><mi>e</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">obstacleGrid[i][j]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dp[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0,j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，只能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 向下移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>l</mi><mi>e</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">obstacleGrid[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>l</mi><mi>e</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">obstacleGrid[i][j]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dp[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0,j&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，可以从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 向下移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 或从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 向右移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>l</mi><mi>e</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">obstacleGrid[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j]+dp[i][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>l</mi><mi>e</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">obstacleGrid[i][j]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dp[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
</ul>
</li>
</ul>
<p>所以，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，动态规划转移方程如下：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>obstacleGrid[i][j]=1</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>obstacleGrid[i][j]=0 &amp; i=0 &amp; j&gt;0</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>obstacleGrid[i][j]=0 &amp; i&gt;0 &amp; j=0</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>obstacleGrid[i][j]=0 &amp; i&gt;0 &amp; j&gt;0</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j]=\begin{cases} 0, &amp; \text{obstacleGrid[i][j]=1}\\dp[i][j-1],&amp;\text{obstacleGrid[i][j]=0 \&amp; i=0 \&amp; j&gt;0}\\dp[i-1][j],&amp;\text{obstacleGrid[i][j]=0 \&amp; i&gt;0 \&amp; j=0}\\dp[i-1][j]+dp[i][j-1], &amp;\text{obstacleGrid[i][j]=0 \&amp; i&gt;0 \&amp; j&gt;0} \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000008em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.5949900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8899900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1849900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.905010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">obstacleGrid[i][j]=1</span></span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">obstacleGrid[i][j]=0 &amp; i=0 &amp; j&gt;0</span></span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">obstacleGrid[i][j]=0 &amp; i&gt;0 &amp; j=0</span></span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">obstacleGrid[i][j]=0 &amp; i&gt;0 &amp; j&gt;0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>根据动态规划的状态转移方程，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 的顺序可以是一下两种</p>
<ul>
<li>从小到大遍历每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 从小到大遍历每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>。该顺序为按行遍历</li>
<li>从小到大遍历每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 从小大大便利每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。该顺序为按列遍历</li>
</ul>
<p>计算得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[m-1][n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 即为从左上角到右上角的路径的最小值的和</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] obstacleGrid =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> res = solution.UniquePathsWithObstacles(obstacleGrid);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">UniquePathsWithObstacles</span>(<span class="params"><span class="built_in">int</span>[][] obstacleGrid</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = obstacleGrid.Length, n = obstacleGrid[<span class="number">0</span>].Length;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span>[][] dp = <span class="keyword">new</span> <span class="built_in">int</span>[m][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0064——最小路径和</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30064%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>
<strong>说明</strong>：每次只能向下或者向右移动一步。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0064_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>由于每次只能向下或者向右移动，因此对于网格中的每个位置，到达该位置的路径数目需要通过相邻元素的路径数目计算得到。可以使用动态规划计算路径数目。</p>
<p>动态规划步骤如下</p>
<ul>
<li>创建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的二维数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0,j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 上只有一个位置，最小路径和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">grid[0][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>，所以边界情况为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[0][0]=grid[0][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0,j&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，需要考虑如下方面
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0,j&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，只能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 向右移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dp[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=grid[i][j]+dp[i][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0,j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，只能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 向下移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dp[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=grid[i][j]+dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0,j&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，可以从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 向下移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 或从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 向右移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 最小路径和为两种情况的最小值，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=min(dp[i-1][j],dp[i][j-1]+dp[i][j-1])+grid[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></li>
</ul>
</li>
</ul>
<p>所以，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，动态规划转移方程如下：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>i=0 &amp; j&gt;0</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>i&gt;0 &amp; j=0</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>i&gt;0 &amp; j&gt;0</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j]=\begin{cases} dp[i][j-1]+grid[i][j], &amp; \text{i=0 \&amp; j&gt;0}\\dp[i-1][j]+grid[i][j],&amp;\text{i&gt;0 \&amp; j=0}\\min(dp[i-1][j],dp[i][j-1])+grid[i][j],&amp;\text{i&gt;0 \&amp; j&gt;0} \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">i=0 &amp; j&gt;0</span></span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">i&gt;0 &amp; j=0</span></span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">i&gt;0 &amp; j&gt;0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>根据动态规划的状态转移方程，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 的顺序可以是一下两种</p>
<ul>
<li>从小到大遍历每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 从小到大遍历每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>。该顺序为按行遍历</li>
<li>从小到大遍历每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 从小大大便利每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。该顺序为按列遍历</li>
</ul>
<p>计算得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[m-1][n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 即为从左上角到右上角的最小路径和</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] grid =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> res = solution.MinPathSum(grid);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinPathSum</span>(<span class="params"><span class="built_in">int</span>[][] grid</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = grid.Length, n = grid[<span class="number">0</span>].Length;</span><br><span class="line">        <span class="built_in">int</span>[][] dp = <span class="keyword">new</span> <span class="built_in">int</span>[m][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = Math.Min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0065——有效数字</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30065%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/valid-number/">有效数字</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>
<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>
<li>下述格式之一：1. 至少一位数字，后面跟着一个点 <code>'.'</code>
<ol start="2">
<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>
<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>
<li>至少一位数字</li>
</ol>
<p>部分有效数字列举如下：<code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code><br>
部分无效数字列举如下：<code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code><br>
给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;e&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="示例3">示例3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>可以直接使用正则表达式进行匹配，<code>^\s*-?\d+(\.\d+)?([eE][-+]?\d+)?\s*$</code>为当前正确得正则表达式，解读如下：</p>
<ul>
<li><code>^\s*</code>表示以零个、一个或多个空格开头</li>
<li><code>-?</code>表示一个可选的负号</li>
<li><code>\d+</code>表示一个或多个的数字</li>
<li><code>(\.\d+)?</code>表示一个可选的小数部分，包括一个小数点和至少一个数字</li>
<li><code>([eE][-+]?\d+)?</code>表示科学计数法，包括<code>&quot;e&quot;</code>或<code>&quot;E&quot;</code>，可选的正负号和至少一个数字</li>
<li><code>\s*</code>表示以零个、一个或多个空字符</li>
<li><code>$</code>表示结尾</li>
</ul>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Regex compare = <span class="keyword">new</span> Regex(<span class="string">@&quot;^\s*-?\d+(\.\d+)?([eE][-+]?\d+)?\s*$&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;e&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Console.WriteLine(solution.IsNumber(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsNumber</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> compare.IsMatch(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0066——加一</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30066%E2%80%94%E2%80%94%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/plus-one/">加一</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个由 <strong>整数 <strong>组成的</strong> 非空</strong> 数组所表示的非负整数，在该数的基础上加一。<br>
最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。<br>
你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br></pre></td></tr></table></figure>
<h2 id="示例3">示例3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index=digits.Length-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，如果数组中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span></span></span></span> 位置为<code>9</code>，那么将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span></span></span></span> 前移<br>
如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mo>=</mo><mn>0</mn><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">index==0 \&amp;\&amp; digits[index]==9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>，那么对数组扩容，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span></span></span></span> 位置的内容变为<code>1</code>且对之后的所有元素变为<code>0</code>，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mo>=</mo><mn>0</mn><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">index==0\&amp;\&amp;digits[index]\neq9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 那么将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>并对之后的元素变为<code>0</code><br>
如果不满足上方条件，则将最后一个元素加一</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] digits = &#123; <span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] res = solution.PlusOne(digits);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; res.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(res[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">PlusOne</span>(<span class="params"><span class="built_in">int</span>[] digits</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> index = digits.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (digits[digits.Length - <span class="number">1</span>] == <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits.Length &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (digits[index] == <span class="number">9</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        index--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; digits[index] == <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Array.Resize(<span class="keyword">ref</span> digits, digits.Length + <span class="number">1</span>);</span><br><span class="line">                digits[index] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                digits[index] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = digits.Length - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            digits[digits.Length - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0067——二进制求和</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30067%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/add-binary/">二进制求和</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你两个二进制字符串 <code>a</code> 和 <code>b</code> ，以二进制字符串的形式返回它们的和。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出：&quot;100&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出：&quot;10101&quot;</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">index_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">index_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别表示二进制整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 遍历到的下标，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">carry</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 表示进位值，初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">index_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">index_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别指向整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的最大下标，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">carry=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。使用字符串保存两个二进制整数之和的每一位，计算过程中依次将每一位结果拼接到字符串的末尾</p>
<p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>≥</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub><mo>≥</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">index_1\geq 0,index_2\geq 0, carry\neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 三个条件中至少有一个成立，对于每一位，执行如下操作</p>
<ul>
<li>记 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">digit_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">digit_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[index_1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">b[index_2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>对应的数字，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">index_1&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">digit_1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">index_2&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">digit_2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li>计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>=</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mi>c</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">sum=digit_1+digit_2+carry</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，则两个二进制整数之和的当前位置的值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">%</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">sum \%2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">%</span><span class="mord">2</span></span></span></span>，进位值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{sum}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">%</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">sum\%2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">%</span><span class="mord">2</span></span></span></span> 拼接到字符串末尾，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">carry</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 更新为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{sum}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">index_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">index_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别向左移动一位</li>
</ul>
<p>操作结束之后，将字符串翻转之后得到两个二进制整数之和</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> a = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> b = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> res = solution.AddBinary(a, b);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">AddBinary</span>(<span class="params"><span class="built_in">string</span> a, <span class="built_in">string</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="built_in">int</span> index1 = a.Length - <span class="number">1</span>, index2 = b.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span> || carry != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> digit1 = index1 &gt;= <span class="number">0</span> ? a[index1] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> digit2 = index2 &gt;= <span class="number">0</span> ? b[index2] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> sum = digit1 + digit2 + carry;</span><br><span class="line">            sb.Append(sum % <span class="number">2</span>);</span><br><span class="line">            carry = sum / <span class="number">2</span>;</span><br><span class="line">            index1--;</span><br><span class="line">            index2--;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = sb.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            sb2.Append(sb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb2.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0068——文本左右对齐</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30068%E2%80%94%E2%80%94%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/text-justification/">文本左右对齐</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个单词数组 <code>words</code> 和一个长度 <code>maxWidth</code> ，重新排版单词，使其成为每行恰好有 <code>maxWidth</code> 个字符，且左右两端对齐的文本。<br>
你应该使用 “<strong>贪心算法</strong>” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>' '</code> 填充，使得每行恰好有 maxWidth 个字符。<br>
要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。<br>
文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。<br>
<strong>注意</strong>：</p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 maxWidth。</li>
<li>输入单词数组 <code>words</code> 至少包含一个单词。</li>
</ul>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">&quot;This    is    an&quot;,</span><br><span class="line">&quot;example  of text&quot;,</span><br><span class="line">&quot;justification.  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">&quot;What   must   be&quot;,</span><br><span class="line">&quot;acknowledgment  &quot;,</span><br><span class="line">&quot;shall be        &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="示例3">示例3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]，maxWidth = 20</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">&quot;Science  is  what we&quot;,</span><br><span class="line">&quot;understand     nwell&quot;,</span><br><span class="line">&quot;enough to explain to&quot;,</span><br><span class="line">&quot;a  computer.  Art is&quot;,</span><br><span class="line">&quot;everything  else  we&quot;,</span><br><span class="line">&quot;do                  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>遍历单词数组，对于每个单词 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span>，尝试将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 拼接到当前行的末尾，如果当前行已经有单词则需要添加一个空格将单词分隔，考虑将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 拼接到当前行的末尾之后，当前行的宽度。</p>
<p>如果当前行的宽度不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">maxWidth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>，则将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span>拼接到当前行的末尾。</p>
<p>如果当前行的宽度超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">maxWidth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>，则不能将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 拼接到当前行的末尾，当前行的单词添加完毕。此时需要将当前行的单词重新排版使得单词之间的空格均匀分配，将重新排版之后的当前行添加到结果中，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span> 填入新的一行。重新排版当前行的做法如下。</p>
<p>如果当前行只有一个单词，则将该单词左对齐，然后在右侧添加空格直到当前行有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">maxWidth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span> 个字符。</p>
<p>如果当前行有至少两个单词，则根据单词数量计算间隔数量，根据单词长度之和计算空格数量，将空格均匀分配在每个间隔中，满足左侧间隔的空格数大于等于右侧间隔的空格数。</p>
<p>遍历单词数组结束之后，需要将剩余的单词填入末尾行。由于末尾行左对齐且相邻单词之间只有一个空格，因此将末尾行的单词使用一个空格分隔的方式依次拼接，然后在右侧添加空格直到末尾行有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">maxWidth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span> 个字符。</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span>[] words = &#123; <span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;example&quot;</span>, <span class="string">&quot;of&quot;</span>, <span class="string">&quot;text&quot;</span>, <span class="string">&quot;justification.&quot;</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> maxWidth = <span class="number">16</span>;</span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; res = solution.FullJustify(words, maxWidth);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> word <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; <span class="title">FullJustify</span>(<span class="params"><span class="built_in">string</span>[] words, <span class="built_in">int</span> maxWidth</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; justification = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; line = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> lineWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> wordsCount = words.Length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; wordsCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> word = words[i];</span><br><span class="line">            <span class="built_in">int</span> newLength = lineWidth + (lineWidth &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) + word.Length;</span><br><span class="line">            <span class="keyword">if</span> (newLength &lt;= maxWidth)</span><br><span class="line">            &#123;</span><br><span class="line">                lineWidth = newLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> justifiedLine = JustifyLine(line, lineWidth, maxWidth);</span><br><span class="line">                justification.Add(justifiedLine);</span><br><span class="line">                line.Clear();</span><br><span class="line">                lineWidth = word.Length;</span><br><span class="line">            &#125;</span><br><span class="line">            line.Add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> justifiedLastLine = JustifyLastLine(line, maxWidth);</span><br><span class="line">        justification.Add(justifiedLastLine);</span><br><span class="line">        <span class="keyword">return</span> justification;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">JustifyLine</span>(<span class="params">IList&lt;<span class="built_in">string</span>&gt; line, <span class="built_in">int</span> lineWidth, <span class="built_in">int</span> maxWidth</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.Append(line[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">int</span> lineWords = line.Count;</span><br><span class="line">        <span class="built_in">int</span> splits = lineWords - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (splits == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (sb.Length &lt; maxWidth)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.Append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> spaces = maxWidth - (lineWidth - splits);</span><br><span class="line">            <span class="built_in">int</span> quotient = spaces / splits, remainder = spaces % splits;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; lineWords; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> currSpaces = quotient + (i &lt;= remainder ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; currSpaces; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sb.Append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.Append(line[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.ToString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">JustifyLastLine</span>(<span class="params">IList&lt;<span class="built_in">string</span>&gt; line, <span class="built_in">int</span> maxWidth</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.Append(line[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">int</span> lineWords = line.Count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; lineWords; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.Append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            sb.Append(line[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sb.Length &lt; maxWidth)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.Append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0069——x的平方根</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30069%E2%80%94%E2%80%94x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/sqrtx/">x的平方根</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。<br>
由于返回类型是整数，结果只保留 <strong>整数部分</strong>，小数部分将被 <strong>舍去 。</strong><br>
<strong>注意</strong>：不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>使用二分查找，定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">high=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">low=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 来表示上下边界，进行如下操作</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么直接返回<code>0</code></li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>&lt;</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">low&lt;high</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span></span></span></span>，那么定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mo stretchy="false">(</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid=low+(high-low+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>∗</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">(mid*mid)\leq x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 那么让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">low=mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，否则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">high=mid-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
<p>遍历结束之后直接返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">36</span>;</span><br><span class="line">        <span class="built_in">int</span> res = solution.MySqrt(x);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MySqrt</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> high = x;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = low + (high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">long</span>)mid * mid &lt;= x)</span><br><span class="line">            &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0070——爬楼梯</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30070%E2%80%94%E2%80%94%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。<br>
每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>使用回溯法，使用数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">array</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 来存储总计的内容，定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">array[0]=1,array[1]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
回溯法方法如下：</p>
<ul>
<li>如果数组的第<code>n</code>个元素不是<code>0</code>，那么，直接返回第<code>n</code>个元素</li>
<li>根据第1，2，3，4层方法得出的结果来看，结果为斐波那契数列，所以第n层方法为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)+(n+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></li>
<li>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 为回溯方法的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 层</li>
<li>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 为回溯方法的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 层<br>
最后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">array[n]=x+y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 并返回</li>
</ul>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> res = solution.ClimbStairs(n);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ClimbStairs</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ChangeArray(n,array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ChangeArray</span>(<span class="params"><span class="built_in">int</span> n, <span class="built_in">int</span>[] array</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[n] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> array[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> x = ChangeArray(n<span class="number">-1</span>, array);</span><br><span class="line">        <span class="built_in">int</span> y = ChangeArray(n<span class="number">-2</span>, array);</span><br><span class="line">        array[n] = x + y;</span><br><span class="line">        <span class="keyword">return</span> array[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0071——简化路径</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30071%E2%80%94%E2%80%94%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/simplify-path/">简化路径</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 **绝对路径 **（以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。<br>
在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。<br>
请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>
<ul>
<li>始终以斜杠 <code>'/'</code> 开头。</li>
<li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>
<li>最后一个目录名（如果存在）**不能 **以 <code>'/'</code> 结尾。</li>
<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>
</ul>
<p>返回简化后得到的 <strong>规范路径</strong></p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例3">示例3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例4">示例4</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>首先将给定的字符串 <code>path</code> 根据 <code>/</code> 分割成一个由若干字符串组成的列表，记为 <code>names</code>。根据题目中规定的「规范路径的下述格式」，<code>names</code> 中包含的字符串只能为以下几种：</p>
<ul>
<li>
<p>空字符串。例如当出现多个连续的 <code>/</code>，就会分割出空字符串；</p>
</li>
<li>
<p>一个点 <code>.</code>；</p>
</li>
<li>
<p>两个点 <code>..</code>；</p>
</li>
<li>
<p>只包含英文字母、数字或 <code>_</code> 的目录名。</p>
</li>
</ul>
<p>对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理，因为「空字符串」没有任何含义，而「一个点」表示当前目录本身，我们无需切换目录。</p>
<p>对于「两个点」或者「目录名」，我们则可以用一个栈来维护路径中的每一个目录名。当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录。当我们遇到「目录名」时，就把它放入栈。</p>
<p>这样一来，我们只需要遍历 <code>names</code>中的每个字符串并进行上述操作即可。在所有的操作完成后，我们将从栈底到栈顶的字符串用 <code>/</code> 进行连接，再在最前面加上 <code>/</code> 表示根目录，就可以得到简化后的规范路径。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">&quot;/../&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> res = solution.SimplifyPath(path);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">SimplifyPath</span>(<span class="params"><span class="built_in">string</span> path</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>[] names = path.Split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; stack = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> names) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.Equals(name)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.Count &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    stack.RemoveAt(stack.Count - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (name.Length &gt; <span class="number">0</span> &amp;&amp; !<span class="string">&quot;.&quot;</span>.Equals(name)) </span><br><span class="line">            &#123;</span><br><span class="line">                stack.Add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (stack.Count == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.Append(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> stack) </span><br><span class="line">            &#123;</span><br><span class="line">                ans.Append(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                ans.Append(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0072——编辑距离</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30072%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数  。<br>
你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>利用动态规划，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 分别表示字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">word_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">word_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的长度，对于满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\leq i\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\leq j\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的每个下标对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，需要分别计算将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">word_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个字符转换成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">word_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个字符的最小操作数</p>
<p>创建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m+1)*(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的二维数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 为将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">word_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个字符转换成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">word_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个字符的最小操作数</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则对于任意 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，需要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">word_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个字符全部删除，最少操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则对于任意 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，需要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">word_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个字符全部删除，最少操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，因此动态规划边界为：对于任意 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">0\leq j\leq n, dp[0][j]=j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，对于任意 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">0\leq i\leq m, dp[i][0]=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，当然，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dp[0][0]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\leq i\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\leq j\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 时，让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c_1=word_1[i-1], c_2=word_2[j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，总共分为两种情况</p>
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_1=c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 成为公共字符，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">word_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个字符的最小操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo mathvariant="normal">≠</mo><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_1\neq c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时，计算将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">word_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个字符串转换成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">word_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个字符的最少操作数时需要考虑三种可能的操作，取其中的最小操作数作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>
<ul>
<li>第一种操作是插入字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，操作之前的最少操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，操作之后的最少操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i-1][j]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>第二种操作是删除字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，操作之前的最少操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，操作之后的最少操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i][j-1]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>第三种操作是将字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 替换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，操作之前的最少操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，操作之后的最少操作数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i-1][j-1]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
</ul>
<p>动态规划转移方程如下<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>word1[i-1]=word2[j-1]</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>word1[i-1]!=word2[j-1] </mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j]=\begin{cases} dp[i-1][j-1],&amp;\text{word1[i-1]=word2[j-1]}\\min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1,&amp;\text{word1[i-1]!=word2[j-1] } \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">word1[i-1]=word2[j-1]</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">word1[i-1]!=word2[j-1] </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>根据动态规划转移方程，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 的顺序为从小到大遍历每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 从小到大遍历每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>。最后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[m][n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 即为最少操作数</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> word1 = <span class="string">&quot;horse&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> word2 = <span class="string">&quot;ros&quot;</span>;</span><br><span class="line">        Console.WriteLine(solution.MinDistance(word1,word2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinDistance</span>(<span class="params"><span class="built_in">string</span> word1, <span class="built_in">string</span> word2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = word1.Length, n = word2.Length;</span><br><span class="line">        <span class="built_in">int</span>[][] dp = <span class="keyword">new</span> <span class="built_in">int</span>[m + <span class="number">1</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="built_in">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> c1 = word1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">char</span> c2 = word2[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = Math.Min(Math.Min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0073——矩阵置零</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30073%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/set-matrix-zeroes/">矩阵置零</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0 <strong>，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法</strong>。</strong></p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0073_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0073_2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>利用两个数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 来存入数值为<code>0</code>的位置的行和列，之后对数组进行遍历，将所在单位设为<code>0</code></p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] matrix =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        solution.SetZeroes(matrix);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> matrix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> j <span class="keyword">in</span> i)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetZeroes</span>(<span class="params"><span class="built_in">int</span>[][] matrix</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> index_x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> index_y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span>[] row = <span class="keyword">new</span> <span class="built_in">int</span>[matrix.Length * matrix[<span class="number">0</span>].Length];</span><br><span class="line">        <span class="built_in">int</span>[] col = <span class="keyword">new</span> <span class="built_in">int</span>[matrix.Length * matrix[<span class="number">0</span>].Length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; matrix.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; matrix[i].Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    row[index_x] = i;</span><br><span class="line">                    col[index_y] = j;</span><br><span class="line">                    index_x++;</span><br><span class="line">                    index_y++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt; index_x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[row[count]][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt; index_y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; matrix.Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[j][col[count]] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0074——搜索二位矩阵</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30074%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E4%BA%8C%E4%BD%8D%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/search-a-2d-matrix/">搜索二维矩阵</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0074_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0074_2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>对当前数组的第一列进行遍历：</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">matrix[i][0]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span> 那么，记录 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>i</mi></msub><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">col_index=i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">matrix[i][0]==target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span> ，直接返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span></li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">matrix[matrix.Length-1][0]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mord">.</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>i</mi></msub><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>L</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">col_index=matrix.Length-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mord">.</span><span class="mord mathdefault">L</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>i</mi></msub><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">col_index&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，直接返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span></li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>i</mi></msub><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">matrix[col_index][i]==target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，否则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span></li>
</ul>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[][] matrix =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">60</span> &#125;</span><br><span class="line">            <span class="comment">//new[]&#123;1&#125;,</span></span><br><span class="line">            <span class="comment">//new[]&#123;3&#125;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">30</span>;</span><br><span class="line">        Console.WriteLine(solution.SearchMatrix(matrix,target));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SearchMatrix</span>(<span class="params"><span class="built_in">int</span>[][] matrix, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> col_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; matrix.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                col_index = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matrix[matrix.Length<span class="number">-1</span>][<span class="number">0</span>] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            col_index = matrix.Length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (col_index &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[col_index][i] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0075——颜色分类</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30075%E2%80%94%E2%80%94%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>
我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>直接利用双指针进行解题，步骤如下：</p>
<ul>
<li>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mi>l</mi></msub><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">index_left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mi>r</mi></msub><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">index_right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 指针，分别置为<code>0</code>，对当前数组进行遍历</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">nums[i]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，交换当前位置和右指针的元素，右指针自增</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">nums[i]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，交换当前位置和左指针的元素，左指针自增
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mi>l</mi></msub><mi>e</mi><mi>f</mi><mi>t</mi><mo>&lt;</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msub><mi>x</mi><mi>r</mi></msub><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">index_left&lt;index_right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，交换当前位置和右指针的元素（在父条件之后）</li>
<li>左右指针自增</li>
</ul>
</li>
<li>右指针到达数组末尾，遍历结束</li>
</ul>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        solution.SortColors(nums);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> nums)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SortColors</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> index_left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> index_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(nums, i, index_right);</span><br><span class="line">                index_right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(nums, i, index_left);</span><br><span class="line">                <span class="keyword">if</span> (index_left &lt; index_right)</span><br><span class="line">                &#123;</span><br><span class="line">                    Swap(nums,i, index_right);</span><br><span class="line">                &#125;</span><br><span class="line">                index_left++;</span><br><span class="line">                index_right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> index_left, <span class="built_in">int</span> index_right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[index_left];</span><br><span class="line">        nums[index_left] = nums[index_right];</span><br><span class="line">        nums[index_right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0076——最小覆盖子串</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30076%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意</strong>:</p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例3">示例3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br></pre></td></tr></table></figure>
<h1>题解</h1>
<blockquote>
<p>使用滑动窗口法，定义两个字典 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">need</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">window</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">need</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span> 内部存储 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 的内容，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">window</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 内部存储符合要求的内容<br>
具体步骤如下：</p>
<ul>
<li>对当前字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 进行遍历，让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 右移，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 指针第一次找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">window</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">need</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span> 里的全部内容</li>
<li>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span> 右移，直到找到下一个在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">need</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span> 内容里的元素，继续遍历重复上一步步骤</li>
<li>将内容比较，长度短的内容保存</li>
<li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span> 遍历到字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 的最后一个内容的时候，遍历结束</li>
</ul>
<p>返回最短的内容</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;ADOBECODEBANC&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">        Console.WriteLine(solution.MinWindow(s,t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">MinWindow</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">int</span>&gt; need = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">        Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">int</span>&gt; window = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (need.ContainsKey(a))</span><br><span class="line">            &#123;</span><br><span class="line">                need[a]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                need.Add(a, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> len = Int32.MaxValue;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.ContainsKey(c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.ContainsKey(c))</span><br><span class="line">                &#123;</span><br><span class="line">                    window[c]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    window.Add(c, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (need[c] == window[c])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count == need.Count)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len)</span><br><span class="line">                &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.ContainsKey(d))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == Int32.MaxValue ? <span class="string">&quot;&quot;</span> : s.Substring(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0077——组合</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30077%E2%80%94%E2%80%94%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/combinations/">组合</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。<br>
你可以按 <strong>任何顺序</strong> 返回答案。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 算法可解<br>
用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 表示当前遍历到的数字，初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">num=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。回溯过程中，以下两种情况可以直接返回。</p>
<ul>
<li>
<p>如果当前组合中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数，则得到一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数的组合，将其添加到答案中，不需要继续遍历更多的数字。</p>
</li>
<li>
<p>如果当前组合中的数字过少，即使将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[num,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 范围中的所有整数都加入当前组合都无法使组合中的数字个数达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，则在当前组合的情况下一定不可能得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数的组合。</p>
</li>
</ul>
<p>其余情况下，对于当前遍历到的数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>，分别考虑将其加入组合与不加入组合两种情况，并执行回溯。</p>
<p>使用剪枝的情况下，可以排除不可能的组合，需要遍历的组合数从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 减少到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">int</span> k = <span class="number">2</span>;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; res = solution.Combine(n, k);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> j <span class="keyword">in</span> i)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; Combine(<span class="built_in">int</span> n, <span class="built_in">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; res = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; k || k &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>(IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;)(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DFS(n, k, <span class="number">1</span>, list, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span>(<span class="params"><span class="built_in">int</span> n, <span class="built_in">int</span> k, <span class="built_in">int</span> begin, IList&lt;<span class="built_in">int</span>&gt; list, IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; res</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; path = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> (list.Count == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                path.Add(list[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.Add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = begin; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.Add(i);</span><br><span class="line">            DFS(n,k,i+<span class="number">1</span>,list,res);</span><br><span class="line">            list.RemoveAt(list.Count<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0078——子集</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30078%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/subsets/">子集</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。<br>
解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<blockquote>
<p>利用回溯算法可解<br>
每个结果都需要存储，不需要约束条件<br>
由于每个都需要存储，所以不需要剪枝<br>
注意，这个算法依旧需要回头</p>
</blockquote>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; res = solution.Subsets(nums);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> j <span class="keyword">in</span> i)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; Subsets(<span class="built_in">int</span>[] nums)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DFS(nums, <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(), <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span>(<span class="params"><span class="built_in">int</span>[] nums, List&lt;<span class="built_in">int</span>&gt; path, <span class="built_in">int</span> start,IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = start; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.Add(nums[i]);</span><br><span class="line"></span><br><span class="line">            DFS(nums, path, i + <span class="number">1</span>,ans);</span><br><span class="line"></span><br><span class="line">            path.Remove(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0079——单词搜索</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30079%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1>单词搜索</h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述：">题目描述：</h2>
<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br>
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<h2 id="示例1：">示例1：</h2>
<p><img src="/images/ltc0079_1.jpg" alt="image"></p>
<blockquote>
<p><strong>输入</strong>：board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “ABCCED”<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例2：">示例2：</h2>
<p><img src="/images/ltc0079_2.jpg" alt="image"></p>
<blockquote>
<p><strong>输入</strong>：board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “SEE”<br>
<strong>输出</strong>：true</p>
</blockquote>
<h2 id="示例3：">示例3：</h2>
<p><img src="/images/ltc0079_3.jpg" alt="image"></p>
<blockquote>
<p><strong>输入</strong>：board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “ABCB”<br>
<strong>输出</strong>：false</p>
</blockquote>
<h2 id="题解：">题解：</h2>
<p>根据题目可得需要用到回溯算法<br>
遍历表格内的每一个元素，如果满足要求即可回溯，最终得到结果，以下为具体步骤:</p>
<ul>
<li>定义两个方向数组<code>moveX</code>和<code>moveY</code></li>
<li>如果当前位置的元素和单词中的元素内容不相同，返回<code>false</code></li>
<li>如果遍历到单词的最后一个元素，返回<code>true</code></li>
<li>将当前位置设置为<code>true</code>，并进行循环：
<ul>
<li>新的方向为当前方向加上第<code>i</code>次循环中<code>moveX[i]</code>和<code>move[Y]</code>的值</li>
<li>如果新的方向均大于零并且移动的下一次元素位置不超过二维数组边界并且将要遍历的元素没有使用过，那么就进行回溯，将新的移动位置传入到回溯，并将判断的单词元素下标加一</li>
<li>如果回溯结束之后满足条件，返回<code>ture</code></li>
<li>如果循环结束之后没有最终满足，对操作进行回头，即将当前位置设为未使用并返回<code>false</code></li>
</ul>
</li>
<li>遍历每一个元素，对其都进行回溯，如果其中的元素在回溯中最后返回<code>true</code>，则返回<code>true</code></li>
<li>如果所有元素都不满足条件，则返回<code>false</code></li>
</ul>
<p>最后的结果即为题目答案</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="built_in">int</span>[] desX = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="built_in">int</span>[] desY = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[][] board =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;S&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">string</span> word = <span class="string">&quot;ABCB&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">bool</span> res = solution.Exist(board, word);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">DFS</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">string</span> word, <span class="built_in">int</span> index, <span class="built_in">char</span>[][] board, <span class="built_in">bool</span>[,] used</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (word[index] != board[x][y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == word.Length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        used[x, y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> newX = x + desX[i];</span><br><span class="line">            <span class="built_in">int</span> newY = y + desY[i];</span><br><span class="line">            <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newX &lt; board.Length &amp;&amp; newY &lt; board[<span class="number">0</span>].Length &amp;&amp; used[newX, newY] != <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (DFS(newX, newY, word, index + <span class="number">1</span>, board, used)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        used[x, y] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Exist</span>(<span class="params"><span class="built_in">char</span>[][] board, <span class="built_in">string</span> word</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span>[,] used = <span class="keyword">new</span> <span class="built_in">bool</span>[board.Length, board[<span class="number">0</span>].Length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; board.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; board[i].Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DFS(i, j, word, <span class="number">0</span>, board, used)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0080——删除有序数组中的重复项II</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30080%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个有序数组 <code>nums</code> ，请你<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>原地</strong></a>删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。<br>
不要使用额外的数组空间，你必须在 <a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong>原地</strong></a>修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>说明</strong>：<br>
为什么返回数值是整数，但输出的答案是数组呢？<br>
请注意，输入数组是以「<strong>引用</strong>」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>
你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">&amp;nbsp; &amp;nbsp; print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>如果数组长度小于等于<code>2</code>，直接返回数组的长度<br>
如果长度大于<code>2</code>，执行如下操作</p>
<ul>
<li>令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">index=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>从第三个数开始循环，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i] = nums[index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> <em>&amp;&amp;</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[index] = nums[index-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，跳过本次循环</li>
<li>将当前下标的元素值赋值到index的位置，并让index自增</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> len = solution.RemoveDuplicates(nums);</span><br><span class="line">        Console.WriteLine(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RemoveDuplicates</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.Length &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.Length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[index] &amp;&amp; nums[index] == nums[index - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[++index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0081——搜索旋转排序数组II</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30081%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。<br>
在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 **旋转 **，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。<br>
给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。<br>
你必须尽可能减少整个操作步骤。</p>
<h2 id="示例1">示例1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>二分法，采用左右指针，对其进行如下操作</p>
<ul>
<li>如果左指针小于等于右指针，执行循环
<ul>
<li>定义中间值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">mid=(right-left)/2+left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span></li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]=target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，直接返回<code>true</code></li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[mid]=nums[left]=nums[right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>，将左指针右移，右指针左移</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[left]\leq nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">target&lt;nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span><em>&amp;&amp;</em><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \req at position 7: target\̲r̲e̲q̲ ̲nums[left]'>target\req nums[left]</span>
<ul>
<li>说明左侧单增，将右指针移动到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">mid-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li>否则就将左指针移动到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">mid+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li>如果不满足上述全部条件
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">target&gt;nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span><em>&amp;&amp;</em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">target\leq nums[right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>
<ul>
<li>说明右侧单增，将左指针移动到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">mid+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li>否则就将右指针移动到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">mid-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
<li>如果循环结束仍未找到，则返回<code>false</code></li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Console.WriteLine(solution.Search(nums,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Search</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>,right = nums.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[left] &amp;&amp; nums[right] == nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[left])</span><br><span class="line">                &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0082——删除排序链表中的重复元素II</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30082%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0082_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0082_2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>采用快慢指针，执行如下操作</p>
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo mathvariant="normal">≠</mo><mi>f</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">fast.val \neq fast.next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span>
<ul>
<li>如果慢指针的下一个为快指针，将快指针指向的位置给到慢指针</li>
<li>否则将快指针指向的下一个位置给到慢指针的下一个位置</li>
</ul>
</li>
<li>每次循环将快指针后移<br>
最后将答案链表从第二个节点返回</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next = <span class="keyword">new</span> ListNode(<span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    next = <span class="keyword">new</span> ListNode(<span class="number">3</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        next = <span class="keyword">new</span> ListNode(<span class="number">4</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            next = <span class="keyword">new</span> ListNode(<span class="number">4</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                next = <span class="keyword">new</span> ListNode(<span class="number">5</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ListNode ans = solution.DeleteDuplicates(head);</span><br><span class="line">        <span class="keyword">while</span> (ans != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(ans.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            ans = ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">DeleteDuplicates</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode ans = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ans.next = head;</span><br><span class="line">        ListNode slow = ans;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.val != fast.next?.val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow.next == fast)</span><br><span class="line">                &#123;</span><br><span class="line">                    slow = fast;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    slow.next = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0083——删除排序链表中的重复元素</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30083%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0083_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0083_2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>和0082一样的解题方法，将条件稍微改一下即可解题</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next = <span class="keyword">new</span> ListNode(<span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ListNode ans = solution.DeleteDuplicates(head);</span><br><span class="line">        <span class="keyword">while</span> (ans != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(ans.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            ans = ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">DeleteDuplicates</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode ans = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode t = ans;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val != p.next?.val)</span><br><span class="line">            &#123;</span><br><span class="line">                t.next = p;</span><br><span class="line">                t = t.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0084——柱状图中最大的矩形</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30084%E2%80%94%E2%80%94%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>
求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0084_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0084_2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>对于下标<code>i</code>，要找到最大的下标<code>j</code>和最小的下标<code>k</code>，满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j&lt;i&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[j]&lt;heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[k]&lt;heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，则存在一个宽度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，高度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的矩形，计算该矩形的最大面积</p>
<p>最为直观的做法是遍历每一个柱子，对于每个下标<code>i</code>，向两边遍历寻找对应的下标<code>j</code>和<code>k</code>，得到以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>为高的最大矩形宽度并计算矩形的面积，但是此算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，会超过时间限制</p>
<p>创建两个长度为<code>n</code>的数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，对于每个下标<code>i</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">left[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">right[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>分别记录对应的下标<code>j</code>和<code>k</code>。初始时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span>的全部元素为<code>-1</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>的全部元素为<code>n</code></p>
<p>从左到右遍历数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">heights</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span></span></span></span>，当遍历到下标<code>i</code>时，进行如下操作：</p>
<ul>
<li>如果栈不为空且栈顶下标对应的元素大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，则将栈顶下标对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>值设为<code>i</code>，重复该操作直到栈为空或者下标的元素小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></li>
<li>如果栈不为空，则栈顶下标对应的元素小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，因此将<code>i</code>对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span>值设为栈顶下标</li>
<li>将<code>i</code>入栈</li>
</ul>
<p>遍历结束之后，对于每个下标<code>i</code>，令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i=left[i],k=right[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[j]&lt;heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[k]&lt;heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[k]=heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，那么高度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heights[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的最大矩形宽度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>所以最大面积为比对之后的最大值</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] heights = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> ans = solution.LargestRectangleArea(heights);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LargestRectangleArea</span>(<span class="params"><span class="built_in">int</span>[] heights</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] left = <span class="keyword">new</span> <span class="built_in">int</span>[heights.Length];</span><br><span class="line">        <span class="built_in">int</span>[] right = <span class="keyword">new</span> <span class="built_in">int</span>[heights.Length];</span><br><span class="line">        Array.Fill(left, <span class="number">-1</span>);</span><br><span class="line">        Array.Fill(right, heights.Length);</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; heights.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> height = heights[i];</span><br><span class="line">            <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> &amp;&amp; heights[stack.Peek()] &gt;= height)</span><br><span class="line">            &#123;</span><br><span class="line">                right[stack.Pop()] = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stack.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = stack.Peek();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.Push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; heights.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = Math.Max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0085——最大矩形</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30085%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/maximal-rectangle/">最大矩形</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0085_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h2 id="示例3">示例3</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h2 id="示例4">示例4</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="示例5">示例5</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;,&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>是0084的进阶，可以将它升维转换为二维数组，具体如下<br>
比如matrix = [[“1”,“0”,“1”,“0”,“0”],[“1”,“0”,“1”,“1”,“1”],[“1”,“1”,“1”,“1”,“1”],[“1”,“0”,“0”,“1”,“0”]]<br>
可以转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 0 3 0 0</span><br><span class="line">3 0 2 3 2</span><br><span class="line">2 1 1 2 1</span><br><span class="line">1 0 0 1 0</span><br></pre></td></tr></table></figure>
<p>即：将需要讨论的内容缩小，将本来需要讨论的纵坐标转化为每一行的高，之后就可以根据0084的算法来对每一行的内容都取最大面积，之后对结果进行对比，最大的数即为结果</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[][] matrix = </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span>[] &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> ans = solution.MaximalRectangle(matrix);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaximalRectangle</span>(<span class="params"><span class="built_in">char</span>[][] matrix</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> rows = matrix.Length;</span><br><span class="line">        <span class="built_in">int</span> cols = matrix[<span class="number">0</span>].Length;</span><br><span class="line">        <span class="built_in">int</span>[] heights = <span class="keyword">new</span> <span class="built_in">int</span>[cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    heights[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    heights[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxArea = Math.Max(maxArea, GetMaxArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetMaxArea</span>(<span class="params"><span class="built_in">int</span>[] heights</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] left = <span class="keyword">new</span> <span class="built_in">int</span>[heights.Length];</span><br><span class="line">        <span class="built_in">int</span>[] right = <span class="keyword">new</span> <span class="built_in">int</span>[heights.Length];</span><br><span class="line">        Array.Fill(left, <span class="number">-1</span>);</span><br><span class="line">        Array.Fill(right, heights.Length);</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; heights.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> height = heights[i];</span><br><span class="line">            <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> &amp;&amp; heights[stack.Peek()] &gt;= height)</span><br><span class="line">            &#123;</span><br><span class="line">                right[stack.Pop()] = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stack.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = stack.Peek();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.Push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; heights.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = Math.Max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0086——分隔链表</title>
    <url>/2023/11/21/%E5%8A%9B%E6%89%A30086%E2%80%94%E2%80%94%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/partition-list/description/">分隔链表</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。<br>
你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0086_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,4,3,2,5,2], x = 3</span><br><span class="line">输出：[1,2,2,4,3,5]</span><br></pre></td></tr></table></figure>
<h2 id="示例2">示例2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [2,1], x = 2</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<h2 id="题解">题解</h2>
<p>来用两个链表进行拼接，如果比目标值小就添加到第一个链表，比目标值大或与目标值相等就添加到第二个链表，最后将两个链表拼接</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next = <span class="keyword">new</span> ListNode(<span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    next = <span class="keyword">new</span> ListNode(<span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        next = <span class="keyword">new</span> ListNode(<span class="number">5</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            next = <span class="keyword">new</span> ListNode(<span class="number">2</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode ans = solution.Partition(head, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (ans != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(ans.val);</span><br><span class="line">            ans = ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Partition</span>(<span class="params">ListNode head, <span class="built_in">int</span> x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode ans = head;</span><br><span class="line">        ListNode temp1 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode temp2 = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode s1 = temp1,s2 = temp2;</span><br><span class="line">        <span class="keyword">while</span> (ans != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans.val &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                s1.next = ans;</span><br><span class="line">                s1 = s1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s2.next = ans;</span><br><span class="line">                s2 = s2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">        s1.next = temp2.next;</span><br><span class="line">        s2.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> temp1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0087——扰乱字符串</title>
    <url>/2023/11/29/%E5%8A%9B%E6%89%A30087%E2%80%94%E2%80%94%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/scramble-string/description/">扰乱字符串</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：</p>
<ol>
<li>如果字符串的长度为 1 ，算法停止</li>
<li>如果字符串的长度 &gt; 1 ，执行下述步骤：
<ul>
<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li>
<li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li>
<li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>
</ul>
</li>
</ol>
<p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否是 <code>s1</code> 的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> s1 = “great”, s2 = “rgeat”<br>
<strong>输出：</strong> true</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> s1 = “abcde”, s2 = “caebd”<br>
<strong>输出：</strong> false</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> s1 = “a”, s2 = “a”<br>
<strong>输出：</strong> true</p>
<h2 id="题解">题解</h2>
<p>直接使用动态规划来解题，原始的递归方法中存在大量的重复操作，从而使时间复杂度大幅提高，这时可以使用一个三维数组<code>dp[i][j][k]</code>来记录，<code>i</code>表示<code>s1</code>起始位置，<code>j</code>表示<code>s2</code>起始位置，<code>k</code>表示当前字符串的长度<br>
转移方程如下：<br>
dp[i,j,k] = (dp[i,j,m] &amp;&amp; dp[i+m,j+m,k-m]) || (dp[i,j+k-m,m] &amp;&amp; dp[i+m,j,k-m])<br>
其中m的取值范围是[1,k)。这表示切割位置可以在1到k之间选择。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http.Headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;List&lt;<span class="built_in">string</span>&gt;&gt; strings = <span class="keyword">new</span> List&lt;List&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s1 = <span class="string">&quot;great&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> s2 = <span class="string">&quot;rgeat&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">bool</span> ans = solution.IsScramble(s1, s2);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsScramble</span>(<span class="params"><span class="built_in">string</span> s1, <span class="built_in">string</span> s2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.Equals(s2))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> length = s1.Length;</span><br><span class="line">        <span class="built_in">int</span>[,,] dp = <span class="keyword">new</span> <span class="built_in">int</span>[length, length, length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">1</span>; k &lt;= length; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= length - k; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt;= length - k; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i, j, k] = s1[i] == s2[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> m = <span class="number">1</span>; m &lt; k; m++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((dp[i, j, m] == <span class="number">1</span> &amp;&amp; dp[i + m, j + m, k - m] == <span class="number">1</span>) || (dp[i, j + k - m, m] == <span class="number">1</span> &amp;&amp; dp[i + m, j, k - m] == <span class="number">1</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i, j, k] = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>, <span class="number">0</span>, length] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0088——合并两个有序数组</title>
    <url>/2023/11/29/%E5%8A%9B%E6%89%A30088%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/merge-sorted-array/description/">合并两个有序数组</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p><strong>注意：</strong> 最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>
<strong>输出：</strong>[1,2,2,3,5,6]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> nums1 = [1], m = 1, nums2 = [], n = 0<br>
<strong>输出：</strong>[1]</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> nums1 = [0], m = 0, nums2 = [1], n = 1<br>
<strong>输出：</strong>[1]</p>
<h2 id="题解">题解</h2>
<p>因为<code>nums1</code>的长度为<code>m+n</code>，所以可以直接将<code>nums2</code>的内容加入到<code>nums1</code>中然后进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Sort</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span>排序</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">int</span>[] nums2 = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> m = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">3</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        solution.Merge(nums1, m, nums2, n);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Merge</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span> m, <span class="built_in">int</span>[] nums2, <span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = m, j = <span class="number">0</span>; j &lt; n; i++, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Array.Sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0089——格雷编码</title>
    <url>/2023/11/30/%E5%8A%9B%E6%89%A30089%E2%80%94%E2%80%94%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/gray-code/solutions/1636093/by-stormsunshine-gxoi/">格雷编码</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p><strong>n 位格雷码序列</strong> 是一个由 <code>2n</code> 个整数组成的序列，其中：</p>
<ul>
<li>每个整数都在范围 <code>[0, 2n - 1]</code> 内（含 <code>0</code> 和 <code>2n - 1</code>）</li>
<li>第一个整数是 <code>0</code></li>
<li>一个整数在序列中出现 <strong>不超过一次</strong></li>
<li>每对 <strong>相邻</strong> 整数的二进制表示 <strong>恰好一位不同</strong> ，且</li>
<li><strong>第一个</strong> 和 <strong>最后一个</strong> 整数的二进制表示 <strong>恰好一位不同</strong></li>
</ul>
<p>给你一个整数 <code>n</code> ，返回任一有效的 <strong>n 位格雷码序列</strong> 。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> n = 2<br>
<strong>输出：</strong>[0,1,3,2]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> n = 1<br>
<strong>输出：</strong>[0,1]</p>
<h2 id="题解">题解</h2>
<p>依题意得，数组的第一个元素必定是<code>0</code>，依据之后的规律可以发现，需要用到位运算<br>
定义<code>temp</code>为中间变量，令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mo>=</mo><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">temp = 1 &lt;&lt; (n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 即每一次循环中，temp都可以取到每一次遍历的位运算数<br>
定义一个<code>List</code>表，第一个元素为<code>0</code>，之后每一次遍历都需要对当前数组添加数据，添加的数据内容为让当前<code>List</code>表中的元素与<code>temp</code>进行按位或运算对的值<br>
遍历到最后将<code>List</code>表返回即为最终结果</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">2</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; ans = solution.GrayCode(n);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">GrayCode</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;()&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> lastTime = GrayCode(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> temp = <span class="number">1</span> &lt;&lt; (n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = lastTime.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            lastTime.Add(lastTime[i] | temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lastTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0090——子集II</title>
    <url>/2023/11/30/%E5%8A%9B%E6%89%A30090%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/subsets-ii/solutions/1927200/by-stormsunshine-jdn0/">子集</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> nums = [1,2,2]<br>
<strong>输出：</strong>[[],[1],[1,2],[1,2,2],[2],[2,2]]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> nums = [0]<br>
<strong>输出：</strong>[[],[0]]</p>
<h2 id="题解">题解</h2>
<p>先将数组排序，生成所有的子集，排序之后相同的元素位于相邻的位置，利用这一特点去重<br>
去重操作主要是判断前一个数和当前数字是否相等，如果不相等就继续进行之后的操作，相等则跳出本次回溯<br>
当遍历到数组中下标为<code>i</code>的数时，执行如下操作：</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那么得到一个子集，将子集添加到答案中</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，则分别考虑将其加入到子集和不加入到子集中两种情况
<ul>
<li>不将其加入子集则继续对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 进行回溯</li>
<li>如果可以加入到子集中，则将其加入到子集中之后继续回溯，回溯之后将当前子集的末尾元素移除，恢复到初始状态</li>
</ul>
</li>
</ul>
<p>遍历结束之后，就可以得到最终答案</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">        ans = solution.SubsetsWithDup(nums);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> j <span class="keyword">in</span> i)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; powerSet = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">    IList&lt;<span class="built_in">int</span>&gt; temp = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="built_in">int</span>[] nums;</span><br><span class="line">    <span class="built_in">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; SubsetsWithDup(<span class="built_in">int</span>[] nums)</span><br><span class="line">    &#123;</span><br><span class="line">        Array.Sort(nums);</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">this</span>.n = nums.Length;</span><br><span class="line">        Backtrack(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> powerSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Backtrack</span>(<span class="params"><span class="built_in">int</span> index, <span class="built_in">bool</span> prevSelected</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == n)</span><br><span class="line">        &#123;</span><br><span class="line">            powerSet.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Backtrack(index + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span> || nums[index - <span class="number">1</span>] != nums[index] || prevSelected)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.Add(nums[index]);</span><br><span class="line">                Backtrack(index + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">                temp.RemoveAt(temp.Count - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0091——解码方法</title>
    <url>/2023/12/03/%E5%8A%9B%E6%89%A30091%E2%80%94%E2%80%94%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/decode-ways/description/">解码方法</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<p>‘A’ -&gt; “1”<br>
‘B’ -&gt; “2”<br>
…<br>
‘Z’ -&gt; “26”</p>
<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> s = “12”<br>
<strong>输出：</strong> 2</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> s = “226”<br>
<strong>输出：</strong> 3</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> s = “06”<br>
<strong>输出：</strong> 0</p>
<h2 id="题解">题解</h2>
<p>依题意得，编码得第一个数字不能为1，则可分为以下部分：</p>
<ul>
<li>当<code>s[0] == '0'</code>，那么直接返回<code>0</code></li>
<li>之后由第二个元素开始遍历
<ul>
<li>当当前元素为<code>0</code>，那么前一个元素只能为两种情况：
<ul>
<li>当前一个元素为<code>1</code>或<code>2</code>时，只有一种解法</li>
<li>当前一个元素不为上述两个数，则没有解法</li>
</ul>
</li>
<li>当当前元素为<code>1</code>或<code>2</code>并且前一个元素和当前元素拼接的数字不大于26
<ul>
<li>有两种解法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>最后将遍历结束的值返回即为所求</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;27&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> ans = solution.NumDecodings(s);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">NumDecodings</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; s.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> temp = curr;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    curr = pre;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; (s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                curr = curr + pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0092——反转链表II</title>
    <url>/2023/12/03/%E5%8A%9B%E6%89%A30092%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">反转链表II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0092_1.jpg" alt="image"><br>
<strong>输入：</strong> head = [1,2,3,4,5], left = 2, right = 4<br>
<strong>输出：</strong>[1,4,3,2,5]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> head = [5], left = 1, right = 1<br>
<strong>输出：</strong>[5]</p>
<h2 id="题解">题解</h2>
<p>由于没有提及修改原链表节点，那么可以直接修改值，具体方法如下</p>
<ul>
<li>快慢指针，慢指针指向<code>left</code>，快指针指向<code>right</code>，将两个值交换</li>
<li>将慢指针右移，快指针移动到<code>right - 1</code>，继续交换</li>
</ul>
<p>当左右指针会面，即可结束，得到最终答案</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val; </span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                next = <span class="keyword">new</span> ListNode(<span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    next = <span class="keyword">new</span> ListNode(<span class="number">4</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        next = <span class="keyword">new</span> ListNode(<span class="number">5</span>) </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> right = <span class="number">4</span>;</span><br><span class="line">        ListNode ans = solution.ReverseBetween(head, left, right);</span><br><span class="line">        <span class="keyword">while</span> (ans != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(ans.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            ans = ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseBetween</span>(<span class="params">ListNode head, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode ans = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = left; i &lt; right; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode fast = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; right - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> temp = fast.val;</span><br><span class="line">            fast.val = slow.val;</span><br><span class="line">            slow.val = temp;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0093——复原ip地址</title>
    <url>/2023/12/04/%E5%8A%9B%E6%89%A30093%E2%80%94%E2%80%94%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">复原ip地址</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>
<ul>
<li>例如：<code>&quot;0.1.2.201&quot;</code> 和 <code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> s = “25525511135”<br>
<strong>输出：</strong>[“255.255.11.135”,“255.255.111.35”]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> s = “0000”<br>
<strong>输出：</strong>[“0.0.0.0”]</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> s = “101023”<br>
<strong>输出：</strong>[“1.0.10.23”,“1.0.102.3”,“10.1.0.23”,“10.10.2.3”,“101.0.2.3”]</p>
<h2 id="题解">题解</h2>
<p>可以使用回溯法来解题<br>
回溯时需要记录起始下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span> 和片段数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>，使用长度为<code>4</code>的数组记录每个片段对应的整数，初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">count = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">start = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,对于每个片段，只有不含有前导零且对应的整数范围在 [<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>255</mn></mrow><annotation encoding="application/x-tex">0,255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span>]，才可能是有效的ip地址</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">count=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，则只有<code>s</code>遍历结束之后才能得到有效的ip地址，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">start=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 时，字符串<code>s</code>遍历结束，根据数组中的整数生成ip地址并添加到答案中</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">count&lt;4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，则当前片段对应的编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>，用<code>end</code>表示当前片段的结束下标，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>:</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">start:end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>]$ 来表示字符串的下标范围 [<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo separator="true">,</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">start,end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>] 的子数组，将<code>end</code>从<code>start</code>到<code>n-1</code>依次遍历，执行如下操作：
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>:</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">start:end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>]$ 不含有前导零且对应的整数在范围[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>255</mn></mrow><annotation encoding="application/x-tex">0,255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span>]则当前片段可能是有效 IP 地址的一个片段，将当前片段对应的整数填入数组的下标<code>count</code>中，继续对下一个片段回溯，下一个片段的起始下标是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">end + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，下一个片段的片段数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">count + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>:</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">start:end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>]$ 含前导零或对应的整数不在范围[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>255</mn></mrow><annotation encoding="application/x-tex">0,255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span>]则当前片段不可能是有效 IP 地址的一个片段，如果继续将<code>end</code>向右移动则当前片段一定不符合有效 IP 地址的规则，因此结束对当前<code>start</code>的回溯</li>
</ul>
</li>
</ul>
<p>回溯结束时，即可得到所有可能的有效 IP 地址。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> n; </span><br><span class="line">    <span class="built_in">string</span> s; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> maxAdd = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">int</span>[] ipArr = <span class="keyword">new</span> <span class="built_in">int</span>[maxAdd];</span><br><span class="line">    IList&lt;<span class="built_in">string</span>&gt; ipAddress = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;25525511135&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;<span class="built_in">string</span>&gt; ans = solution.RestoreIpAddresses(s);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> ip <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; <span class="title">RestoreIpAddresses</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = s.Length;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; maxAdd || n &gt; <span class="number">3</span> * maxAdd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ipAddress;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BackTrack(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ipAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params"><span class="built_in">int</span> start, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == maxAdd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == n)</span><br><span class="line">            &#123;</span><br><span class="line">                ipAddress.Add(Convert(ipArr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> end = start; end &lt; n &amp;&amp; flag; end++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Valid(start, end))</span><br><span class="line">                &#123;</span><br><span class="line">                    ipArr[count] = <span class="built_in">int</span>.Parse(s.Substring(start, end - start + <span class="number">1</span>));</span><br><span class="line">                    BackTrack(end + <span class="number">1</span>, count + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">int</span>[] ipArr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.Append(ipArr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; maxAdd; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.Append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            sb.Append(ipArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.ToString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Valid</span>(<span class="params"><span class="built_in">int</span> start, <span class="built_in">int</span> end</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = end - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">1</span> || length &gt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">1</span> &amp;&amp; s[start] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>.Parse(s.Substring(start, end - start + <span class="number">1</span>)) &lt;= <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0094——二叉树的中序遍历</title>
    <url>/2023/12/04/%E5%8A%9B%E6%89%A30094%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">二叉树的中序遍历</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0094_1.jpg" alt="image"><br>
<strong>输入：</strong> root = [1,null,2,3]<br>
<strong>输出：</strong>[1,3,2]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> root = []<br>
<strong>输出：</strong>[]</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> root = [1]<br>
<strong>输出：</strong>[1]</p>
<h2 id="题解">题解</h2>
<p>根据中序遍历的基本思想直接写出即可</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val=<span class="number">0</span>, TreeNode left=<span class="literal">null</span>, TreeNode right=<span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; ans = solution.InorderTraversal(root);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> x <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">InorderTraversal</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; ans = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        BackTrack(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root, IList&lt;<span class="built_in">int</span>&gt; ans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BackTrack(root.left, ans);</span><br><span class="line">        ans.Add(root.val);</span><br><span class="line">        BackTrack(root.right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0095——不同的二叉搜索树II</title>
    <url>/2023/12/04/%E5%8A%9B%E6%89%A30095%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/description/">不同的二叉搜索树II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0095_1.jpg" alt="image"><br>
<strong>输入：</strong> n = 3<br>
<strong>输出：</strong>[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> n = 1<br>
<strong>输出：</strong>[[1]]</p>
<h2 id="题解">题解</h2>
<p>根据<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855?fr=ge_ala">二叉搜索树的概念</a>可以分析得到这是一个递归方法解决的问题</p>
<ul>
<li>由n个节点组成的二叉搜索树的节点值范围为[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>]，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">rootValue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span> 表示根结点值，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\leq rootValue\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，根节点左子树的范围为[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1,rootValue-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>]，根节点右子树的范围为[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">rootValue-1,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>]</li>
<li>对于每一个根节点，左右子树有多种情况，可以是任意一个符合要求的子树</li>
<li>用[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo separator="true">,</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">start,end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>]表示二叉搜索树的取值范围，终止条件为取值范围为空，当节点值不为空的时候分别将每个节点值作为根节点值，然后递归构造左右子树</li>
</ul>
<p>最后将答案添加到列表中返回即可得到最终结果</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">3</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;TreeNode&gt; ans = solution.GenerateTrees(n);</span><br><span class="line">        <span class="keyword">foreach</span> (TreeNode node <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            IList&lt;<span class="built_in">int</span>&gt; temp = solution.InorderTraversal(node);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> temp)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;TreeNode&gt; <span class="title">GenerateTrees</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> CallBack(<span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">CallBack</span>(<span class="params"><span class="built_in">int</span> start, <span class="built_in">int</span> end</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;TreeNode&gt; ans = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.Add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;TreeNode&gt; leftTrees = CallBack(start,i - <span class="number">1</span>);</span><br><span class="line">                List&lt;TreeNode&gt; rightTrees = CallBack(i + <span class="number">1</span>,end);</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> leftTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> rightTrees)</span><br><span class="line">                    &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.left = a;</span><br><span class="line">                        root.right = b;</span><br><span class="line">                        ans.Add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">InorderTraversal</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; ans = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        BackTrack(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root, IList&lt;<span class="built_in">int</span>&gt; ans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BackTrack(root.left, ans);</span><br><span class="line">        ans.Add(root.val);</span><br><span class="line">        BackTrack(root.right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0096——不同的二叉搜索树</title>
    <url>/2023/12/04/%E5%8A%9B%E6%89%A30096%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">不同的二叉搜索树</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0095_1.jpg" alt="image"><br>
<strong>输入：</strong> n = 3<br>
<strong>输出：</strong> 5</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> n = 1<br>
<strong>输出：</strong> 1</p>
<h2 id="题解">题解</h2>
<p>依据动态规划解题，进行如下操作</p>
<ul>
<li>因为当节点数为<code>0</code>的时候是一个空的树，所以返回值也为<code>1</code>，所以边界值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[0]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>当根节点确定时，设不同左子树的数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">leftCount</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>，不同右子树数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rightCount</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>，故不同的二叉搜索树数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>∗</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">leftCount * rightCount</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></li>
<li>所以，进行循环，当循环结束即可得到最终结果</li>
</ul>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.Intrinsics.Arm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">3</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Console.WriteLine(solution.NumTrees(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">NumTrees</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0097——交错字符串</title>
    <url>/2023/12/05/%E5%8A%9B%E6%89%A30097%E2%80%94%E2%80%94%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/interleaving-string/description/">交错字符串</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p>
<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0097_1.jpg" alt="image"><br>
<strong>输入：</strong> s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>
<strong>输出：</strong> true</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”<br>
<strong>输出：</strong> false</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> s1 = “”, s2 = “”, s3 = “”<br>
<strong>输出：</strong> true</p>
<h2 id="题解">题解</h2>
<p>由题意可知此题由动态规划可解</p>
<ol>
<li>创建bool类型二维数组<code>dp[i1+1][i2+1]</code>，<code>dp[i][j]==true</code>表示s1的前<code>i</code>个字符与<code>s2</code>的前<code>j</code>个字符能够交错组成s3的前<code>i+j</code>个字符</li>
<li>那么<code>dp[i][j]</code>的公式可得：
<ul>
<li>初始条件为，<code>dp[0][0]=true</code></li>
<li>若<code>i==0</code>，即不算<code>s1</code>，只比较<code>s2</code>和<code>s3</code>的前<code>i</code>个字符</li>
<li>若<code>j==0</code>，则不算<code>s2</code>，值比较<code>s1</code>和<code>s3</code>的前<code>j</code>个字符</li>
<li>其他情况下要做两个判断：
<ul>
<li><code>dp[i][j]</code>是否为<code>true</code>且<code>s1[i-1]</code>是否等于<code>s3[i+j-1]</code></li>
<li><code>dp[i][j]</code>是否为<code>true</code>且<code>s2[j-1]</code>是否等于<code>s3[i+j-1]</code></li>
<li>上述两个判断满足其一即可将<code>dp[i][j]</code>赋值为<code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>最终返回<code>dp[i1][i2]</code>即为所求</li>
</ol>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> s1 = <span class="string">&quot;aabcc&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> s2 = <span class="string">&quot;dbbca&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> s3 = <span class="string">&quot;aadbbcbcac&quot;</span>;</span><br><span class="line">        Console.WriteLine(solution.IsInterleave(s1,s2,s3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsInterleave</span>(<span class="params"><span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i1 = s1.Length;</span><br><span class="line">        <span class="built_in">int</span> i2 = s2.Length;</span><br><span class="line">        <span class="built_in">int</span> i3 = s3.Length;</span><br><span class="line">        <span class="keyword">if</span> (i1 + i2 != i3)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">bool</span>[][] dp = <span class="keyword">new</span> <span class="built_in">bool</span>[i1 + <span class="number">1</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; i1 + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="built_in">bool</span>[i2 + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i2 + <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = s2.Substring(<span class="number">0</span>, j) == s3.Substring(<span class="number">0</span>, j);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = s1.Substring(<span class="number">0</span>, i) == s3.Substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]) || (dp[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i1][i2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0098——验证二叉搜索树</title>
    <url>/2023/12/05/%E5%8A%9B%E6%89%A30098%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">验证二叉搜索树</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0098_1.jpg" alt="image"><br>
<strong>输入：</strong> root = [2,1,3]<br>
<strong>输出：</strong> true</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0098_2.jpg" alt="iamge"><br>
<strong>输入：</strong> root = [5,1,4,null,null,3,6]<br>
<strong>输出：</strong> false</p>
<h2 id="题解">题解</h2>
<p>由题意得需要使用回溯法解题，使用以下步骤</p>
<ul>
<li>当回溯到根节点为空，返回<code>true</code></li>
<li>当回溯到根节点比最小值要小，返回<code>false</code></li>
<li>当回溯到根节点比最大值要大，返回<code>false</code></li>
</ul>
<p>遍历结束之后返回最终回溯的结果即为所得</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode treeNode = <span class="keyword">new</span> TreeNode(<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Console.WriteLine(solution.IsValidBST(treeNode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsValidBST</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BackTrack(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root, <span class="built_in">int</span>? min, <span class="built_in">int</span>? max</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BackTrack(root.left,min,root.val) &amp;&amp; BackTrack(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0099——恢复二叉搜索树</title>
    <url>/2023/12/05/%E5%8A%9B%E6%89%A30099%E2%80%94%E2%80%94%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/recover-binary-search-tree/description/">恢复二叉搜索树</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0099_1.jpg" alt="image"><br>
<strong>输入：</strong> root = [1,3,null,null,2]<br>
<strong>输出：</strong>[3,1,null,null,2]</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0099_2.jpg" alt="iamge"><br>
<strong>输入：</strong> root = [3,1,4,null,null,2]<br>
<strong>输出：</strong>[2,1,4,null,null,3]</p>
<h2 id="题解">题解</h2>
<p>因为二叉搜索树的性质可得，将其中序遍历存储到列表中，数值为单调递增，由此可以得到以下步骤</p>
<ul>
<li>遍历列表，找到递增中断点</li>
<li>再次遍历列表，找到中断点应该在的位置</li>
<li>将两个数值进行交换</li>
</ul>
<p>完成之后即为所求</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    IList&lt;TreeNode&gt; travelList = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        solution.RecoverTree(root);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> solution.travelList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(a.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RecoverTree</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Travel(root);</span><br><span class="line">        <span class="built_in">int</span> index1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; travelList.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (travelList[index1].val &gt; travelList[index1 - <span class="number">1</span>].val)</span><br><span class="line">            &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index2 &lt; travelList.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (travelList[index2].val &gt; travelList[index1 - <span class="number">1</span>].val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode treeNode1 = travelList[index1 - <span class="number">1</span>];</span><br><span class="line">        TreeNode treeNode2 = travelList[index2 - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> val1 = treeNode1.val;</span><br><span class="line">        <span class="built_in">int</span> val2 = treeNode2.val;</span><br><span class="line">        treeNode1.val = val2;</span><br><span class="line">        treeNode2.val = val1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Travel</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Travel(root.left);</span><br><span class="line">        travelList.Add(root);</span><br><span class="line">        Travel(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0100——相同的树</title>
    <url>/2023/12/05/%E5%8A%9B%E6%89%A30100%E2%80%94%E2%80%94%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/same-tree/description/">相同的树</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0100_1.jpg" alt="image"><br>
<strong>输入：</strong> p = [1,2,3], q = [1,2,3]<br>
<strong>输出：</strong> true</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0100_2.jpg" alt="image"><br>
<strong>输入：</strong> p = [1,2], q = [1,null,2]<br>
<strong>输出：</strong> false</p>
<h2 id="示例3">示例3</h2>
<p><img src="/images/ltc0100_3.jpg" alt="image"><br>
<strong>输入：</strong> p = [1,2,1], q = [1,1,2]<br>
<strong>输出：</strong> false</p>
<h2 id="题解">题解</h2>
<p>依据题意得，本体需要使用回溯法解题，基本思想就是遍历每个节点之后对比</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.Intrinsics.Arm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode p = <span class="keyword">new</span> TreeNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        TreeNode q = <span class="keyword">new</span> TreeNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Console.WriteLine(solution.IsSameTree(p,q));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsSameTree</span>(<span class="params">TreeNode p, TreeNode q</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; IsSameTree(p.left,q.left) &amp;&amp; IsSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0101——对称二叉树</title>
    <url>/2023/12/05/%E5%8A%9B%E6%89%A30101%E2%80%94%E2%80%94%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/symmetric-tree/description/">对称二叉树</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0101_1.png" alt="image"><br>
<strong>输入：</strong> root = [1,2,2,3,4,4,3]<br>
<strong>输出：</strong> true</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0101_2.png" alt="iamge"><br>
<strong>输入：</strong> root = [1,2,2,null,3,null,3]<br>
<strong>输出：</strong> false</p>
<h2 id="题解">题解</h2>
<p>和第 0100 题相同的解法，利用回溯法求解，不同的是比较左右两个子树</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Console.WriteLine(solution.IsSymmetric(root));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsSymmetric</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BackTrack(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">BackTrack</span>(<span class="params">TreeNode p, TreeNode q</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; BackTrack(p.left, q.right) &amp;&amp; BackTrack(p.right,q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0102——二叉树的层序遍历</title>
    <url>/2023/12/06/%E5%8A%9B%E6%89%A30102%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">二叉树的层序遍历</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0102_1.jpg" alt="image"><br>
<strong>输入：</strong> root = [3,9,20,null,null,15,7]<br>
<strong>输出：</strong>[[3],[9,20],[15,7]]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> root = [1]<br>
<strong>输出：</strong>[[1]]</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> root = []<br>
<strong>输出：</strong>[]</p>
<h2 id="题解">题解</h2>
<p>由题意得，可以利用队列来进行解题，可获得如下步骤</p>
<ul>
<li>将根节点入队，当队列内元素个数不为零，进行如下循环：
<ul>
<li>进行队列元素个数次循环（嵌套第一次循环内）
<ul>
<li>队列出队一个元素，将其添加到列表中，判断其左右子树是否为空
<ul>
<li>如果均为空，则结束本次循环</li>
<li>如果有元素，就将其入队</li>
</ul>
</li>
</ul>
</li>
<li>将列表添加到答案中，并进行下一次循环</li>
</ul>
</li>
</ul>
<p>循环结束后得答案即为所求</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode roots = <span class="keyword">new</span> TreeNode(<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">15</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = solution.LevelOrder(roots);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; LevelOrder(TreeNode root)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">        queue.Enqueue(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            IList&lt;<span class="built_in">int</span>&gt; tmp = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            <span class="built_in">int</span> count  = queue.Count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode treeNode = queue.Dequeue();</span><br><span class="line">                tmp.Add(treeNode.val);</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.Enqueue(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (treeNode.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.Enqueue(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.Add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0103——二叉树的锯齿形层序遍历</title>
    <url>/2023/12/06/%E5%8A%9B%E6%89%A30103%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">二叉树的锯齿形层序遍历</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0102_1.jpg" alt="image"><br>
<strong>输入：</strong> root = [3,9,20,null,null,15,7]<br>
<strong>输出：</strong>[[3],[20,9],[15,7]]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> root = [1]<br>
<strong>输出：</strong>[[1]]</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> root = []<br>
<strong>输出：</strong>[]</p>
<h2 id="题解">题解</h2>
<p>和 0102 题类似，不同的是从左到右的时候对<code>List</code>得操作是<code>Add</code>，从右到左的时候是<code>Insert</code>到最前面</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode (<span class="number">15</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode (<span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = solution.ZigzagLevelOrder(root);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ZigzagLevelOrder(TreeNode root)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">        queue.Enqueue(root);</span><br><span class="line">        <span class="built_in">bool</span> isLeftFirst = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            IList&lt;<span class="built_in">int</span>&gt; tmp = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            <span class="built_in">int</span> count = queue.Count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node = queue.Dequeue();</span><br><span class="line">                <span class="keyword">if</span> (isLeftFirst)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.Add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.Insert(<span class="number">0</span>, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.Enqueue(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.Enqueue(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.Add(tmp);</span><br><span class="line">            isLeftFirst = !isLeftFirst;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0104——二叉树的最大深度</title>
    <url>/2023/12/06/%E5%8A%9B%E6%89%A30104%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0104_1.jpg" alt="image"><br>
<strong>输入：</strong> root = [3,9,20,null,null,15,7]<br>
<strong>输出：</strong> 3</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> root = [1,null,2]<br>
<strong>输出：</strong> 2</p>
<h2 id="题解">题解</h2>
<p>遍历每一个子树存下最大值，每遍历到最后的子叶和最大值进行比较<br>
遍历结束之后的答案即为所得</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode (<span class="number">15</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode (<span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Console.WriteLine(solution.MaxDepth(root));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxDepth</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BackTrack(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root, <span class="built_in">int</span> maxt,<span class="built_in">int</span> tmp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        maxt = max;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxt &lt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                max = tmp;</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BackTrack(root.left, maxt, tmp+<span class="number">1</span>);</span><br><span class="line">        BackTrack(root.right, maxt, tmp+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0105——从前序与中序遍历序列构造二叉树</title>
    <url>/2023/12/06/%E5%8A%9B%E6%89%A30105%E2%80%94%E2%80%94%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">从前序与中序遍历序列构造二叉树</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0105_1.jpg" alt="image"><br>
<strong>输入:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>
<strong>输出:</strong> [3,9,20,null,null,15,7]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入:</strong> preorder = [-1], inorder = [-1]<br>
<strong>输出:</strong> [-1]</p>
<h2 id="题解">题解</h2>
<p>遍历前序遍历序列，对于每个值分别创建结点，将每个结点作为上一个结点的左子结点，并将每个结点入栈，直到前序遍历序列的上一个结点值等于中序遍历序列的当前结点值。然后遍历中序遍历序列并依次将栈内的结点出栈，直到栈顶结点值和中序遍历序列的当前结点值不同，此时前序遍历序列的当前值对应的结点为最后一个出栈的结点的右子结点，将当前结点入栈。然后对前序遍历序列和中序遍历序列的其余值继续执行上述操作，直到遍历结束时，二叉树构造完毕。</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] preorder = &#123; <span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] inorder = &#123; <span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        TreeNode ans = solution.BuildTree(preorder, inorder);</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; tmp = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        solution.BackTrack(ans, tmp);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">BuildTree</span>(<span class="params"><span class="built_in">int</span>[] preorder, <span class="built_in">int</span>[] inorder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> length = inorder.Length;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.Push(root);</span><br><span class="line">        <span class="built_in">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode prev = stack.Peek();</span><br><span class="line">            TreeNode curr = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">            <span class="keyword">if</span> (prev.val != inorder[inorderIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                prev.left = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> &amp;&amp; stack.Peek().val == inorder[inorderIndex])</span><br><span class="line">                &#123;</span><br><span class="line">                    prev = stack.Pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                prev.right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.Push(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root, IList&lt;<span class="built_in">int</span>&gt; list</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BackTrack(root.left, list);</span><br><span class="line">        list.Add(root.val);</span><br><span class="line">        BackTrack(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0106——从中序与后序遍历构造二叉树</title>
    <url>/2023/12/08/%E5%8A%9B%E6%89%A30106%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">从中序与后序遍历构造二叉树</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0105_1.jpg" alt="image"><br>
<strong>输入：</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<br>
<strong>输出：</strong>[3,9,20,null,null,15,7]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> inorder = [-1], postorder = [-1]<br>
<strong>输出：</strong>[-1]</p>
<h2 id="题解">题解</h2>
<p>因为后序遍历中最后一个元素为根节点，可以根据根节点将中序分割为左右，之后在根据中序左右子树的节点数量等于后续左右子树节点数量分割后续</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] inorder = &#123; <span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span>[] postorder = &#123; <span class="number">9</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        TreeNode ans = solution.BuildTree(inorder, postorder);</span><br><span class="line">        solution.BackTrack(ans, list);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">BuildTree</span>(<span class="params"><span class="built_in">int</span>[] inorder, <span class="built_in">int</span>[] postorder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span>(<span class="number">0</span>);</span><br><span class="line">        BuildNode(root, inorder, <span class="number">0</span>, inorder.Length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.Length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuildNode</span>(<span class="params">TreeNode node, <span class="built_in">int</span>[] inorder, <span class="built_in">int</span> instart, <span class="built_in">int</span> inend, <span class="built_in">int</span>[] postorder, <span class="built_in">int</span> poststart, <span class="built_in">int</span> postend</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        node.val = postorder[postend];</span><br><span class="line">        <span class="built_in">int</span> inHead = Array.IndexOf(inorder, node.val);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> inendLeft = inHead - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> postendLeft = poststart + inendLeft - instart;</span><br><span class="line">        <span class="keyword">if</span> (inendLeft &gt;= instart)</span><br><span class="line">        &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">            BuildNode(node.left, inorder, instart, inendLeft, postorder, poststart, postendLeft);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> instartRight = inHead + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> poststartRight = postendLeft + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (inend &gt;= instartRight)</span><br><span class="line">        &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">            BuildNode(node.right, inorder, instartRight, inend, postorder, poststartRight, postend - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root,List&lt;<span class="built_in">int</span>&gt; list</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BackTrack(root.left,list);</span><br><span class="line">        list.Add(root.val);</span><br><span class="line">        BackTrack(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0107——二叉树的层序遍历II</title>
    <url>/2023/12/08/%E5%8A%9B%E6%89%A30107%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">二叉树的层序遍历II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0102_1.jpg" alt="image"><br>
<strong>输入：</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<br>
<strong>输出：</strong>[3,9,20,null,null,15,7]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> inorder = [-1], postorder = [-1]<br>
<strong>输出：</strong>[-1]</p>
<h2 id="题解">题解</h2>
<p>和 0102 题解题思路相同，不同的只不过是最后将<code>List</code>加入到<code>List&lt;List&gt;</code>中的时候变为<code>Insert</code>即可</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">15</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = solution.LevelOrderBottom(root);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; LevelOrderBottom(TreeNode root)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">        queue.Enqueue(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            IList&lt;<span class="built_in">int</span>&gt; tmp = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            <span class="built_in">int</span> count = queue.Count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode treeNode = queue.Dequeue();</span><br><span class="line">                tmp.Add(treeNode.val);</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.Enqueue(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (treeNode.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.Enqueue(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.Insert(<span class="number">0</span>,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0108——将有序数组转换为二叉搜索树</title>
    <url>/2023/12/08/%E5%8A%9B%E6%89%A30108%E2%80%94%E2%80%94%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">将有序数组转换为二叉搜索树</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0108_1.jpg" alt="image"><br>
<strong>输入：</strong> nums = [-10,-3,0,5,9]<br>
<strong>输出：</strong>[0,-3,9,-10,null,5]<br>
或者也可以为：<br>
<img src="/images/ltc0108_2.jpg" alt="image"><br>
<strong>输出：</strong>[0,-10,5,null,-3,null,9]</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0108_3.jpg" alt="iamge"><br>
<strong>输入：</strong> nums = [1,3]<br>
<strong>输出：</strong>[3,1]</p>
<h2 id="题解">题解</h2>
<p>直接使用回溯法，基本原理就是二分数组，将左边的值按照二分法赋值给左子树，右边的值按照二分法赋值给右子树</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">-10</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        TreeNode root = solution.SortedArrayToBST(nums);</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        solution.AddTree(root, list);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">SortedArrayToBST</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BackTrack(nums,<span class="number">0</span>,nums.Length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">BackTrack</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> start, <span class="built_in">int</span> end</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[mid], BackTrack(nums, start, mid - <span class="number">1</span>), BackTrack(nums, mid + <span class="number">1</span>, end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddTree</span>(<span class="params">TreeNode root, IList&lt;<span class="built_in">int</span>&gt; ans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AddTree(root.left, ans);</span><br><span class="line">        ans.Add(root.val);</span><br><span class="line">        AddTree(root.right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity高度解耦合-事件的监听和广播系统</title>
    <url>/2023/12/09/Unity%E9%AB%98%E5%BA%A6%E8%A7%A3%E8%80%A6%E5%90%88-%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E5%92%8C%E5%B9%BF%E6%92%AD%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1>Unity高度解耦合-事件的监听和广播系统</h1>
<h2 id="使用事件的广播与监听系统">使用事件的广播与监听系统</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">	<span class="comment">//使用监听函数，传入的第一个数据为唯一的事件码，可以在EventType(新的文件，内部只有枚举类)</span></span><br><span class="line">	<span class="comment">//第二个数据是一个委托，即本文件下的Show方法</span></span><br><span class="line">	<span class="comment">//如果传入的委托是有参数的，必须添加相应的泛型</span></span><br><span class="line">	EventCenter.AddListener&lt;<span class="built_in">string</span>&gt;(EventType.ShowText,Show);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//使用监听的时候要在OnDestroy()的时候进行移除</span></span><br><span class="line">	<span class="comment">//如果不移除的话在后续的使用中会报错</span></span><br><span class="line">	<span class="comment">//只需要调用RemoveListener方法即可，传入的数据一致</span></span><br><span class="line">	EventCenter.RemoveListener&lt;<span class="built_in">string</span>&gt;(EventType.ShowText,Show);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">	GetComponent&lt;Text&gt;().text = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EventType</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//这个枚举中的方法对应上面代码传入的EventType.ShowText，为唯一的事件码</span></span><br><span class="line">	ShowText,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//使用的时候只需要广播一下事件码，之后的参数为之前定义的参数</span></span><br><span class="line">	<span class="comment">//如果不传递或传递类型不正确就会报错</span></span><br><span class="line">	EventCenter.Broadcast(EventType.ShowText,<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建添加监听的方法">创建添加监听的方法</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建字典的key为EventeType，value为Delegate(委托)</span></span><br><span class="line">	<span class="keyword">private</span> Dictionary&lt;EventType,Delegate&gt; m_EventTable = <span class="keyword">new</span> Dictionary&lt;EventType,Delegate&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//无参添加监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>(<span class="params">EventType eventType,CallBack callBack</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!m_EventTable.ContainsKey(eventType))</span><br><span class="line">		&#123;</span><br><span class="line">			m_EventTable.Add(eventType,<span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Delegate d = m_EventTable[eventType];</span><br><span class="line">		<span class="keyword">if</span>(d != <span class="literal">null</span> &amp;&amp; d.GetType() != callBack.GetType())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;尝试为事件&#123;0&#125;添加不同类型的委托，当前事件所对应的委托是&#123;1&#125;，要添加的委托类型为&#123;2&#125;&quot;</span>，eventType,d.GetType(),callBack.GetType()));</span><br><span class="line">		&#125;</span><br><span class="line">		m_EventTable[eventType] = (CallBack)m_EventTable[eventType] + callBack;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参移除监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>(<span class="params">EventType eventType,CallBack callBack</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_EventType.ContainsKey(eventType))</span><br><span class="line">		&#123;</span><br><span class="line">			Delegate d = EventTable[eventType];</span><br><span class="line">			<span class="keyword">if</span>(d == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：时间&#123;0&#125;没有对应的委托&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(d.GetType() != callBack.GetType())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：尝试为事件&#123;0&#125;移除不同类型的委托，当前委托类型为&#123;1&#125;，要移除的类型为&#123;2&#125;&quot;</span>,eventType,d.GetType(),callBack.GetType()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Excption(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：没有事件码&#123;0&#125;&quot;</span>,eventType));</span><br><span class="line">		&#125;</span><br><span class="line">		m_EventType[eventType] = (CallBack)m_EventType[eventType] - callBack;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参广播监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>(<span class="params">EventType eventType</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack callBack = d <span class="keyword">as</span> CallBack;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EventType</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>&gt;(<span class="params">T arg</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="创建测试脚本来测试无参的监听和广播">创建测试脚本来测试无参的监听和广播</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShowText</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">		EventCenter.AddListener(EventType.ShowText,Show);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		EventCenter.RemoveListener(EventType.ShowText,Show);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要在EventType文件下添加枚举属性，具体如下</p>
</blockquote>
 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EventType</span><br><span class="line">&#123;</span><br><span class="line">ShowText,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试脚本编辑如下</p>
</blockquote>
 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BtnClick</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		EventCenter.Broadcast(EventType.ShowText);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带有一个参数的监听和广播的方法">带有一个参数的监听和广播的方法</h2>
<blockquote>
<p>因为已经在上面的CallBack文件中创建了带有一个参数的委托方法的定义，所以直接在EventCenter中继续写带有一个监听和广播的方法即可</p>
</blockquote>
 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带有一个参数添加监听的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T&gt; callBack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!m_EventTable.ContainsKey(eventType))</span><br><span class="line">&#123;</span><br><span class="line">	m_EventTable.Add(eventType,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">Delegate d = m_EventTable[eventType];</span><br><span class="line"><span class="keyword">if</span>(d != <span class="literal">null</span> &amp;&amp; d.GetType() != callBack.GetType())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;尝试为事件&#123;0&#125;添加不同类型的委托，当前事件所对应的委托是&#123;1&#125;，要添加的委托类型为&#123;2&#125;&quot;</span>，eventType,d.GetType(),callBack.GetType()));</span><br><span class="line">&#125;</span><br><span class="line">m_EventTable[eventType] = (CallBack&lt;T&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带有一个参数移除监听的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T&gt; callBack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_EventType.ContainsKey(eventType))</span><br><span class="line">&#123;</span><br><span class="line">	Delegate d = EventTable[eventType];</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：时间&#123;0&#125;没有对应的委托&quot;</span>,eventType));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(d.GetType() != callBack.GetType())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：尝试为事件&#123;0&#125;移除不同类型的委托，当前委托类型为&#123;1&#125;，要移除的类型为&#123;2&#125;&quot;</span>,eventType,d.GetType(),callBack.GetType()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> Excption(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：没有事件码&#123;0&#125;&quot;</span>,eventType));</span><br><span class="line">&#125;</span><br><span class="line">m_EventType[eventType] = (CallBack&lt;T&gt;)m_EventType[eventType] - callBack;</span><br><span class="line"><span class="keyword">if</span>(m_EventType[eventType] == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">	m_EventTable.Remove(eventType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带有一个参数的广播监听的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,T arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Delegate d;</span><br><span class="line"><span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">&#123;</span><br><span class="line">	CallBack&lt;T&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T&gt;;</span><br><span class="line">	<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		callBack(arg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在ShowText中可以添加带有一个参数的委托来方便测试</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShowText</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">		&lt;!--EventCenter.AddListener(EventType.ShowText,Show);--&gt;</span><br><span class="line">		EventCenter.AddListener&lt;<span class="built_in">string</span>&gt;(EventType.ShowText,Show);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		EventCenter.RemoveListener&lt;<span class="built_in">string</span>&gt;(EventType.ShowText,Show);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;!--<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">	&#125;--&gt;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">		GetComponent&lt;Text&gt;().text = str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试脚本如下</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BtnClick</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		EventCenter.Broadcast(EventType.ShowText,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="精简重复的代码">精简重复的代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建字典的key为EventeType，value为Delegate(委托)</span></span><br><span class="line">	<span class="keyword">private</span> Dictionary&lt;EventType,Delegate&gt; m_EventTable = <span class="keyword">new</span> Dictionary&lt;EventType,Delegate&gt;();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerAdding</span>(<span class="params">EventType eventType,Delegate callBack</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!m_EventTable.ContainsKey(eventType))</span><br><span class="line">		&#123;</span><br><span class="line">			m_EventTable.Add(eventType,<span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Delegate d = m_EventTable[eventType];</span><br><span class="line">		<span class="keyword">if</span>(d != <span class="literal">null</span> &amp;&amp; d.GetType() != callBack.GetType())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;尝试为事件&#123;0&#125;添加不同类型的委托，当前事件所对应的委托是&#123;1&#125;，要添加的委托类型为&#123;2&#125;&quot;</span>，eventType,d.GetType(),callBack.GetType()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参添加监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>(<span class="params">EventType eventType,CallBack callBack</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		OnListenerAdding(eventType,callBack);</span><br><span class="line">		m_EventTable[eventType] = (CallBack)m_EventTable[eventType] + callBack;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带有一个参数添加监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerAdding(eventType,callBack);</span><br><span class="line">		m_EventTable[eventType] = (CallBack&lt;T&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerRemoving</span>(<span class="params">EventType eventType,Delegate callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		<span class="keyword">if</span>(m_EventType.ContainsKey(eventType))</span><br><span class="line">		&#123;</span><br><span class="line">			Delegate d = EventTable[eventType];</span><br><span class="line">			<span class="keyword">if</span>(d == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：时间&#123;0&#125;没有对应的委托&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(d.GetType() != callBack.GetType())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：尝试为事件&#123;0&#125;移除不同类型的委托，当前委托类型为&#123;1&#125;，要移除的类型为&#123;2&#125;&quot;</span>,eventType,d.GetType(),callBack.GetType()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Excption(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：没有事件码&#123;0&#125;&quot;</span>,eventType));</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerRemoved</span>(<span class="params">EventType evetType</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		<span class="keyword">if</span>(m_EventType[eventType] == <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			m_EventTable.Remove(eventType);</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参移除监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>(<span class="params">EventType eventType,CallBack callBack</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		OnListenerRemoving(eventType,callBack);</span><br><span class="line">		m_EventType[eventType] = (CallBack)m_EventType[eventType] - callBack;</span><br><span class="line">		OnListenerRemoved(eventType);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带有一个参数移除监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerRemoving(eventType,callBack);</span><br><span class="line">		m_EventType[eventType] = (CallBack&lt;T&gt;)m_EventType[eventType] - callBack;</span><br><span class="line">		OnListenerRemoved(eventType);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参广播监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>(<span class="params">EventType eventType</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack callBack = d <span class="keyword">as</span> CallBack;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带有一个参数的广播监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,T arg</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack&lt;T&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T&gt;;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack(arg);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现多个参数的监听和广播">实现多个参数的监听和广播</h2>
<blockquote>
<p>在CallBack文件中继续添加声名</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>&gt;(<span class="params">T arg</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>, <span class="title">X</span>&gt;(<span class="params">T arg1, X arg2</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>&gt;(<span class="params">T arg1, X arg2, Y arg3</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt;(<span class="params">T arg1, X arg2, Y arg3, Z arg4</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>, <span class="title">W</span>&gt;(<span class="params">T arg1, X arg2, Y arg3, Z arg4, W arg5</span>)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完整的EventCenter代码</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建字典的key为EventeType，value为Delegate(委托)</span></span><br><span class="line">	<span class="keyword">private</span> Dictionary&lt;EventType,Delegate&gt; m_EventTable = <span class="keyword">new</span> Dictionary&lt;EventType,Delegate&gt;();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerAdding</span>(<span class="params">EventType eventType,Delegate callBack</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!m_EventTable.ContainsKey(eventType))</span><br><span class="line">		&#123;</span><br><span class="line">			m_EventTable.Add(eventType,<span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Delegate d = m_EventTable[eventType];</span><br><span class="line">		<span class="keyword">if</span>(d != <span class="literal">null</span> &amp;&amp; d.GetType() != callBack.GetType())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;尝试为事件&#123;0&#125;添加不同类型的委托，当前事件所对应的委托是&#123;1&#125;，要添加的委托类型为&#123;2&#125;&quot;</span>，eventType,d.GetType(),callBack.GetType()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参添加监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>(<span class="params">EventType eventType,CallBack callBack</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		OnListenerAdding(eventType,callBack);</span><br><span class="line">		m_EventTable[eventType] = (CallBack)m_EventTable[eventType] + callBack;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带有一个参数添加监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerAdding(eventType,callBack);</span><br><span class="line">		m_EventTable[eventType] = (CallBack&lt;T&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有两个参数添加监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T, X&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerAdding(eventType,callBack);</span><br><span class="line">		m_EventTable[eventType] = (CallBack&lt;T, X&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有三个参数添加监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T, X, Y&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerAdding(eventType,callBack);</span><br><span class="line">		m_EventTable[eventType] = (CallBack&lt;T, X, Y&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有四个参数添加监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T, X, Y, Z&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerAdding(eventType,callBack);</span><br><span class="line">		m_EventTable[eventType] = (CallBack&lt;T, X, Y, Z&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有五个参数添加监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>, <span class="title">W</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T, X, Y, Z, W&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerAdding(eventType,callBack);</span><br><span class="line">		m_EventTable[eventType] = (CallBack&lt;T, X, Y, Z, W&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerRemoving</span>(<span class="params">EventType eventType,Delegate callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		<span class="keyword">if</span>(m_EventType.ContainsKey(eventType))</span><br><span class="line">		&#123;</span><br><span class="line">			Delegate d = EventTable[eventType];</span><br><span class="line">			<span class="keyword">if</span>(d == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：时间&#123;0&#125;没有对应的委托&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(d.GetType() != callBack.GetType())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：尝试为事件&#123;0&#125;移除不同类型的委托，当前委托类型为&#123;1&#125;，要移除的类型为&#123;2&#125;&quot;</span>,eventType,d.GetType(),callBack.GetType()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Excption(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误：没有事件码&#123;0&#125;&quot;</span>,eventType));</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerRemoved</span>(<span class="params">EventType evetType</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		<span class="keyword">if</span>(m_EventType[eventType] == <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			m_EventTable.Remove(eventType);</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参移除监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>(<span class="params">EventType eventType,CallBack callBack</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		OnListenerRemoving(eventType,callBack);</span><br><span class="line">		m_EventType[eventType] = (CallBack)m_EventType[eventType] - callBack;</span><br><span class="line">		OnListenerRemoved(eventType);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带有一个参数移除监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerRemoving(eventType,callBack);</span><br><span class="line">		m_EventType[eventType] = (CallBack&lt;T&gt;)m_EventType[eventType] - callBack;</span><br><span class="line">		OnListenerRemoved(eventType);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有两个参数移除监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T, X&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerRemoving(eventType,callBack);</span><br><span class="line">		m_EventType[eventType] = (CallBack&lt;T, X&gt;)m_EventType[eventType] - callBack;</span><br><span class="line">		OnListenerRemoved(eventType);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有三个参数移除监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T, X, Y&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerRemoving(eventType,callBack);</span><br><span class="line">		m_EventType[eventType] = (CallBack&lt;T, X, Y&gt;)m_EventType[eventType] - callBack;</span><br><span class="line">		OnListenerRemoved(eventType);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有四个参数移除监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T, X, Y, Z&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerRemoving(eventType,callBack);</span><br><span class="line">		m_EventType[eventType] = (CallBack&lt;T, X, Y, Z&gt;)m_EventType[eventType] - callBack;</span><br><span class="line">		OnListenerRemoved(eventType);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有五个参数移除监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>, <span class="title">W</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T, X, Y, Z, W&gt; callBack</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		OnListenerRemoving(eventType,callBack);</span><br><span class="line">		m_EventType[eventType] = (CallBack&lt;T, X, Y, Z, W&gt;)m_EventType[eventType] - callBack;</span><br><span class="line">		OnListenerRemoved(eventType);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参广播监听的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>(<span class="params">EventType eventType</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack callBack = d <span class="keyword">as</span> CallBack;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带有一个参数的广播监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,T arg</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack&lt;T&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T&gt;;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack(arg);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有两个参数的广播监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>, <span class="title">X</span>&gt;(<span class="params">EventType eventType, T arg1, X arg2</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack&lt;T, X&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T, X&gt;;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack(arg1, arg2);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有三个参数的广播监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>&gt;(<span class="params">EventType eventType, T arg1, X arg2, Y arg3</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack&lt;T, X, Y&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T, X, Y&gt;;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack(arg1, arg2, arg3);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有四个参数的广播监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt;(<span class="params">EventType eventType, T arg1, X arg2, Y arg3, Z arg4</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack&lt;T, X, Y, Z&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T, X, Y, Z&gt;;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack(arg1, arg2, arg3, arg4);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//带有五个参数的广播监听的方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>, <span class="title">W</span>&gt;(<span class="params">EventType eventType, T arg1, X arg2, Y arg3, Z arg4, W arg5</span>)</span></span><br><span class="line">	 &#123;</span><br><span class="line">		Delegate d;</span><br><span class="line">		<span class="keyword">if</span>(m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))</span><br><span class="line">		&#123;</span><br><span class="line">			CallBack&lt;T, X, Y, Z, W&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T, X, Y, Z, W&gt;;</span><br><span class="line">			<span class="keyword">if</span>(callBack != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				callBack(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>,eventType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于该系统的利弊">关于该系统的利弊</h2>
<blockquote>
<p>解决了代码之间的高度耦合性<br>
参数的顺序和指定的泛型顺序必须一致<br>
必须知道事件码</p>
</blockquote>
]]></content>
      <categories>
        <category>Unity进修</category>
      </categories>
      <tags>
        <tag>Unity解耦合</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0109——有序链表转换二叉搜索树</title>
    <url>/2024/01/17/%E5%8A%9B%E6%89%A30109%E2%80%94%E2%80%94%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">有序链表转换二叉搜索树</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</p>
<h2 id="示例1：">示例1：</h2>
<p><img src="/images/ltc0109_1.jpg" alt="images"></p>
<p><strong>输入:</strong> head = [-10,-3,0,5,9]<br>
<strong>输出:</strong> [0,-3,9,-10,null,5]<br>
<strong>解释:</strong> 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。</p>
<h2 id="示例2">示例2:</h2>
<p><strong>输入:</strong> head = []<br>
<strong>输出:</strong> []</p>
<h2 id="题解：">题解：</h2>
<p>和 <code>0108</code>一样的思路，将链表中的元素转存到数组中，之后按照 <code>0108</code> 的思路解题即可</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode next = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val; </span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span> .val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode list = <span class="keyword">new</span> ListNode</span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">-10</span>,</span><br><span class="line">            next = <span class="keyword">new</span> ListNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">-3</span>,</span><br><span class="line">                next = <span class="keyword">new</span> ListNode</span><br><span class="line">                &#123;</span><br><span class="line">                    val = <span class="number">0</span>,</span><br><span class="line">                    next = <span class="keyword">new</span> ListNode</span><br><span class="line">                    &#123;</span><br><span class="line">                        val = <span class="number">5</span>,</span><br><span class="line">                        next = <span class="keyword">new</span> ListNode</span><br><span class="line">                        &#123;</span><br><span class="line">                            val = <span class="number">9</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        TreeNode ans = solution.SortedListToBST(list);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">SortedListToBST</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Queue&lt;<span class="built_in">int</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.Enqueue(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span>[] temp = <span class="keyword">new</span> <span class="built_in">int</span>[queue.Count];</span><br><span class="line">        <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index] = queue.Dequeue();</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BackTrack(temp, <span class="number">0</span>, temp.Length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">BackTrack</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> start, <span class="built_in">int</span> end</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[mid], BackTrack(nums, start, mid - <span class="number">1</span>), BackTrack(nums, mid + <span class="number">1</span>, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0110——平衡二叉树</title>
    <url>/2024/01/27/%E5%8A%9B%E6%89%A30110%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">平衡二叉树</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0110_1.jpg" alt="image"></p>
<p><strong>输入：</strong> root = [3,9,20,null,null,15,7]<br>
<strong>输出：</strong> true</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0110_2.jpg" alt="image"></p>
<p><strong>输入：</strong> root = [1,2,2,3,3,null,null,4,4]<br>
<strong>输出：</strong> false</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> root = []<br>
<strong>输出：</strong> true</p>
<h2 id="题解">题解</h2>
<p>利用递归的思想对整棵树进行遍历，如果左子树深度减右子树深度大于<code>1</code>，那么将返回值设定为<code>-1</code>，如果不是，则将返回值的定为<code>1 + 左右子树深度的最大值</code>，最终判定最后的返回值是否为<code>-1</code>，如果是<code>-1</code>,那么就不是二叉搜索树，反之则是二叉搜索树</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root= <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            val= <span class="number">3</span>,</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val= <span class="number">20</span>,</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">15</span>),</span><br><span class="line">                right= <span class="keyword">new</span> TreeNode(<span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">bool</span> ans = solution.IsBalanced(root);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsBalanced</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(BackTrack(root) == <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> leftH = BackTrack(root.left);</span><br><span class="line">        <span class="keyword">if</span> (leftH == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> rightH = BackTrack(root.right);</span><br><span class="line">        <span class="keyword">if</span> (rightH == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.Abs(leftH - rightH) &gt; <span class="number">1</span> ? <span class="number">-1</span> : (<span class="number">1</span> + Math.Max(leftH, rightH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0111——二叉树的最小深度</title>
    <url>/2024/01/28/%E5%8A%9B%E6%89%A30111%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">二叉树的最小深度</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong> 叶子节点是指没有子节点的节点。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0111_1.jpg" alt="iamge"><br>
<strong>输入：</strong> root = [3,9,20,null,null,15,7]<br>
<strong>输出：</strong> 2</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> root = [2,null,3,null,4,null,5,null,6]<br>
<strong>输出：</strong> 5</p>
<h2 id="题解">题解</h2>
<p>使用回溯法，遍历每一个节点，当一个节点没有左子树和右子树之后结束本次遍历，将结果存储并在之后进行对比，如果和上一次的回溯结果相比本次更小则将结果替换，直到遍历完所有节点</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">2</span>,</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">3</span>,</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode</span><br><span class="line">                &#123;</span><br><span class="line">                    val = <span class="number">4</span>,</span><br><span class="line">                    right = <span class="keyword">new</span> TreeNode</span><br><span class="line">                    &#123;</span><br><span class="line">                        val = <span class="number">5</span>,</span><br><span class="line">                        right = <span class="keyword">new</span> TreeNode</span><br><span class="line">                        &#123;</span><br><span class="line">                            val = <span class="number">6</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> ans = solution.MinDepth(root);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinDepth</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = Math.Min(ans, MinDepth(root.left));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = Math.Min(ans, MinDepth(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0112——路径总和</title>
    <url>/2024/01/28/%E5%8A%9B%E6%89%A30112%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/path-sum/description/">路径总和</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0112_1.jpg" alt="iamge"><br>
<strong>输入：</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>
<strong>输出：</strong> true</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0112_2.jpg" alt="iamge"><br>
<strong>输入：</strong> root = [1,2,3], targetSum = 5<br>
<strong>输出：</strong> false</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> root = [], targetSum = 0<br>
<strong>输出：</strong> false</p>
<h2 id="题解">题解</h2>
<p>使用回溯法，因为最终的结果是节点值之和，所以可以使用累减方法进行回溯，当相等的时候可以直接返回<code>true</code></p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">5</span>,</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">4</span>,</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode</span><br><span class="line">                &#123;</span><br><span class="line">                    val = <span class="number">11</span>,</span><br><span class="line">                    left = <span class="keyword">new</span> TreeNode</span><br><span class="line">                    &#123;</span><br><span class="line">                        val = <span class="number">7</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    right = <span class="keyword">new</span> TreeNode</span><br><span class="line">                    &#123;</span><br><span class="line">                        val = <span class="number">2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">8</span>,</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">13</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode</span><br><span class="line">                &#123;</span><br><span class="line">                    val = <span class="number">4</span>,</span><br><span class="line">                    right = <span class="keyword">new</span> TreeNode(<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">bool</span> ans = solution.HasPathSum(root, <span class="number">22</span>);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HasPathSum</span>(<span class="params">TreeNode root, <span class="built_in">int</span> targetSum</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HasPathSum(root.left,targetSum - root.val) || HasPathSum(root.right,targetSum - root.val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0113——路径总和II</title>
    <url>/2024/01/29/%E5%8A%9B%E6%89%A30113%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/path-sum-ii/description/">路径总和II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0113_1.jpg" alt="image"><br>
<strong>输入：</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>
<strong>输出：</strong>[[5,4,11,2],[5,8,4,5]]</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc0112_2.jpg" alt="image"><br>
<strong>输入：</strong> root = [1,2,3], targetSum = 5<br>
<strong>输出：</strong>[]</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> root = [1,2], targetSum = 0<br>
<strong>输出：</strong>[]</p>
<h2 id="题解">题解</h2>
<p>和 0112 题的思路一致，都是对<code>targetSum</code>进行减法回溯，不同的是需要记录当前节点的值</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Metadata.W3cXsd2001;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">5</span>,</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">4</span>,</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode</span><br><span class="line">                &#123;</span><br><span class="line">                    val = <span class="number">11</span>,</span><br><span class="line">                    left = <span class="keyword">new</span> TreeNode(<span class="number">7</span>),</span><br><span class="line">                    right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">8</span>,</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">13</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode</span><br><span class="line">                &#123;</span><br><span class="line">                    val = <span class="number">4</span>,</span><br><span class="line">                    left = <span class="keyword">new</span> TreeNode(<span class="number">5</span>),</span><br><span class="line">                    right = <span class="keyword">new</span> TreeNode(<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; currans = solution.PathSum(root, <span class="number">22</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> currans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">    IList&lt;<span class="built_in">int</span>&gt; temp = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; PathSum(TreeNode root, <span class="built_in">int</span> targetSum)</span><br><span class="line">    &#123;</span><br><span class="line">        BackTrack(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root, <span class="built_in">int</span> targetSum</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.Add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val == targetSum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BackTrack(root.left, targetSum - root.val);</span><br><span class="line">        BackTrack(root.right, targetSum - root.val);</span><br><span class="line">        temp.RemoveAt(temp.Count - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0114——二叉树展开为链表</title>
    <url>/2024/01/29/%E5%8A%9B%E6%89%A30114%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1>[二叉树展开为链表]</h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0114_1.jpg" alt="image"><br>
<strong>输入：</strong> root = [1,2,5,3,4,null,6]<br>
<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> root = []<br>
<strong>输出：</strong>[]</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> root = [0]<br>
<strong>输出：</strong>[0]</p>
<h2 id="题解">题解</h2>
<p>因为和先序遍历相同，所以可以想到利用先序遍历将所有的结点存储到列表中，之后便可以依次添加右子结点</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">1</span>,</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">2</span>,</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">5</span>,</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode(<span class="number">6</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        solution.Flatten(root);</span><br><span class="line">        solution.OnlyReadRightTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;TreeNode&gt; treeList = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Flatten</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Travel(root);</span><br><span class="line">        <span class="built_in">int</span> size = treeList.Count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode tree = treeList[i];</span><br><span class="line">            tree.left = <span class="literal">null</span>;</span><br><span class="line">            tree.right = i == size - <span class="number">1</span> ? <span class="literal">null</span> : treeList[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Travel</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        treeList.Add(root);</span><br><span class="line">        Travel(root.left);</span><br><span class="line">        Travel(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnlyReadRightTree</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OnlyReadRightTree(root.right);</span><br><span class="line">        Console.Write(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0115——不同的子序列</title>
    <url>/2024/01/30/%E5%8A%9B%E6%89%A30115%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/distinct-subsequences/description/">不同的子序列</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> + 7 取模。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> s = “rabbbit”, t = “rabbit”<br>
<strong>输出：</strong><code>3</code></p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> s = “babgbag”, t = “bag”<br>
<strong>输出</strong>：<code>5</code></p>
<h2 id="题解">题解</h2>
<p>根据题目可知，此题需要用到动态规划，动态规划方程为：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>c1[i - 1] == c2[j - 1]</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>c1[i - 1] != c2[j - 1]</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j] = \begin{cases} dp[i - 1][j - 1] + dp[i - 1][j],&amp;\text{c1[i - 1] == c2[j - 1]} \\ dp[i - 1][j],&amp;\text{c1[i - 1] != c2[j - 1]} \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">c1[i - 1] == c2[j - 1]</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">c1[i - 1] != c2[j - 1]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
其中，c1为s中的字符，c2为t中的字符</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;babgbag&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">&quot;bag&quot;</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> ans = solution.NumDistinct(s, t);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">NumDistinct</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = s.Length;</span><br><span class="line">        <span class="built_in">int</span> n = t.Length;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[,]dp = <span class="keyword">new</span> <span class="built_in">int</span>[m + <span class="number">1</span>, n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i, <span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">char</span> c1 = s[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">char</span> c2 = t[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i, j] = dp[i - <span class="number">1</span>, j - <span class="number">1</span>] + dp[i - <span class="number">1</span>, j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i, j] = dp[i - <span class="number">1</span>, j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m, n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0116——填充每一个节点的下一个右侧指针</title>
    <url>/2024/01/31/%E5%8A%9B%E6%89%A30116%E2%80%94%E2%80%94%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">填充每一个节点的下一个右侧指针</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}</p>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0116_1.png" alt="image"><br>
<strong>输入：</strong> root = [1,2,3,4,5,6,7]<br>
<strong>输出：</strong>[1,#,2,3,#,4,5,6,7,#]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> root = []<br>
<strong>输出：</strong>[]</p>
<h2 id="题解">题解</h2>
<p>直接使用双层列表，在其中赋值即可</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="built_in">int</span> _val</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="built_in">int</span> val, Node left, Node right, Node next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node</span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">1</span>,</span><br><span class="line">            left = <span class="keyword">new</span> Node</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">2</span>,</span><br><span class="line">                left = <span class="keyword">new</span> Node(<span class="number">4</span>),</span><br><span class="line">                right = <span class="keyword">new</span> Node(<span class="number">5</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            right = <span class="keyword">new</span> Node</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">3</span>,</span><br><span class="line">                left = <span class="keyword">new</span> Node(<span class="number">6</span>),</span><br><span class="line">                right = <span class="keyword">new</span> Node(<span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Node ans = solution.Connect(root);</span><br><span class="line">        Console.WriteLine(ans.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Connect</span>(<span class="params">Node root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;Node&gt;&gt; list = <span class="keyword">new</span> List&lt;List&lt;Node&gt;&gt;();</span><br><span class="line">        Travel(root, list, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; list[i].Count - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                list[i][j].next = list[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            list[i][list[i].Count - <span class="number">1</span>].next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Travel</span>(<span class="params">Node root, List&lt;List&lt;Node&gt;&gt; list, <span class="built_in">int</span> h</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list.Count &lt;= h)</span><br><span class="line">        &#123;</span><br><span class="line">            list.Add(<span class="keyword">new</span> List&lt;Node&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        list[h].Add(root);</span><br><span class="line">        Travel(root.left, list, h + <span class="number">1</span>);</span><br><span class="line">        Travel(root.right, list, h + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0117——填充每一个节点的下一个右侧指针II</title>
    <url>/2024/02/01/%E5%8A%9B%E6%89%A30117%E2%80%94%E2%80%94%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">填充每一个节点的下一个右侧指针II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个二叉树：</p>
<p>struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}</p>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0117_1.png" alt="image"><br>
<strong>输入</strong>：root = [1,2,3,4,5,null,7]<br>
<strong>输出：</strong>[1,#,2,3,#,4,5,7,#]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> root = []<br>
<strong>输出：</strong>[]</p>
<h2 id="题解">题解</h2>
<p>可以根据队列解题，将根节点入队，当队内元素不为<code>0</code>的时候开始循环，定义一个新的空节点，并进行嵌套循环，将节点出队并用temp保存起来，如果该节点的左（右）子树不为空，就将它的左（右）子树入队，如果 <code>i != 1</code>元素则将出队的节点赋值给空节点的下一个节点，并将空节点移动到下一个</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="built_in">int</span> _val</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="built_in">int</span> val, Node left, Node right, Node next</span>) : <span class="title">this</span>(<span class="params">val</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node</span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">1</span>,</span><br><span class="line">            left = <span class="keyword">new</span> Node</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">2</span>,</span><br><span class="line">                left = <span class="keyword">new</span> Node(<span class="number">4</span>),</span><br><span class="line">                right = <span class="keyword">new</span> Node(<span class="number">5</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            right = <span class="keyword">new</span> Node</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">3</span>,</span><br><span class="line">                right = <span class="keyword">new</span> Node(<span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Connect</span>(<span class="params">Node root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> Queue&lt;Node&gt;();</span><br><span class="line">        queue.Enqueue(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> n = queue.Count;</span><br><span class="line">            Node last = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Node f = queue.Dequeue();</span><br><span class="line">                <span class="keyword">if</span> (f.left != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.Enqueue(f.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f.right != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.Enqueue(f.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    last.next = f;</span><br><span class="line">                &#125;</span><br><span class="line">                last = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0118——杨辉三角</title>
    <url>/2024/02/02/%E5%8A%9B%E6%89%A30118%E2%80%94%E2%80%94%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/pascals-triangle/description/">杨辉三角</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个非负整数 _<code>numRows</code>，_生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0118_1.gif" alt="image"><br>
<strong>输入:</strong> numRows = 5<br>
<strong>输出:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入:</strong> numRows = 1<br>
<strong>输出:</strong> [[1]]</p>
<h2 id="题解">题解</h2>
<p>直接使用动态规划，操作列表即可，当内层循环为最开始和结尾时，将表内元素置为1，其余的条件即为上一行的对应位置和对应位置的前一个位置的和</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> numRows = <span class="number">3</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = solution.Generate(numRows);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> a)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; Generate(<span class="built_in">int</span> numRows)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; ans = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            IList&lt;<span class="built_in">int</span>&gt; t = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    t.Add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t.Add(ans[i - <span class="number">1</span>][j - <span class="number">1</span>] + ans[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.Add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans.RemoveAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0119——杨辉三角II</title>
    <url>/2024/02/02/%E5%8A%9B%E6%89%A30119%E2%80%94%E2%80%94%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">杨辉三角II</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc0118_1.gif" alt="image"><br>
<strong>输入:</strong> rowIndex = 3<br>
<strong>输出:</strong> [1,3,3,1]</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入:</strong> rowIndex = 0<br>
<strong>输出:</strong> [1]</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入:</strong> rowIndex = 1<br>
<strong>输出:</strong> [1,1]</p>
<h2 id="题解">题解</h2>
<p>可以利用两个列表，一个列表用于获取新行，一个列表用于存储，基本的解题思路和 <code>0118</code>的思路相同</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span> rowIndex = <span class="number">3</span>;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; ans = solution.GetRow(rowIndex);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> ans)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">GetRow</span>(<span class="params"><span class="built_in">int</span> rowIndex</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; ans = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= rowIndex + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            IList&lt;<span class="built_in">int</span>&gt; t = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    t.Add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t.Add(ans[j - <span class="number">1</span>] + ans[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0120——三角形最小路径和</title>
    <url>/2024/02/03/%E5%8A%9B%E6%89%A30120%E2%80%94%E2%80%94%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/triangle/description/">三角形最小路径和</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>
<strong>输出：</strong> 11</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> triangle = [[-10]]<br>
<strong>输出：</strong>-10</p>
<h2 id="题解">题解</h2>
<p>是用动态规划</p>
<ul>
<li>当遍历当前行的第一个元素时，该元素位置的最短路径和只能为正上方的最短路径和加当前元素的值；</li>
<li>遍历当前行的最后一个元素时，它的最短路径和只能为上方的前一个元素的最短路径和加当前元素的值</li>
<li>其余情况下为正上方和左上方的最短路径和的最小值加上当前元素值</li>
</ul>
<p>动态规划方程为：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>j</mtext><mo>=</mo><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>j</mtext><mo>=</mo><mo>=</mo><mi>i</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>1</mtext><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j] = \begin{cases} dp[i - 1][j] + triangle[i][j], &amp;\text j == 0 \\ dp[i - 1][j - 1] + triangle[i][j], &amp;\text j == i\\ min(dp[i - 1][j - 1],dp[i - 1][j]) + triangle[i][j],&amp;\text 1 \leq j &lt; i \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">j</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">j</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">1</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; triangles = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">2</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">int</span> ans = solution.MinimumTotal(triangles);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MinimumTotal</span>(<span class="params">IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; triangle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] dp = <span class="keyword">new</span> <span class="built_in">int</span>[triangle.Count][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; triangle.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="built_in">int</span>[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; dp.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            IList&lt;<span class="built_in">int</span>&gt; t = triangle[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; dp[i].Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + t[j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + t[j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = Math.Min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + t[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Array.Sort(dp[dp.Length - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[dp.Length <span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0121——买卖股票的最佳时机</title>
    <url>/2024/02/03/%E5%8A%9B%E6%89%A30121%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">买卖股票的最佳时机</a></h1>
<p>难度：<strong>简单</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong>[7,1,5,3,6,4]<br>
<strong>输出：</strong> 5</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> prices = [7,6,4,3,1]<br>
<strong>输出：</strong> 0</p>
<h2 id="题解">题解</h2>
<p>因为直接双层嵌套循环，时间复杂度为O(n!)，时间复杂度不达标，所以需要降低复杂度，可以运用一次遍历，求出当前位置获得利润的最大值</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] prices = &#123; <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> ans = solution.MaxProfit(prices);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxProfit</span>(<span class="params"><span class="built_in">int</span>[] prices</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> pre = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; prices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = Math.Max(ans, prices[i] - pre);</span><br><span class="line">            pre = Math.Min(pre, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0122——买卖股票的最佳时机II</title>
    <url>/2024/02/03/%E5%8A%9B%E6%89%A30122%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机II</a></h1>
<p>难度：<strong>中等</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> prices = [7,1,5,3,6,4]<br>
<strong>输出：</strong> 7</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> prices = [1,2,3,4,5]<br>
<strong>输出：</strong> 4</p>
<h2 id="题解">题解</h2>
<p>因为不是只能购买一次，所以只要是后一天的利润大于前一天都可以直接卖出</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] prices = &#123; <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> ans = solution.MaxProfit(prices);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxProfit</span>(<span class="params"><span class="built_in">int</span>[] prices</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> pre = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; prices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += Math.Max(prices[i] - pre, <span class="number">0</span>);</span><br><span class="line">            pre = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——01什么是InterNet</title>
    <url>/2024/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9401%E4%BB%80%E4%B9%88%E6%98%AFInterNet/</url>
    <content><![CDATA[<h1>什么是InterNet</h1>
<h2 id="1-1-什么是网络">1.1 什么是网络</h2>
<p>由节点和边组成的与形状大小无关的拓扑</p>
<h2 id="1-2-什么是internet">1.2 什么是Internet</h2>
<ul>
<li>从具体构成角度来说：
<ul>
<li>节点：
<ul>
<li>主机及其上运行的应用程序</li>
<li>路由器、交换机等网络交换设备</li>
</ul>
</li>
<li>边：通信链路
<ul>
<li>接入网链路：主机连接到互联网的链路</li>
<li>主干链路：路由器间的链路</li>
</ul>
</li>
<li>数以亿计的、互联的计算设备
<ul>
<li><font color=red><strong>主机 = 端系统</strong></font></li>
<li>运行<font color=red><strong>网络应用程序</strong></font></li>
</ul>
</li>
<li>通信链路
<ul>
<li>光纤、网络电缆、无线电、卫星</li>
<li>传输速率 = <font color=red><strong>带宽（bps）</strong></font></li>
</ul>
</li>
<li><font color=red><strong>分组交换设备</strong></font>：转发分组（<strong>packets</strong>）
<ul>
<li>路由器和交换机</li>
</ul>
</li>
<li><font color=red>协议</font>控制发送、接收消息
<ul>
<li>比如<strong>TCP、IP、HTTP、FTP、PPP</strong></li>
</ul>
</li>
<li><font color=red><strong>Internet:</strong>“网络的网络”</font>
<ul>
<li>松散的层次结构、互联的<strong>ISP</strong></li>
<li>公共<strong>Internet vs</strong>、专用<strong>intranet</strong></li>
</ul>
</li>
<li><strong>Internet</strong>标准
<ul>
<li><strong>RFC:Request for comments</strong></li>
<li><strong>IETF:Internet Engineering Task Force</strong></li>
</ul>
</li>
<li>协议
<ul>
<li>协议定义了在两个或多个通信实体之间的<font color=red>报文格式</font>和<font color=red>次序</font>，以及在报文传输和接收其他事件方面所采取的<font color=red>动作</font></li>
</ul>
</li>
</ul>
</li>
<li>从服务角度来说：
<ul>
<li><font color=red>使用通信设施进行通信的<strong>分布式应用</strong></font>
<ul>
<li>比如<strong>Web、VoIP、Email</strong>、分布式游戏、电子商务、社交网络等</li>
</ul>
</li>
<li><font color=red><strong>通信基础设施为apps提供编程接口（通信服务）</strong></font>
<ul>
<li>将发送和接收数据的<strong>apps</strong>与互连网连接起来</li>
<li>为<strong>app</strong>应用提供服务选择、类似于邮政服务：
<ul>
<li>无连接不可靠服务</li>
<li>面向连接的可靠服务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0123——买卖股票的最佳时机III</title>
    <url>/2024/02/04/%E5%8A%9B%E6%89%A30123%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">买卖股票的最佳时机III</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入：</strong> prices = [3,3,5,0,0,3,1,4]<br>
<strong>输出：</strong> 6</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> prices = [1,2,3,4,5]<br>
<strong>输出：</strong> 4</p>
<h2 id="题解">题解</h2>
<p>使用动态规划，运用二维数组，设置四列，[i][0]表示买入一次，[i][1]表示卖出一次，[i][2]表示买入两次，[i][3]表示卖出两次</p>
<ul>
<li>当买入一次，说明在这次或者之前买入；</li>
<li>当卖出一次，说明在这次或之前买入一次；</li>
<li>当买入两次，说明已经买入并卖出了一次；</li>
<li>当卖出两次，说明已经买入两次并卖出了一次；</li>
</ul>
<p>所以，动态规划方程为：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j] = \begin{cases} max(dp[i - 1][0],-prices[i]) \\ max(dp[i - 1][1],dp[i - 1][0] + prices[i]) \\ max(dp[i - 1][2],dp[i - 1][1] - prices[i]) \\ max(dp[i - 1][3],dp[i - 1][2] + prices[i]) \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000008em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.5949900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8899900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1849900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.905010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">int</span>[] prices = &#123; <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> ans = solution.MaxProfit(prices);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxProfit</span>(<span class="params"><span class="built_in">int</span>[] prices</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = prices.Length;</span><br><span class="line">        <span class="built_in">int</span>[][] dp = <span class="keyword">new</span> <span class="built_in">int</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">int</span>.MinValue / <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="built_in">int</span>.MinValue / <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="built_in">int</span>.MinValue / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.Max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.Max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.Max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.Max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.Max(<span class="number">0</span>,Math.Max(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——02网络边缘</title>
    <url>/2024/02/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9402%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98/</url>
    <content><![CDATA[<h1>网络边缘</h1>
<h2 id="网络结构">网络结构</h2>
<ul>
<li>网络边缘：
<ul>
<li>主机</li>
<li>应用程序（客户端和服务器）</li>
</ul>
</li>
<li>网络核心
<ul>
<li>互联着的路由器</li>
<li>网络的网络</li>
</ul>
</li>
<li>接入网、物理媒体
<ul>
<li>有线或无线通信链路</li>
</ul>
</li>
</ul>
<h2 id="网络边缘">网络边缘</h2>
<ul>
<li><font color=red>端系统（主机）</font>
<ul>
<li>运行应用程序</li>
</ul>
</li>
<li><font color=red>客户/服务器模式（C/S模式）</font>
<ul>
<li>客户端想服务器请求、接收服务</li>
</ul>
</li>
<li><font color=red>对等（<strong>peer-peer</strong>）模式</font>
<ul>
<li>很少（甚至没有）专门的服务器</li>
</ul>
</li>
</ul>
<h2 id="网络边缘：采用网络设施的面向服务链接">网络边缘：采用网络设施的面向服务链接</h2>
<ul>
<li><font color=red><strong>目标</strong></font>：在端系统之间传输数据
<ul>
<li>握手：在数据传输之前做好准备
<ul>
<li>两个通信主机之间<font color=red>连接建立状态</font></li>
</ul>
</li>
<li><strong>TCP</strong> - 传输控制协议
<ul>
<li><strong>Internet</strong>上面向连接的服务（只有端系统知道）</li>
</ul>
</li>
</ul>
</li>
<li><font color=red><strong>TCP服务</strong></font>
<ul>
<li>可靠的、按顺序的传输数据
<ul>
<li>确认和重传</li>
</ul>
</li>
<li>流量控制
<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
<li>拥塞控制
<ul>
<li>当网络拥塞时，发送方降低发送速率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络边缘：采用基础设施的无连接服务">网络边缘：采用基础设施的无连接服务</h2>
<ul>
<li><font color=red><strong>目标</strong></font>：在端系统之间传输数据
<ul>
<li>无连接服务</li>
</ul>
</li>
<li><font color=red><strong>UDP</strong></font>-用户数据报协议
<ul>
<li>无连接</li>
<li>不可靠传输</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
</ul>
</li>
<li><font color=red>使用<strong>TCP</strong>的应用</font>
<ul>
<li>HTTP（Web）、FTP（文件传送）、Telent（远程登陆）、SMTP（email）</li>
</ul>
</li>
<li><font color=red>使用<strong>UDP</strong>的应用</font>
<ul>
<li>流媒体、远程会议、DNS、Internet电话</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——03网络核心</title>
    <url>/2024/02/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9403%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<h1>网络核心</h1>
<h2 id="网络核心">网络核心</h2>
<ul>
<li>网络核心：路由器的网络状态</li>
<li><font color=red>基本问题</font>：数据怎样通过网络进行传输
<ul>
<li><font color=red>电路交换</font>：为每个呼叫预留一条专有电路</li>
<li><font color=red>分组交换</font>
<ul>
<li>将要传送的数据分成一个个单位：分组</li>
<li>将分组从一个路由器传到相邻路由器（<strong>hop</strong>），一段段最终从源端传到目标端</li>
<li>每段：采用链路的最大传输能力（带宽）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络核心：电路交换">网络核心：电路交换</h2>
<p><font color=red>端到端的资源被分配给从源端到目标端的呼叫“call”</font></p>
<ul>
<li>图中，每段链路有4条线路：<br>
<img src="/images/wl_02_1.png" alt="示例">
<ul>
<li>该呼叫采用了上面链路的第二个线路，右边链路的第一个链路（piece）</li>
</ul>
</li>
<li>独享资源：不同享
<ul>
<li>每个呼叫一旦建立起来就能够保证性能</li>
</ul>
</li>
<li>如果呼叫没有数据发送，被分配的资源就会被浪费（<em>no sharing</em>)</li>
<li>通常被传统电话网络采用</li>
</ul>
<p><font color=red>为呼叫预留端-端资源</font></p>
<ul>
<li>链路带宽、交换能力</li>
<li>专用资源：不共享</li>
<li>保证性能</li>
<li>要求简历呼叫连接</li>
</ul>
<p>网络资源（如带宽）被分成<font color=red>片</font></p>
<ul>
<li>为呼叫分配片</li>
<li>如果某个呼叫没有数据，则其资源片处于<font color=red>空闲状态</font>（不共享）</li>
<li>将带宽分成片
<ul>
<li>频分（FDM）</li>
<li>时分（TDM）</li>
<li>波分（WDM）</li>
</ul>
</li>
</ul>
<p>电路交换不适合计算机之间的通信</p>
<ul>
<li>建立连接时间长</li>
<li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片段多
<ul>
<li>即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li>
</ul>
</li>
<li>可靠性不高？</li>
</ul>
<h2 id="网络核心：分组交换">网络核心：分组交换</h2>
<p><font color=red>以分组为单位存储-转发方式</font></p>
<ul>
<li>网络带宽资源不再被分为一个个片，传输时使用全部带宽</li>
<li>主机之间传输的数据被分为一个个分组</li>
</ul>
<p><font color=red>资源共享，按需使用</font></p>
<ul>
<li>存储、转发：分组每次移动一跳（hop）
<ul>
<li>在转发之前，节点必须收到整个分组</li>
<li>延迟比线路交换要大</li>
<li>排队时间</li>
</ul>
</li>
</ul>
<h2 id="分组交换：存储-转发">分组交换：存储-转发</h2>
<ul>
<li>被运输到下一个链路之前，整个分组必须到达路由器：<font color=red>存储-转发</font></li>
<li>在一个速率为<strong>R bps</strong>的链路，一个长度为<strong>L bps</strong>的分组存储转发延时：<strong>L/R s</strong></li>
</ul>
<h2 id="分组交换：排队延迟和丢失">分组交换：排队延迟和丢失</h2>
<ul>
<li>如果到达速率 &gt; 链路的输出速率
<ul>
<li>分组将会排队，等待传输</li>
<li>如果路由器的缓存用完了，分组将会被抛弃</li>
</ul>
</li>
</ul>
<h2 id="网络核心的关键功能">网络核心的关键功能</h2>
<ul>
<li><font color=red><em>路由</em></font>：决定分组采用的源到目标的路径</li>
<li><font color=red><em>转发</em></font>：将分组从路由器的输入链路转移到输出链路</li>
</ul>
<h2 id="分组交换：统计多路复用">分组交换：统计多路复用</h2>
<p><img src="/images/wl_02_2.png" alt="示例"><br>
<strong>A &amp; B</strong>时分复用链路资源<br>
<strong>A &amp; B</strong>分组没有固定的模式 → <font color=red>统计多路复用</font></p>
<h2 id="分组交换-vs-电路交换">分组交换 vs. 电路交换</h2>
<p><font color=red>分组交换允许更多用户使用网络</font><br>
<font color=red>分组交换是“突发数据的胜利者”</font></p>
<ul>
<li>适用于对突发式数据传输
<ul>
<li>资源共享</li>
<li>简单，不必建立呼叫</li>
</ul>
</li>
<li><font color=red>过度使用会造成网络拥塞</font>，分组延时和丢失
<ul>
<li>对可靠的数据传输需要协议来约束：拥塞控制</li>
</ul>
</li>
</ul>
<h2 id="分组交换网络：存储-转发">分组交换网络：存储-转发</h2>
<p><font color=red>分组交换</font>：分组的存储转发一段一段从源端到目标端，按照有无网络层的连接，分成：</p>
<ul>
<li><font color=red>数据报网络</font>
<ul>
<li>分组的目标地址表示下一跳</li>
<li>在不同的阶段，路由可以改变</li>
<li>类似于问路</li>
<li><strong>Internet</strong></li>
</ul>
</li>
<li><font color=red>虚电路网络</font>
<ul>
<li>每个分组都带有标签，虚电路标识<strong>VC ID</strong>，标签决定下一跳</li>
<li>在<font color=red>呼叫建立时</font>决定路径，在整个呼叫中路径保持不变</li>
<li><font color=red>路由器维持每个呼叫的状态信息</font></li>
<li><strong>X.25</strong> 和 <strong>ATM</strong></li>
</ul>
</li>
</ul>
<h2 id="数据报的工作原理">数据报的工作原理</h2>
<ul>
<li>在通信之前，无须建立起一个连接，有数据就传输</li>
<li>每一个分组都独立路由（路径不一样，可能会失序）</li>
<li>路由器根据分组的目标地址进行路由</li>
</ul>
<h2 id="虚电路的工作原理">虚电路的工作原理</h2>
<p><img src="/images/wl_02_3.png" alt="工作原理"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——04接入网和物理媒体</title>
    <url>/2024/02/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9404%E6%8E%A5%E5%85%A5%E7%BD%91%E5%92%8C%E7%89%A9%E7%90%86%E5%AA%92%E4%BD%93/</url>
    <content><![CDATA[<h1>接入网和物理媒体</h1>
<h2 id="接入网络和物理媒体">接入网络和物理媒体</h2>
<ul>
<li><font color=red>怎样将端系统和边缘路由器连接？</font>
<ul>
<li>住宅接入网络</li>
<li>单位接入网络（学校、公司）</li>
<li>无线接入网络</li>
</ul>
</li>
</ul>
<h2 id="住宅接入：modem">住宅接入：modem</h2>
<ul>
<li>将上网数据<font color=red>调制</font>加载到音频信号上，在电话线上传输，在局端将其中的数据<font color=red>解调</font>出来；
<ul>
<li>调频</li>
<li>调幅</li>
<li>调相位</li>
<li>综合调制</li>
</ul>
</li>
<li><font color=red>拨号调制解调器</font>
<ul>
<li><strong>56Kbps</strong>的速率直接接入路由器（通常更低）</li>
<li>不能同时上网和打电话；不能总是在线</li>
</ul>
</li>
</ul>
<h2 id="接入网-dsl">接入网（DSL）</h2>
<ul>
<li>采用<font color=red>现有的</font>到交换局DSLAM的电话线
<ul>
<li>DSL线路上的数据被传到互连网</li>
<li>DSL线路上的语音被传到电话网</li>
</ul>
</li>
<li>&lt; 2.5Mbps上行传输速率(typically &lt; 1Mbps)</li>
<li>&lt; 24Mbps下行运输速率(typically &lt; 10Mps)</li>
</ul>
<h2 id="接入网：线缆网络">接入网：线缆网络</h2>
<p>有线电视信号线缆双向改造<br>
<font color=red><em>FDM</em></font>：在不同频段传输不同信道的数据，数字电视和上网数据（上下行）</p>
<ul>
<li>HFC：
<ul>
<li>非对称：最高30Mbps的下行传输速率，2Mbps上行传输速率</li>
</ul>
</li>
<li>线缆和光纤网络将整个家庭用户接入到ISP路由器</li>
<li>各用户<font color=red>共享</font>到线缆头端的接入网络
<ul>
<li>与DSL不同，DSL每个用户一个专用线路到CO（central office）</li>
</ul>
</li>
</ul>
<h2 id="住宅接入：电缆模式">住宅接入：电缆模式</h2>
<p><img src="/images/wl_04_1.png" alt="示例"></p>
<h2 id="接入网：家庭网络">接入网：家庭网络</h2>
<p><img src="/images/wl_04_2.png" alt="示例"></p>
<h2 id="企业接入网络">企业接入网络</h2>
<p><img src="/images/wl_04_3.png" alt="示例"><br>
经常被企业或大学等机构采用</p>
<ul>
<li>10 Mbps, 100Mbps, 1Gbps, 10Gbps传输率</li>
<li>现在，端系统经常直接接到以太网络交换机上</li>
</ul>
<h2 id="无线接入网路">无线接入网路</h2>
<p>各无线端系统共享无线接入网络（端系统到无线路由器）</p>
<ul>
<li>通过基站或者加接入点</li>
</ul>
<p><font color=red><strong>无线LAN</strong></font></p>
<ul>
<li>建筑物内部（100 ft）</li>
<li>802.11 b/g（WIFI）：11，54Mbps 传输速率</li>
</ul>
<p><font color=red><strong>广域无线接入</strong></font></p>
<ul>
<li>由电信运营商提供</li>
<li>1 到 10 Mbps</li>
<li>3G、4G、LTE</li>
</ul>
<h2 id="物理媒体">物理媒体</h2>
<ul>
<li><font color=red><strong>Bit</strong></font>：在传输-接收对间传播</li>
<li><font color=red>物理链路</font>：在每个传输-接收对，跨越一种物理媒体</li>
<li><font color=red>引导型媒体</font>
<ul>
<li>信号沿着固体媒介或导引</li>
</ul>
</li>
<li><font color=red>非引导型媒体</font>
<ul>
<li>信号自由传播</li>
</ul>
</li>
</ul>
<h3 id="引导型媒体">引导型媒体</h3>
<ul>
<li><font color=red>双绞线</font>
<ul>
<li>两个绝缘铜线</li>
<li>5类：100Mbps 以太网 ，Gbps 千兆位以太网</li>
<li>6类：10Gbps万兆以太网</li>
</ul>
</li>
<li><font color=red>同轴电缆</font>
<ul>
<li>两根同轴的铜导线</li>
<li>双向</li>
<li>基带电缆：
<ul>
<li>电缆上一个单个信道</li>
<li>Ethernet</li>
</ul>
</li>
<li>宽带电缆：
<ul>
<li>电缆上有多个信道</li>
<li>HFC</li>
</ul>
</li>
</ul>
</li>
<li><font color=red>光缆</font>
<ul>
<li>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输</li>
<li>高速： 点到点的高速传输（如10 Gps-100Gbps传输速率 ）</li>
<li>低误码率：在两个中继器之 间可以有很长的距离，不受 电磁噪声的干扰</li>
<li>安全</li>
</ul>
</li>
</ul>
<h2 id="物理媒介：无线链路">物理媒介：无线链路</h2>
<ul>
<li>开放空间传输电磁波，携带要传输的数据</li>
<li>无需物理“线缆”</li>
<li>双向</li>
<li>传播环境效应
<ul>
<li>反射</li>
<li>吸收</li>
<li>干扰</li>
</ul>
</li>
</ul>
<h3 id="font-color-red-无线链路类型-font"><font color=red><strong>无线链路类型</strong></font></h3>
<ul>
<li>地面微波</li>
<li>LAN</li>
<li>wide-area</li>
<li>卫星
<ul>
<li>每个信道Kbps到45Kbps（或者多个聚集信道）</li>
<li>270msec端到端延迟</li>
<li>同步静止卫星和低轨卫星</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0124——二叉树的最大路径和</title>
    <url>/2024/02/05/%E5%8A%9B%E6%89%A30124%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">二叉树的最大路径和</a></h1>
<p>难度：<strong>困难</strong></p>
<h2 id="题目描述">题目描述</h2>
<p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<h2 id="示例1">示例1</h2>
<p><img src="/images/ltc_0124_1.jpg" alt="images"><br>
<strong>输入：</strong> root = [1,2,3]<br>
<strong>输出：</strong> 6</p>
<h2 id="示例2">示例2</h2>
<p><img src="/images/ltc_0124_2.jpg" alt="images"><br>
<strong>输入：</strong> root = [-10,9,20,null,null,15,7]<br>
<strong>输出：</strong> 42</p>
<h2 id="题解">题解</h2>
<p>因为每个节点只能遍历一次，所以当选择的根节点不为最顶层的节点的时候，叶子节点只能选择一个，可以利用回溯算法，将两个叶子节点其中的最大值（需要大于0）和当前节点的和与0进行比较的结果返回，回溯结束之后就可以得到最终结果</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, TreeNode left = <span class="literal">null</span>, TreeNode right = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">-10</span>,</span><br><span class="line">            left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>),</span><br><span class="line">            right = <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                val = <span class="number">20</span>,</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(<span class="number">15</span>),</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">int</span> x = solution.MaxPathSum(root);</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ans = <span class="built_in">int</span>.MinValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxPathSum</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BackTrack(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">BackTrack</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> left = BackTrack(root.left);</span><br><span class="line">        <span class="built_in">int</span> right = BackTrack(root.right);</span><br><span class="line">        <span class="built_in">int</span> current = Math.Max(<span class="number">0</span>, left) + Math.Max(<span class="number">0</span>, right) + root.val;</span><br><span class="line">        ans = Math.Max(current, ans);</span><br><span class="line">        <span class="keyword">return</span> Math.Max(<span class="number">0</span>, Math.Max(left, right)) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣0125——验证回文串</title>
    <url>/2024/02/06/%E5%8A%9B%E6%89%A30125%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1><a href="https://leetcode.cn/problems/valid-palindrome/description/">验证回文串</a></h1>
<p>难度：<font color=green><strong>简单</strong></font></p>
<h2 id="题目描述">题目描述</h2>
<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> 。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h2 id="示例1">示例1</h2>
<p><strong>输入:</strong> s = “A man, a plan, a canal: Panama”<br>
<strong>输出：</strong> true</p>
<h2 id="示例2">示例2</h2>
<p><strong>输入：</strong> s = “race a car”<br>
<strong>输出：</strong> false</p>
<h2 id="示例3">示例3</h2>
<p><strong>输入：</strong> s = &quot; &quot;<br>
<strong>输出：</strong> true</p>
<h2 id="题解">题解</h2>
<p>直接利用正则表达删除掉空格和标点符号，并将所有的字母转换为小写，之后将它转换为zhar数组并将其翻转，再将它变为字符串之后与经过正则处理之后的字符串进行对比即可</p>
<h2 id="想法代码">想法代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="built_in">string</span> s = s = <span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>;</span><br><span class="line">        <span class="built_in">bool</span> ans = solution.IsPalindrome(s);</span><br><span class="line">        Console.WriteLine(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> temp = Regex.Replace(s, <span class="string">&quot;[^A-Za-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">        <span class="built_in">char</span>[] tempArr = temp.ToCharArray();</span><br><span class="line">        Array.Reverse(tempArr);</span><br><span class="line">        <span class="keyword">return</span> temp.Equals(<span class="keyword">new</span> <span class="built_in">string</span>(tempArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——05Internet结构和ISP</title>
    <url>/2024/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9405Internet%E7%BB%93%E6%9E%84%E5%92%8CISP/</url>
    <content><![CDATA[<h1>Internet结构和ISP</h1>
<h2 id="互连网络结构：网络的网络">互连网络结构：网络的网络</h2>
<ul>
<li>端系统通过<font color=red>接入ISPs</font>连接到互连网
<ul>
<li>住宅、公司和大学的ISPs</li>
</ul>
</li>
<li>接入ISPs相应的必须是互联的
<ul>
<li>因此任何2个端系统可相互发送分组到对方</li>
</ul>
</li>
<li>导致的“网络的网络”非常复杂
<ul>
<li>发展和演化是通过<font color=red>经济的</font>和<font color=red>国家的</font>政策来驱动的</li>
</ul>
</li>
</ul>
<p><font color=red><strong>问题</strong></font>：给定数百万接入ISPs，如何将他们互联到一起?</p>
<p><img src="/images/wl_05_1.png" alt="图例"></p>
<p><font color=red><strong>选项</strong></font>：<em>将每个接入ISPs都连接到全局ISP（全局范围内覆盖）？</em></p>
<p><font color=red><strong>客户</strong></font>ISPs和<font color=red><strong>提供者</strong></font>ISPs有经济合约</p>
<p><img src="/images/wl_05_2.png" alt="图例"></p>
<p><font color=red><strong>竞争</strong></font>：如果全局ISP是有利可为的业务，那会有竞争者</p>
<p><img src="/images/wl_05_3.png" alt="图例"></p>
<p><font color=red><strong>合作</strong></font>：通过ISP之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系</p>
<p><img src="/images/wl_05_4.png" alt="图例"></p>
<p><font color=red>接入方式</font>：</p>
<ul>
<li>对等连接（路由器之间的连接）</li>
<li>IXP</li>
</ul>
<p>然后业务会细分（全球接入和区域接入），区域网络将出现，用于将ISPs连接到全局ISPs<br>
<img src="/images/wl_05_5.png" alt="图例"></p>
<ul>
<li>除了ISP，客户端两个身份，还有ICP这个角色，比如百度，谷歌等提供内容的服务商</li>
<li>ISP是提供基本连接的，ICP是提供业务的，早期ICP通过连入ISP来进行信息传输，会出现两个问题
<ul>
<li>成本过高：钱都要交给ISP</li>
<li>ISP没办法向全球的用户提供高质量的服务</li>
</ul>
</li>
<li>因此ICP就搭建自己的专网，即在全球范围内部署自己的数据中心机房，这些机房之间采用自己的专线，（或者是自己搭的，或者是租的，比如国内是不允许谷歌自己搭电缆的，要不然挖的乱七八糟的），而且机房的位置都靠近核心的ISP设备，用户通过ISP接进来，很快就能访问到谷歌的ISP，即使附近没有机房，也可以通过ISP连接到附近有机房的ISP</li>
<li>这样降低了成本，也提高了服务质量</li>
<li>国内也是类似，不过也可以向政府提案提速降费</li>
</ul>
<p>之后<font color=red>内容提供商网络</font>可能会构建他们的网络，将他们的服务、内容更加靠近端用户，向客户提供更好的服务，减少自己的运营支出<br>
<img src="/images/wl_05_6.png" alt="图例"></p>
<p>ICP数据服务中心机房部署的位置需要考虑很多因素</p>
<ul>
<li>离ISP数据中心机房较近</li>
<li>有的部署在温度较低的环境：北极、水底</li>
<li>比如大山：战争、自然灾害影响较小</li>
</ul>
<p><img src="/images/wl_05_7.png" alt="image"></p>
<p>在网络的最中心，一些为数不多的充分连接的大范围网络（分布广、节点有限、但是之间有着多重连接）</p>
<ul>
<li><font color=red>“tier-1” commercial ISPs</font> (e.g., Level 3, Sprint, AT&amp;T, NTT), 国家或者国际 范围的覆盖</li>
<li><font color=red>content provider network</font> (e.g., Google): 将它们的数据中心接入ISP，方便周边 用户的访问；通常私有网络之间用专网绕过第一层ISP和区域</li>
</ul>
<h2 id="internet结构：network-of-networks">Internet结构：network of networks</h2>
<ul>
<li>松散的层次结构</li>
<li><font color=red><strong>中心：第一层ISP</strong></font>国家/国际覆盖，速率很高
<ul>
<li>直接与其他第一层ISP相连</li>
<li>与大量的第二层ISP和其他客户网络相连</li>
</ul>
</li>
<li><font color=red><strong>第二层ISP</strong></font>：更小些的（通常是局域性的）ISP
<ul>
<li>与一个或多个第一层ISPs，也可能与其他第二层ISP</li>
</ul>
</li>
<li><font color=red><strong>第三层ISP与其他本地ISP</strong></font>
<ul>
<li>接入网（与端系统最近）</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_05_8.png" alt="第一层ISP"></p>
<p><img src="/images/wl_05_9.png" alt="美国骨干网BBN的覆盖情况"></p>
<p><img src="/images/wl_05_10.png" alt="Sprint的覆盖情况"></p>
<ul>
<li>POP是上级和下级的关系</li>
<li>下级通过与上级连接，上级再与ISP连接</li>
</ul>
<p><img src="/images/wl_05_11.png" alt="第二层ISP"></p>
<p><img src="/images/wl_05_12.png" alt="一个分组要经过许多网络"></p>
<h2 id="isp之间的连接">ISP之间的连接</h2>
<ul>
<li>POP：高层ISP面向客户网络的接入点，涉及费用结算
<ul>
<li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li>
</ul>
</li>
<li>对等接入：2个ISP对等互接，不涉及费用结算</li>
<li>IXP：多个对等ISP互联互通之处，通常不涉及费用结算</li>
<li>ICP自己部署专用网络，同时和各级ISP连接</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——06分组延时、丢失和吞吐量</title>
    <url>/2024/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9406%E5%88%86%E7%BB%84%E5%BB%B6%E6%97%B6%E3%80%81%E4%B8%A2%E5%A4%B1%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/</url>
    <content><![CDATA[<h1>分组延时、丢失和吞吐量</h1>
<h2 id="分组丢失和延时是怎样发生的">分组丢失和延时是怎样发生的</h2>
<p>在路由器缓冲区的分组队列</p>
<ul>
<li><font color=red>分组到达链路的速率超过了链路输出的能力</font></li>
<li>分组等待排到队头、被传输</li>
</ul>
<p><img src="/images/wl_06_1.png" alt="图例"></p>
<p>延时原因：</p>
<ul>
<li>当当前链路有别的分组进行传输，分组没有到达队首，就会进行排队，从而产生排队延迟</li>
<li>丢失原因：分组到达的时候，队列满了，就会丢弃</li>
<li>除了排队延时，还有传输延时</li>
</ul>
<h2 id="四种延时类型">四种延时类型</h2>
<ul>
<li><font color=red>节点处理延时</font>
<ul>
<li>检查<strong>bit</strong>级差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ul>
</li>
<li><font color=red><strong>排队延时</strong></font>
<ul>
<li>在输出链路上等待传输的时间</li>
<li>依赖于路由器的拥塞程度</li>
</ul>
</li>
<li><font color=red>传输延时</font>
<ul>
<li><strong>R</strong> = 链路带宽(<strong>bps</strong>)</li>
<li><strong>L</strong> = 分组长度(<strong>bits</strong>)</li>
<li>将分组发送到链路上的时间 = <strong>L / R</strong></li>
<li>存储转发延时</li>
</ul>
</li>
<li><font color=red>传播延时</font>
<ul>
<li><strong>d</strong> = 物理链路的长度</li>
<li><strong>s</strong> = 在媒体上的传播速度(<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2 * 10^{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> m/sec</strong>)</li>
<li>传播延时 = <strong>d/s</strong></li>
</ul>
</li>
</ul>
<h2 id="节点延时">节点延时</h2>
<p><img src="/images/wl_06_2.png" alt="图例"></p>
<h2 id="排队延时">排队延时</h2>
<ul>
<li><strong>R</strong> = 链路带宽（bps）</li>
<li><strong>L</strong> = 分组长度（bits）</li>
<li><strong>a</strong> = 分组到达队列的平均速率</li>
</ul>
<p><font color=red><strong>流量强度 = La / R</strong></font></p>
<ul>
<li><strong>La / R ~ 0</strong>：平均排队延时很小</li>
<li><strong>La / R -&gt; 1</strong>：排队延时变得很大</li>
<li><strong>La / R &gt; 1</strong>：比特到达队列的速率超过了从该队列输出的速率，平均排队时间将趋向无穷大</li>
</ul>
<p><font color=red><em>系统设计时流量强度不能大于1</em></font></p>
<p><img src="/images/wl_06_3.png" alt="图例"></p>
<h2 id="internet的延时和路由">Internet的延时和路由</h2>
<ul>
<li>Internet 的延时和路由是怎样的？
<ul>
<li><font color=red><strong>Traceroute</strong> 诊断程序</font>：提供从源端，经过路由器，到目的的延时测量</li>
<li><strong>For all i</strong>:
<ul>
<li>沿着目的的路径，向每个路由器发送<strong>3</strong>个探测分组</li>
<li>路由器 <em>i</em> 将向发送方返回一个分组</li>
<li>发送方对发送和回复之间间隔计时</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_06_4.png" alt="图示"></p>
<p>Traceroute 是 利用 <code>ICMP协议（互联网控制报文协议）</code> 运作的<br>
TTL的原理：</p>
<ul>
<li>假设源客户端是A，目标客户端是B，中间的路由器标号一次为 1 2 3 4 5</li>
<li>在分组的头部header中有一个字段叫TTL（Time to leave）是整数，每经过一个路由器时路由器将TTL-1，如果TTL=0，则该路由器向原客户端发送消息，从而得到时间</li>
<li>A设置TTL=1，那么第一个路由器返回时间；设置TTL=2，那么第二个路由器返回时间</li>
</ul>
<p>依次增大TTL，得到每个路由器返回的延时</p>
<ul>
<li>
<p>对于目标客户端B，设置TTL足够大能够达到B，但是设置端口号没有对应的服务，这样到达B之后找不到对应的端口号就又会向A返回时间，得到B的延时</p>
</li>
<li>
<p>在Windows系统下</p>
<ul>
<li>Tracert hostname</li>
<li>如 Tracert <a href="http://www.gucas.ac.cn">www.gucas.ac.cn</a></li>
</ul>
</li>
<li>
<p>更完整的例子</p>
<ul>
<li>tract [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name</li>
<li>请见帮助： <a href="http://www.linkwan.com/gb/broadmeter/article/trace">http://www.linkwan.com/gb/broadmeter/article/trace</a> -help.htm</li>
</ul>
</li>
<li>
<p>测试网址</p>
<ul>
<li><a href="http://www.traceroute.org">www.traceroute.org</a></li>
<li><a href="http://www.linkwan.com">www.linkwan.com</a></li>
</ul>
</li>
</ul>
<h2 id="分组丢失">分组丢失</h2>
<ul>
<li>链路的队列缓冲区容量有限</li>
<li>当分组到达一个满的队列时，该分组将会丢失</li>
<li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</li>
</ul>
<p><img src="/images/wl_06_5.png" alt="图示"></p>
<h2 id="吞吐量">吞吐量</h2>
<ul>
<li><font color=red><em>吞吐量</em></font>：在源端和目标端之间传输的速率（数据量 / 单位时间）
<ul>
<li><font color=red><em>瞬间吞吐量</em></font>：在一个时间点的速率</li>
<li><font color=red><em>平均吞吐量</em></font>：在一个长时间内平均值</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_06_6.png" alt="图示"></p>
<p><img src="/images/wl_06_7.png" alt="图示"></p>
<blockquote>
<p>吞吐量取决于吞吐量最小的路径</p>
</blockquote>
<p><img src="/images/wl_06_8.png" alt="图示"></p>
<h2 id="吞吐量：互联网场景">吞吐量：互联网场景</h2>
<p><img src="/images/wl_06_9.png" alt="图示"></p>
<ul>
<li>如图，可以看到R链路同时由多个连接共享，这样的话不同的连接就要平分带宽</li>
<li>这样尽管R的带宽比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">R_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">R_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大，但是实际给AB的带宽是 1/n，最终比较的是 1/n 的大小</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——07协议层次及服务模型</title>
    <url>/2024/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9407%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E5%8F%8A%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1>协议层次及服务模型</h1>
<h2 id="协议层次">协议层次</h2>
<p><font color=red>网络是一个复杂的系统</font></p>
<ul>
<li>网络功能复杂：数字信号的物理信号承载、点到点、路由、rdt、进程区分、应用等</li>
<li>现实来看，网络的许多构成元素和设备：
<ul>
<li>主机</li>
<li>路由器</li>
<li>各种媒体的链路</li>
<li>应用</li>
<li>协议</li>
<li>硬件，软件</li>
</ul>
</li>
</ul>
<p><font color=red>问题是</font>，如何组织和实现这个复杂的网络功能</p>
<p><code>模块化分解/分层</code></p>
<blockquote>
<p>分解和分层是不一样的</p>
<ul>
<li>分解:模块之间是可以相互调用的</li>
<li>分层：只有相邻两层客户相互调用</li>
</ul>
</blockquote>
<p><font color=red><strong>层次化方式</strong>实现复杂网络功能</font></p>
<ul>
<li>将网络复杂的功能分层功能明确的<font color=red>层次</font>，每一层实现了其中一个或一组<font color=red>功能</font>，功能中有其上层可以使用的功能：<font color=red>服务</font></li>
<li>本层协议实体相互交互执行本层的<font color=red>协议动作</font>，目的是实现本层功能，通过接口为上层提供更好的服务</li>
<li>在实现本层协议的时候，直接<font color=red>利用了下层所提供的服务</font></li>
<li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）更下层所提供的服务</li>
</ul>
<h2 id="服务与服务访问点">服务与服务访问点</h2>
<ul>
<li>服务：底层实体向上层实体提供他们之间通信的能力
<ul>
<li>服务用户</li>
<li>服务提供者</li>
</ul>
</li>
<li>原语：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的形式</li>
<li>服务访问点：上层使用下层提供的服务通过层间的接口——地点
<ul>
<li>例子：邮箱</li>
<li>地址：下层的一个实体支撑着上层的多个实体，<strong>SAP</strong>有标志不同上层实体的作用</li>
<li>可以有不同的实现，队列</li>
<li>例子：传输层的SAP：端口</li>
</ul>
</li>
</ul>
<h2 id="服务的类型">服务的类型</h2>
<ul>
<li>面向连接的服务和无连接的服务——方式
<ul>
<li>面向连接的服务
<ul>
<li><strong>连接</strong>：两个通信实体为进行通信而建立的一种结合</li>
<li>面向连接的服务通信的过程：建立连接，通信，拆除连接</li>
<li>面向连接的服务的例子：网络层的连接被称为虚电路</li>
<li>适用范围：对于大的数据块要传输：不适合小的零星报文</li>
<li>特点：保序</li>
<li>服务类型：
<ul>
<li>可靠的信息流传送页面（可靠的获得，通过接收方的确认）</li>
<li>可靠的字节流远程登陆</li>
<li>不可靠的连接数字化声音</li>
</ul>
</li>
</ul>
</li>
<li>无连接的服务
<ul>
<li>无连接服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃</li>
<li>特点：不可靠、可能重复、可能失序</li>
<li><strong>IP</strong>分组：数据包</li>
<li>适用范围：适合传送零星数据</li>
<li>服务类型：
<ul>
<li>不可靠的数据报：电子方式的函件</li>
<li>有确认的数据报：挂号信</li>
<li>请求回答：信息查询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="服务和协议">服务和协议</h2>
<ul>
<li>服务和协议的区别
<ul>
<li>服务：低层实体向上层实体提供它们之间的通信的能力，是通过原语来操作的，<font color=red>垂直</font></li>
<li>协议：对等层实体之间在相互通信的过程中，需要遵循的规则的集合，<font color=red>水平</font></li>
</ul>
</li>
<li>服务和协议的联系
<ul>
<li>本层<font color=red>协议的实现</font>要靠下层提供的服务来实现</li>
<li>本层实体通过协议为上层<font color=red>提供更高级的服务</font></li>
</ul>
</li>
</ul>
<h2 id="数据单元-du">数据单元（DU）</h2>
<p><img src="/images/wl_07_1.png" alt="图例"></p>
<p><img src="/images/wl_07_2.png" alt="协议和服务的关系"></p>
<h2 id="分层处理和实现复杂系统的好处">分层处理和实现复杂系统的好处</h2>
<p><font color=red>对付复杂的系统</font></p>
<ul>
<li>概念化：结构清晰，便于表示网络组件，以及描述其相互关系
<ul>
<li>分层参考模型</li>
</ul>
</li>
<li>结构化：模块化更易于维护和系统升级
<ul>
<li>改变某一层服务的实现不影响系统中的其他层次
<ul>
<li>对于其他层次而言是透明的</li>
</ul>
</li>
<li>如改变登机程序并不能影响系统的其他部分
<ul>
<li>改变 2 个程序使用的通信方式并不影响 2 个翻译的工作</li>
<li>改变 2 个翻译使用的语言不影响上下 2 个层次的工作</li>
</ul>
</li>
<li>分层思想被认为有海的地方：效率相对较低</li>
</ul>
</li>
</ul>
<h2 id="internet协议栈">Internet协议栈</h2>
<ul>
<li><font color=red>应用层</font>：网络应用
<ul>
<li>为人类用户或者其他应用进程提供网络应用服务</li>
<li>FTP、SMTP、HTTP、DNS</li>
</ul>
</li>
<li><font color=red>传输层</font>：主机之间的数据传输
<ul>
<li>在网络层提供的端到端的通信基础上，细分为进程到进程，将不可靠的通信变成可靠的通信</li>
</ul>
</li>
<li><font color=red>网络层</font>：为数据报从源到目的选择路由
<ul>
<li>主机与主机之间的通信，端到端的通信，不可靠</li>
<li>IP、路由协议</li>
</ul>
</li>
<li><font color=red>链路层</font>：相邻网络节点间的数据传输
<ul>
<li>2 个相邻 2 点的通信，点到点通信，可靠或不可靠</li>
<li>点对点协议<strong>PPP、802.11(wifi)、Ethernet</strong></li>
</ul>
</li>
<li><font color=red>物理层</font>：在线路上传送bit</li>
</ul>
<h2 id="iso-osi-参考模型">ISO/OSI 参考模型</h2>
<p><img src="/images/wl_07_3.png" alt="图示"></p>
<ul>
<li><font color=red><em>表示层</em></font>：允许应用解释传输的数据</li>
<li><font color=red><em>会话层</em></font>：数据交换的同步，检查点，恢复</li>
<li>互连网协议中没有这两层
<ul>
<li>这些服务如果需要的话必须被应用层实现</li>
</ul>
</li>
</ul>
<h2 id="封装和解封装">封装和解封装</h2>
<p><img src="/images/wl_07_4.png" alt=""></p>
<h2 id="各层次的协议数据单元">各层次的协议数据单元</h2>
<ul>
<li>应用层：报文</li>
<li>传输层：报文段：TCP段、UDP数据段</li>
<li>网络层：分组pocket（如果无连接方式：数据报datagram）</li>
<li>数据链路层：帧</li>
<li>物理层：位</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——08应用层原理</title>
    <url>/2024/02/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9408%E5%BA%94%E7%94%A8%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1>应用层原理</h1>
<h2 id="创建一个新的网络">创建一个新的网络</h2>
<p><font color=red><strong>编程</strong></font></p>
<ul>
<li>在不同的端系统上运行</li>
<li>通过网络基础设施提供的服务，应用进程批次通信</li>
<li>如<strong>Web</strong>
<ul>
<li><strong>Web</strong>服务器软件与浏览器软件通信</li>
</ul>
</li>
</ul>
<p><font color=red><strong>网络核心</strong>中没有应用层软件</font></p>
<ul>
<li>网络核心没有应用层功能</li>
<li>网络应用只能在端系统上存在
<ul>
<li>快速网络应用开发和部署</li>
</ul>
</li>
</ul>
<h2 id="网络应用的体系架构">网络应用的体系架构</h2>
<p>可能的应用架构</p>
<ul>
<li>客户-服务器模式（C/S）</li>
<li>对等模式（P2P）</li>
<li>混合体：客户-服务器和对等体系结构</li>
</ul>
<h2 id="客户-服务器-c-s-体系结构">客户-服务器（C/S）体系结构</h2>
<ul>
<li><font color=red>服务器</font>
<ul>
<li>一直运行</li>
<li>固定的IP和周知的端口号（约定）</li>
<li>扩展性：服务器场
<ul>
<li>数据中心进行拓展</li>
<li>拓展性差</li>
</ul>
</li>
</ul>
</li>
<li><font color=red>客户端</font>
<ul>
<li>主动与服务器通信</li>
<li>与互连网有间歇性的连接</li>
<li>可能是动态IP地址</li>
<li>不直接与其他客户端通信</li>
</ul>
</li>
<li><font color=red>缺点</font>
<ul>
<li>可拓展性差</li>
<li>达到一定能限，性能暴跌</li>
<li>可靠性差</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_08_1.png" alt=""></p>
<h2 id="对等体-p2p-体系结构">对等体（P2P）体系结构</h2>
<ul>
<li>（几乎）没有一直运行的服务器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端又是服务器
<ul>
<li><font color=red>自拓展性-新<strong>peer</strong>节点带来新的服务能力，当然也带来新的服务请求</font></li>
</ul>
</li>
<li>参与的主机间歇性连接且可以改变<strong>IP</strong>地址
<ul>
<li><font color=red>难以管理</font></li>
</ul>
</li>
</ul>
<h2 id="c-s和p2p体系结构的混合体">C/S和P2P体系结构的混合体</h2>
<p><font color=red><strong>Napster</strong></font></p>
<ul>
<li>文件搜索：集中
<ul>
<li>主机在中心服务器上注册其资源</li>
<li>主机向中心服务器铲鲟资源位置</li>
</ul>
</li>
<li>文件传输：<strong>P2P</strong>
<ul>
<li>任意<strong>Peer</strong>节点之间</li>
</ul>
</li>
</ul>
<p><font color=red><strong>即时通信</strong></font></p>
<ul>
<li>在线检测：集中
<ul>
<li>当用户上线时，向中心服务器注册其IP地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置</li>
</ul>
</li>
<li>两个用户之间聊天：<strong>P2P</strong></li>
</ul>
<h2 id="进程通信">进程通信</h2>
<p><font color=red>进程</font>：在主机上运行的应用程序</p>
<ul>
<li>在同一个主机内，使用<font color=red>进程间通信机制</font>通信（操作系统定义）</li>
<li>不同主机，通过交换<font color=red>报文</font>来通信
<ul>
<li>使用<strong>OS</strong>提供的通信服务</li>
<li>按照应用协议交换报文
<ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
</ul>
</li>
<li>注意：<strong>P2P</strong>架构的应用也有客户端进程和服务器进程之分</li>
</ul>
<p><font color=red>客户端进程</font>：发起通信的进程</p>
<p><font color=red>服务器进程</font>：等待连接的进程</p>
<h2 id="分布式进程通信需要解决的问题">分布式进程通信需要解决的问题</h2>
<p><img src="/images/wl_08_2.png" alt=""></p>
<ul>
<li>问题1：进程标示和寻址问题（<font color=red>服务用户</font>）</li>
<li>问题2：传输层-应用层提供服务是如何（<font color=red>服务</font>）
<ul>
<li>位置：层间界面的<strong>SAP</strong>（<strong>TCP/IP:socket</strong>）</li>
<li>形式：应用程序接口<strong>API</strong>（<strong>TCP/IP:socke API</strong>）</li>
</ul>
</li>
<li>问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（<font color=red>用户使用服务</font>）
<ul>
<li>定义应用层协议：报文格式、解释、时序等</li>
<li>编制程序：使用<strong>OS</strong>提供的<strong>API</strong>，调用网络基础设施提供通信服务传报文，实现应用时序等</li>
</ul>
</li>
</ul>
<h2 id="问题1：对进程进行编址">问题1：对进程进行编址</h2>
<ul>
<li>进程为了接收报文必须有一个<strong>标识</strong>，即<strong>SAP</strong>（发送也需要标识）
<ul>
<li>主机：唯一的<strong>32</strong>位<font color=red><strong>IP地址</strong></font>
<ul>
<li>仅仅有<strong>IP</strong>地址不能够唯一标示一个进程：在一台端系统上有很多应用进程在运行</li>
</ul>
</li>
<li>所采用的传输层协议：<strong>TCP or UDP</strong></li>
<li><font color=red>端口号</font></li>
</ul>
</li>
<li>一些知名端口号例子：
<ul>
<li><strong>HTTP:TCP 80 Mail:TCP25 ftp:TCP 2</strong></li>
</ul>
</li>
<li>一个进程：用<strong>IP + port</strong>标示端节点</li>
<li>本质上，一对主机进程之间的通信由 2 个端节点构成</li>
</ul>
<h2 id="问题2：传输层提供的服务-需要穿过层间的信息">问题2：传输层提供的服务-需要穿过层间的信息</h2>
<ul>
<li>层间接口必须要携带的信息
<ul>
<li>要传输的报文（对于本层来说：<strong>SDU</strong>）</li>
<li>谁传的：对方的应用进程的标示：<strong>IP + TCP(UDP)</strong> 端口</li>
<li>传给谁：对方的应用进程的标示：对方的<strong>IP + TCP(UDP)</strong> 端口号</li>
</ul>
</li>
<li>传输层实体（<strong>tcp</strong>或者<strong>udp</strong>实体）根据这些信息进行<strong>TCP</strong>报文段（<strong>UDP</strong>数据报）的封装
<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将<strong>IP</strong>地址往下交<strong>IP</strong>实体，用于封装<strong>IP</strong>数据报：源<strong>IP</strong>，目标<strong>IP</strong></li>
</ul>
</li>
</ul>
<h2 id="问题2：传输层提供的服务-层间信息的代表">问题2：传输层提供的服务-层间信息的代表</h2>
<ul>
<li>如果<strong>Socket API</strong>每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理</li>
<li>用个代号标示通信的双方或者单方：<strong>socket</strong></li>
<li>就像<strong>OS</strong>打开文件返回的句柄一样
<ul>
<li>对句柄的操作，就是对文件的操作</li>
</ul>
</li>
<li><strong>TCP socket</strong>:
<ul>
<li><strong>TCP</strong>服务，两个进程之间的通信需要之前要建立连接
<ul>
<li>两个进程通信会<font color=red>持续</font>一段时间，通信关系稳定</li>
</ul>
</li>
<li>可以用一个整数标示两个应用实体之间的通信关系，<font color=red>本地</font>标示</li>
<li>穿过层间接口的信息量<font color=red>最小</font></li>
<li><strong>TCP socket</strong>：源<strong>IP</strong>，源端口，目标<strong>IP</strong>，目标端口</li>
</ul>
</li>
</ul>
<h3 id="tcp之上的套接字-socket">TCP之上的套接字（socket）</h3>
<ul>
<li>对于使用面向连接服务（<strong>TCP</strong>）的应用而言，套接字是 4 元组的一个具有<font color=red>本地意义的标示</font>
<ul>
<li>4 元组：（<font color=red>源<strong>IP</strong>、源<strong>port</strong>、目标<strong>IP</strong>、目标<strong>port</strong></font>）</li>
<li>唯一的指定了一个会话（ 2 个进程之间的会话关系）</li>
<li>应用使用这个标示，与远程的应用进程通信</li>
<li>不必在每一个报文的发送都要指定这 4 元组</li>
<li>就像使用操作系统打开一个文件，<strong>OS</strong>返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</li>
<li>简单、便于管理</li>
</ul>
</li>
</ul>
<h3 id="tcp-socket">TCP socket</h3>
<p><img src="/images/wl_08_3.png" alt=""></p>
<p><img src="/images/wl_08_4.png" alt="例子"></p>
<h2 id="问题2：传输层提供的服务-层间信息代码">问题2：传输层提供的服务-层间信息代码</h2>
<ul>
<li><strong>UDP socket</strong>:
<ul>
<li><strong>UDP</strong>服务，两个进程之间的通信需要之前无需建立连接
<ul>
<li>每个报文都是独立传输的</li>
<li>前后报文可能给不同的分布式进程</li>
</ul>
</li>
<li>因此，只能用一个整数表示本应用实体的标示
<ul>
<li>因为这个报文可能传给另一个分布式进程</li>
</ul>
</li>
<li>穿过层间接口的信息大小最小</li>
<li><strong>UDP socket</strong>：本<strong>IP</strong>，本端口</li>
<li>但是传输报文时，必须要提供对方<strong>IP，port</strong>
<ul>
<li>接收报文时，传输层需要上传对方的<strong>IP，port</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="udp之上的套接字-socket">UDP之上的套接字（socket）</h3>
<ul>
<li>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有<font color=red>本地意义的标示</font>
<ul>
<li>2 元组：<font color=red><strong>IP、port</strong></font>（源端指定）</li>
<li><strong>UDP</strong>套接字指定了应用所在的一个<font color=red>端节点（end point）</font></li>
<li>在发送数据时，采用创建好的本地套接字（标示<strong>ID</strong>），就不必在发送每个报文中指明自己所采用的<strong>ip</strong>和<strong>port</strong></li>
<li>但是在发送报文时，必须要指定对方的<strong>ip</strong>和<strong>udp，port</strong>（另外一个端节点）</li>
</ul>
</li>
</ul>
<h3 id="套接字-socket">套接字(Socket)</h3>
<ul>
<li>进程向<font color=red>套接字</font>发送报文或从套接字接收报文</li>
<li>套接字&lt;-&gt;门户
<ul>
<li>发送进程将报文<strong>推出</strong>门户，发送进程依赖于传输层设施另外一侧的门将报文交付给接受进程</li>
<li>接收进程从另外一端的门户<strong>收到</strong>报文（依赖于传输层设施）</li>
</ul>
</li>
</ul>
<h2 id="问题3：如何使用传输层提供的服务实现应用">问题3：如何使用传输层提供的服务实现应用</h2>
<ul>
<li>定义应用层协议、报文格式、解释、时序等</li>
<li>编制程序，通过<strong>API</strong>调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等</li>
</ul>
<h2 id="应用层协议">应用层协议</h2>
<ul>
<li>定义了：运行在不同端系统上的应用进程如何相互交换报文
<ul>
<li>交换的<font color=red>报文类型</font>：请求和应答报文</li>
<li>各种报文类型的<font color=red>语法</font>:报文中的各个字段及其描述</li>
<li>字段的<font color=red>语义</font>：即字段取值的含义</li>
<li>进程何时，如何发送报文及对报文进行响应的&lt;/font color=red&gt;规则</font></li>
</ul>
</li>
<li>应用协议仅仅是应用的一个组成部分
<ul>
<li><strong>Web</strong>应用：<strong>HTTP</strong>协议、<strong>web</strong>客户端、<strong>web</strong>服务器、<strong>HTML</strong></li>
</ul>
</li>
</ul>
<p><font color=red>公开协议</font>:</p>
<ul>
<li>由<strong>RFC</strong>文档定义</li>
<li>允许互操作</li>
<li>如<strong>HTTP、SMTP</strong></li>
</ul>
<p><font color=red>专有（私有）协议</font>：</p>
<ul>
<li>协议不公开</li>
<li>如：<strong>Skype</strong></li>
</ul>
<h2 id="应用需要传输层提供什么样的服务">应用需要传输层提供什么样的服务</h2>
<p><font color=red>数据丢失率</font></p>
<ul>
<li>有些应用则要求100%的可靠数据传输</li>
<li>有些应用能容忍一定比例以下的数据丢失</li>
</ul>
<p><font color=red>延迟</font></p>
<ul>
<li>一些应用出于有效性考虑，对数据传输有严格的时间限制
<ul>
<li>Internet电话、交互式游戏</li>
<li>延迟，延迟差</li>
</ul>
</li>
</ul>
<p><font color=red>吞吐</font></p>
<ul>
<li>一些应用必须需要最小限度的吞吐，从而使得应用能够有效运转</li>
<li>一些应用能充分利用可供使用的吞吐（弹性应用）</li>
</ul>
<p><font color=red>安全性</font></p>
<ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性（鉴别）</li>
</ul>
<h3 id="常见应用对传输服务的要求">常见应用对传输服务的要求</h3>
<table>
<thead>
<tr>
<th>应用</th>
<th>数据丢失率</th>
<th>吞吐</th>
<th>时间敏感性</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件传输</td>
<td>不能丢失</td>
<td>弹性</td>
<td>不</td>
</tr>
<tr>
<td>e-mail</td>
<td>不能丢失</td>
<td>弹性</td>
<td>不</td>
</tr>
<tr>
<td>Web文档</td>
<td>不嫩柜式</td>
<td>弹性</td>
<td>不</td>
</tr>
<tr>
<td>实时音视频</td>
<td>容忍丢失</td>
<td>音频：5kbps-1Mbps，视频：100kbps-5Mbps</td>
<td>是，100ms</td>
</tr>
<tr>
<td>存储音视频</td>
<td>容忍丢失</td>
<td>同上</td>
<td>是，几秒</td>
</tr>
<tr>
<td>交互式游戏</td>
<td>容忍丢失</td>
<td>kbps-10kbps</td>
<td>是，100ms</td>
</tr>
<tr>
<td>即时讯息</td>
<td>不能丢失</td>
<td>弹性</td>
<td>是和不是</td>
</tr>
</tbody>
</table>
<h2 id="internet传输层提供的服务">Internet传输层提供的服务</h2>
<p><font color=red>TCP服务</font>：</p>
<ul>
<li>可靠的传输服务</li>
<li>流量控制：发送方不会淹没接受方</li>
<li>拥塞控制：当网络出现拥塞时，最小吞吐保证和安全</li>
<li>面向连接：要求客户端进程和服务器进程之间建立连接</li>
</ul>
<p><font color=red>UDP服务</font></p>
<ul>
<li>不可靠数据传输</li>
<li>不提供的服务：可靠、流量控制、拥塞控制、时间、带宽控制、建立连接</li>
</ul>
<h2 id="udp存在的必要性">UDP存在的必要性</h2>
<ul>
<li>能够<font color=red>区分不同的进程</font>，而<strong>IP</strong>服务不能
<ul>
<li>在<strong>IP</strong>提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li>
</ul>
</li>
<li><font color=red>无需建立连接</font>，省去了建立连接的时间，适合事务性的应用</li>
<li><font color=red>不做可靠性的工作</font>，例如检错重发，适合那些对实时性要求比较高而对正确性要求不告而应用
<ul>
<li>因为为了实现可靠性（准确性、保存等），必须付出时间代价（检错重发）</li>
</ul>
</li>
<li>没有拥塞控制和流量控制，<font color=red>应用能够按照设定的速度发送数据</font>
<ul>
<li>而在<strong>TCP</strong>上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<h2 id="internet应用及其应用层协议和传输协议">Internet应用及其应用层协议和传输协议</h2>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>下层传输的协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>e-mail</td>
<td>SMTP[RFC 2821]</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端访问</td>
<td>Telent[RFC 854]</td>
<td>TCP</td>
</tr>
<tr>
<td>Web</td>
<td>HTTP[RFC 2616]</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传输</td>
<td>FTP[RFC 959]</td>
<td>TCP</td>
</tr>
<tr>
<td>流媒体</td>
<td>专用协议</td>
<td>TCP或UDP</td>
</tr>
<tr>
<td>Internet电话</td>
<td>专用协议</td>
<td>TCP或UDP</td>
</tr>
</tbody>
</table>
<h2 id="安全tcp">安全TCP</h2>
<p>TCP &amp; UDP</p>
<ul>
<li>都没有加密</li>
<li>明文通过互联网传输，甚至密码</li>
</ul>
<p>SSL</p>
<ul>
<li>在TCP上面实现，提供加密的TCP连接</li>
<li>私密性</li>
<li>数据完整性</li>
<li>端到端的鉴别</li>
</ul>
<p>SSL在应用层</p>
<ul>
<li>应用采用SSL库，SSL库使用TCP通信</li>
</ul>
<p>SSL socket API</p>
<ul>
<li>应用通过API将明文交给socket，SSL将其加密在互联网上传输</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——09Web and HTTP</title>
    <url>/2024/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9409Web-and-HTTP/</url>
    <content><![CDATA[<h1>Web and HTTP</h1>
<h2 id="一些术语">一些术语</h2>
<ul>
<li><font color=red><strong>Web页</strong></font>：由一些对象组成</li>
<li>对象可以是<strong>HTML</strong>文件、<strong>JPEG</strong>图像，<strong>JAVA</strong>小程序，声音剪辑文件等</li>
<li><strong>Web</strong>页含有一个<font color=red>基本的<strong>HTML</strong>文件</font>，该基本<strong>HTML</strong>文件又包含若干对象的引用（链接）</li>
<li>通过<font color=red><strong>URL</strong></font>对每个对象进行引用
<ul>
<li><font color=red>访问协议：用户名、口令字、端口等</font></li>
</ul>
</li>
<li><strong>URL</strong>格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port://user:psw@www.someSchool.edu/someDept/pic.gif:port</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>路径元素</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Port</td>
<td>协议名</td>
</tr>
<tr>
<td>user</td>
<td>用户</td>
</tr>
<tr>
<td>psw</td>
<td>口令</td>
</tr>
<tr>
<td><a href="http://www.somSchool.edu">www.somSchool.edu</a></td>
<td>主机名</td>
</tr>
<tr>
<td>someDept/pic.gif</td>
<td>路径名</td>
</tr>
<tr>
<td>port</td>
<td>端口</td>
</tr>
</tbody>
</table>
<blockquote>
<p>用户口令可以不提供，即匿名访问<br>
端口不填可以是默认的：http-80，ftp-21</p>
</blockquote>
<h2 id="http概况">HTTP概况</h2>
<p><font color=red><strong>HTTP</strong>：超文本传输协议</font></p>
<ul>
<li><strong>Web</strong>的应用层协议</li>
<li>用户/服务器模式
<ul>
<li>客户：请求、接收和显示<strong>Web</strong>对象的浏览器</li>
<li>服务器：对请求进行响应，发送对象的<strong>Web</strong>服务器</li>
</ul>
</li>
<li><strong>HTTP 1.0: RFC 1945</strong></li>
<li><strong>HTTP 1.1: RFC 2068</strong></li>
</ul>
<p><img src="images/wl_09_1.png" alt=""></p>
<p><font color=red>使用<strong>TCP</strong></font></p>
<ul>
<li>客户发起一个与服务器的<strong>TCP</strong>连接（建立套接字），端口号为<strong>80</strong></li>
<li>服务器接受客户的<strong>TCP</strong>连接</li>
<li>在浏览器（<strong>HTTP</strong>客户端）与<strong>Web</strong>服务器（<strong>HTTP</strong>服务器<strong>server</strong>）交换<strong>HTTP</strong>报文（应用层协议报文）</li>
<li><strong>TCP</strong>连接关闭</li>
</ul>
<p><font color=red><strong>HTTP</strong>是无状态的</font></p>
<ul>
<li>服务器并不维护关于客户的任何信息</li>
</ul>
<p><font color=red>维护状态的协议很复杂</font></p>
<ul>
<li>必须维护历史信息（状态）</li>
<li>如果服务器/客户端死机，他们的状态可能不一致，二者的信息必须一致</li>
<li>无状态的服务器能够支持更多的客户端</li>
</ul>
<h2 id="http连接">HTTP连接</h2>
<p><font color=red>非持久<strong>HTTP</strong></font></p>
<ul>
<li>最多只有一个对象在<strong>TCP</strong>连接上发送</li>
<li>下载多个对象需要多个<strong>TCP</strong>连接</li>
<li><strong>HTTP/1.0</strong>使用非持久连接</li>
</ul>
<p><font color=red>持久<strong>HTTP</strong></font></p>
<ul>
<li>多个对象可以在一个（在客户端和服务器之间的）<strong>TCP</strong>连接上传输</li>
<li><strong>HTTP/1.1</strong>默认使用持久连接</li>
</ul>
<h2 id="非持久http连接">非持久HTTP连接</h2>
<p><img src="/images/wl_09_2.png" alt=""><br>
<img src="/images/wl_09_3.png" alt="非持久HTTP连接"></p>
<h2 id="响应时间模型">响应时间模型</h2>
<p><font color=red>往返时间<strong>RTT</strong></font>：一个小的分组从客户端到服务器，在回到客户端的时间（传输时间忽略）<br>
<font color=red>响应时间</font></p>
<ul>
<li>一个<strong>RTT</strong>用来发起<strong>TCP</strong>连接</li>
<li>一个<strong>RTT</strong>用来<strong>HTTP</strong>请求并等待<strong>HTTP</strong>响应</li>
<li>文件传输时间</li>
</ul>
<p><font color=red>共：<strong>2RTT</strong> + 传输时间</font><br>
<img src="/images/wl_09_4.png" alt=""></p>
<h2 id="持久http">持久HTTP</h2>
<p><font color=red>非持久<strong>HTTP</strong>的缺点</font></p>
<ul>
<li>每个对象要 2 个<strong>RTT</strong></li>
<li>操作系统必须为每个<strong>TCP</strong>连接分配资源</li>
<li>但浏览器通常打开并行<strong>TCP</strong>连接，以获取引用对象</li>
</ul>
<p><font color=red>持久<strong>HTTP</strong></font></p>
<ul>
<li>服务器在发送响应后，仍保持<strong>TCP</strong>连接</li>
<li>在相同客户端和服务器之后的后续请求和响应报文通过相连的连接进行传送</li>
<li>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</li>
</ul>
<p><font color=red>非流水方式的持久<strong>HTTP</strong></font></p>
<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求</li>
<li>每个引用对象花费一个<strong>RTT</strong></li>
</ul>
<p><font color=red>流水方式的持久<strong>HTTP</strong></font></p>
<ul>
<li><strong>HTTP/1.1</strong>的默认模式</li>
<li>客户端遇到一个引用对象就立即产生一个请求</li>
<li>所有引用（小）对象只花费一个<strong>RTT</strong>是可能的</li>
</ul>
<h2 id="http请求报文">HTTP请求报文</h2>
<ul>
<li>两种类型的<strong>HTTP</strong>报文：<font color=red>请求、响应</font></li>
</ul>
<h3 id="font-color-red-http请求报文-font"><font color=red><strong>HTTP</strong>请求报文</font></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">User-agent: Mozilla/4.0</span><br><span class="line">Connection: close</span><br><span class="line">Accept-language:fr</span><br></pre></td></tr></table></figure>
<p>解析报文如下：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求行</td>
<td>GET /somedir/page.html HTTP/1.1</td>
<td>命令： GET：获取数据；POST：上载数据；HEAD：仅仅获取相应头部，搜索引擎使用改命令得到头部之后建立索引资源路径：<code>/somedir/page.html</code>协议/协议版本：<code>HTTP/1.1</code></td>
</tr>
<tr>
<td>首部行</td>
<td>Host: <a href="http://www.someschool.edu">www.someschool.edu</a> User-agent: Mozilla/4.0 Connection: close Accept-language:fr</td>
<td></td>
</tr>
<tr>
<td>实体</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="http请求报文：通用格式">HTTP请求报文：通用格式</h3>
<p><img src="/images/wl_09_5.png" alt=""></p>
<blockquote>
<p>sp是space空格<br>
cr是回车<br>
if是有可能有，有可能没有</p>
</blockquote>
<h3 id="提交表单输入">提交表单输入</h3>
<p><font color=red><strong>Post方式</strong></font></p>
<ul>
<li>网页通常包括表单输入</li>
<li>包含在实体主体中的输入被提交到服务器</li>
</ul>
<p><font color=red><strong>URL</strong>方式</font></p>
<ul>
<li>方法：<strong>GET</strong></li>
<li>输入通过字段请求行的<strong>URL</strong>字段上载</li>
</ul>
<h3 id="方法类型">方法类型</h3>
<p><font color=red><strong>HTTP 1.0</strong></font></p>
<ul>
<li><strong>GET</strong></li>
<li><strong>POST</strong></li>
<li><strong>HEAD</strong>
<ul>
<li>要求服务器咋响应报文中不包含请求对象 -&gt; 故障跟踪</li>
</ul>
</li>
</ul>
<p><font color=red><strong>HTTP 1.1</strong></font></p>
<ul>
<li><strong>GET、POST、HEAD</strong></li>
<li><strong>PUT</strong>
<ul>
<li>将实体主体中的文件上载到<strong>URL</strong>字段限定的路径</li>
</ul>
</li>
<li><strong>DELETE</strong>
<ul>
<li>删除<strong>URL</strong>字段限定的文件</li>
</ul>
</li>
</ul>
<h2 id="http响应报文">HTTP响应报文</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection close</span><br><span class="line">Date: Thu, 06 Aug 1998 12:00:15 GMT</span><br><span class="line">Server: Apache/1.3.0 (Unix)</span><br><span class="line">Last-Modified: Mon, 22 Jun 1998 …... </span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data data data data data ...</span><br></pre></td></tr></table></figure>
<p>解析：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>状态行</td>
<td>HTTP/1.1 200 OK</td>
<td>HTTP/1.1是协议及版本，200是状态码，OK是状态码相应状态信息</td>
</tr>
<tr>
<td>首部行</td>
<td>Connection close Date: Thu, 06 Aug 1998 12:00:15 GMT Server: Apache/1.3.0 (Unix) Last-Modified: Mon, 22 Jun 1998 …… Content-Length: 6821 Content-Type: text/html</td>
<td></td>
</tr>
<tr>
<td>数据</td>
<td>data data data data data …</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="http响应状态码">HTTP响应状态码</h3>
<p>位于服务器 -&gt; 客户端的响应报文中的首行<br>
一些状态码的例子</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态信息</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功，请求对象包含在响应报文的后续部分</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>请求的对象己经被永久转移了;新的URL在响应报文的Location:首部行中指定；客户端软件自动用新的URL去获取对象</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>一个通用的差错代码，表示该请求不能被服务器解读</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>请求的文档在该服务上没有找到</td>
</tr>
<tr>
<td>505</td>
<td>HTTP version Not supported</td>
<td>版本不支持</td>
</tr>
</tbody>
</table>
<h2 id="用户-服务器状态：cookies">用户-服务器状态：cookies</h2>
<p>大多数主要的门户网站使用<strong>cookies</strong></p>
<p><font color=red>4个组成部分</font></p>
<ul>
<li>在<strong>HTTP</strong>响应报文中有一个<strong>cookie</strong>的首部行</li>
<li>在<strong>HTTP</strong>请求报文含有一个<strong>cookie</strong>的首部行</li>
<li>在用户端系统中保留有一个<strong>cookie</strong>文件，由用户的浏览器管理</li>
<li>在<strong>Web</strong>站点有一个后端数据库</li>
</ul>
<h3 id="cookies-维护状态">Cookies:维护状态</h3>
<p><img src="/images/wl_09_6.png" alt=""></p>
<h3 id="cookies能带来什么">Cookies能带来什么</h3>
<ul>
<li>用户验证</li>
<li>购物车</li>
<li>推荐</li>
<li>用户状态</li>
</ul>
<h3 id="如何维持状态"><em>如何维持状态</em></h3>
<ul>
<li>协议端节点：在多个事务上，发送端和接收端维持状态</li>
<li>cookies：http报文携带状态信息</li>
</ul>
<h3 id="cookies与隐私">Cookies与隐私</h3>
<ul>
<li><strong>Cookies</strong>允许站点知道许多关于用户的信息</li>
<li>可能将他知道的东西卖给第三方</li>
<li>使用重定向和<strong>cookie</strong>的搜索引擎还可能知道用户的更多信息</li>
<li>广告公司从站点获得信息</li>
</ul>
<h2 id="web缓存-代理服务器">Web缓存（代理服务器）</h2>
<p><font color=red>目标</font>：不访问<strong>原始</strong>服务器，就满足客户的请求</p>
<ul>
<li>用户设置浏览器：通过缓存访问<strong>Web</strong></li>
<li>浏览器将所有的<strong>HTTP</strong>请求发送给缓存：
<ul>
<li>在缓存中的对象：缓存直接返回对象</li>
<li>如对象不在缓存：缓存请求原始服务器，然后再将对象返回给客户端</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_09_7" alt=""></p>
<h3 id="web缓存">Web缓存</h3>
<ul>
<li>缓存既是客户端又是服务器</li>
<li>通常缓存是由<strong>ISP</strong>安装</li>
</ul>
<h3 id="为什么要使用web缓存">为什么要使用Web缓存</h3>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与<strong>Internet</strong>接入链路上的流量</li>
<li>互连网大量采用了缓存：可以使较弱的<strong>ICP</strong>也能够有效提供内容</li>
</ul>
<h3 id="缓存示例">缓存示例</h3>
<p><img src="/images/wl_09_8.png" alt=""><br>
条件</p>
<ul>
<li>平均对象大小 = 100kb（也就是请求的文件的平均大小是100kb）</li>
<li>机构内浏览器对原始服务器的 平均请求率为 = 15请求/s</li>
<li>平均到浏览器的速率：1.5Mbps（100kb * 15请求/s）</li>
<li>接入链路带宽：1.54Mbps</li>
</ul>
<p><font color=red><strong>相关数据计算</strong></font>：</p>
<ul>
<li>
<p>各种延时计算(Internet延时、接入延时、LAN延时)</p>
</li>
<li>
<p>延时如下：</p>
<ul>
<li>Internet延时：公共网(public Internet)路由器到原始服务器 再返回到路由器的的延时 （ Internet 延时）= 2s；这个也是网络核心的延时吧</li>
<li>接入延时：不确定，不过有公式：接入延时（主要还是排队延时）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{queue}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> = I(1-I) * L / R = 2min</li>
<li>LAN延时：客户端到LAN路由器再返回客户端的时间，为10ms</li>
</ul>
</li>
<li>
<p>流量强度和排队延时计算:</p>
<ul>
<li>流量强度 I = 平均到达浏览器的速率 / 接入链路宽带</li>
<li>排队延时 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{queue}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> = I(1-I) * L / R</li>
<li>L/R：一个分组的传输时间</li>
</ul>
</li>
<li>
<p>结果:</p>
<ul>
<li>LAN的流量强度 = 15%</li>
<li>接入链路上的流量强度 = 99% （排队延迟会非常大，排队延迟会随着分组的流量强度越接近于1趋近于无穷，此时排队延迟会非常大）</li>
<li>总延时= LAN延时+ 接入延时+ Internet 延时 = ms + 分+ 2s</li>
</ul>
</li>
</ul>
<p>流量强度 = 平均到达浏览器的速率 / 接入链路宽带 = 1.5 / 1.54 = 0.99</p>
<p><font color=red><strong>优化方式</strong></font></p>
<ul>
<li>
<p>提高接入链路带宽</p>
<ul>
<li>假设：
<ul>
<li>平均对象大小 = 100kb</li>
<li>机构内浏览器对原始服务器的 平均请求率为 = 15请求/s</li>
<li>平均到浏览器的速率：1.5Mbps</li>
<li>接入链路带宽：1.54Mbps——&gt; 154Mbps（带宽提升）</li>
</ul>
</li>
<li>延时：
<ul>
<li>Internet延时机构内部路由器到原始服务器 再返回到路由器的的延时 = 2s</li>
<li>LAN延时：客户端到LAN路由器再返回客户端的时间，为10ms</li>
</ul>
</li>
<li>结果:
<ul>
<li>LAN的流量强度 = 15%</li>
<li>接入链路上的流量强度 = 9.9%（可以看到强度降低了很多，排队延时也会下降）</li>
<li>总延时 = LAN延时 + 接入延时 + Internet 延时 = ms + 分 + 2s</li>
</ul>
</li>
<li>代价: 增加了接入链路带宽（非常昂贵！）</li>
</ul>
</li>
<li>
<p>安装本地缓存</p>
<ul>
<li>假设:
<ul>
<li>平均对象大小 = 100kb</li>
<li>机构内浏览器对原始服务器的平均 请求率为 = 15请求/s</li>
<li>平均到浏览器的速率：1.5Mbps</li>
<li>机构内部路由器到原始服务器再返回到路由器的的延时 （Internet 延 时）= 2s</li>
<li>接入链路带宽：1.54Mbps</li>
</ul>
</li>
<li>结果:
<ul>
<li>LAN 利用率: 15%</li>
<li>接入网络利用率： ？</li>
<li>总体延迟= ? 代价: web缓存(廉价!)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>计算链路利用率，有缓存的延迟：</p>
<ul>
<li>假设:
<ul>
<li>缓存命中率0.4：40%请求在缓存中被满足，其他60%的请求 需要被原始服务器满足</li>
<li>接入链路利用率: 60%的请求采用接入链路</li>
<li>进过接入链路到达浏览器的数据速 率 = 0.6*1.50 Mbps = 0.9 Mbps</li>
<li>利用率= 0.9/1.54 = 0.58</li>
<li>总体延迟 = 0.6 * (从原始服务器获取对象的 延迟，也就是接入延时 + Internet延时) +0.4 * (从缓存获取对象的延迟，也就是LAN延时) = 0.6 * (2s) + 0.4 * (msecs，这个很小，所以几乎不看了) = 1.2 secs</li>
<li>比安装154Mbps链路还来得小 (而且 比较便宜!)</li>
</ul>
</li>
</ul>
<h3 id="条件get方法">条件GET方法</h3>
<ul>
<li><font color=red>目标</font>：如果缓存器中的对 象拷贝是最新的，就不要发送对象</li>
<li>缓存器: 在HTTP请求中指 定缓存拷贝的日期 <code>If-modified-since:&lt;date&gt;</code></li>
<li>服务器: 如果缓存拷贝陈 旧，则响应报文没包含对象: <code>HTTP/1.0 304 Not Modified</code></li>
</ul>
<p><img src="/images/wl_09_9.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——10FTP</title>
    <url>/2024/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9410FTP/</url>
    <content><![CDATA[<h1>FTP</h1>
<h2 id="ftp：文件传输协议">FTP：文件传输协议</h2>
<ul>
<li>向远程主机上传输文件或从远程主机接收文件</li>
<li>客户/服务器模式
<ul>
<li>客户端：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li><strong>ftp:RFC 959</strong></li>
<li><strong>ftp</strong>服务器：端口号为21</li>
</ul>
<p><img src="/images/wl_10_1.png" alt=""></p>
<h2 id="ftp：控制连接与数据连接分开">FTP：控制连接与数据连接分开</h2>
<p>控制连接</p>
<ul>
<li><strong>FTP</strong>客户端与<strong>FTP</strong>服务器通过端口 21 联系，并使用<strong>TCP</strong>为传输协议</li>
<li>客户端通过控制连接获得身份确认</li>
<li>客户端通过控制连接发送命令浏览远程目录</li>
</ul>
<p>数据连接</p>
<ul>
<li>收到一个文件传输命令时，服务器打开一个到客户端的数据连接</li>
<li>一个文件传输完成后，服务器关闭连接</li>
</ul>
<p>继续控制连接</p>
<ul>
<li>客户端继续通过控制连接发送命令：下载文件</li>
</ul>
<p>重新开启数据连接</p>
<ul>
<li>服务器打开 第二个TCP 数据连接用来传输另一个文件（服务器主动）</li>
<li>然后又关闭连接</li>
</ul>
<p>控制连接： <font color=red>带外（ “out of band” ）</font>传送 ，就是服务端可以向客户端发送请求建立连接</p>
<p>FTP服务器维护用户的状态信息： 当前路径、用户帐户与控制连接对应</p>
<p>FTP是有状态的协议</p>
<h2 id="ftp命令-响应">FTP命令、响应</h2>
<p><font color=red>命令样例</font></p>
<ul>
<li>在控制连接上以<strong>ASCII</strong>文本方式传送</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER username</td>
<td>发送用户名</td>
</tr>
<tr>
<td>PASS password</td>
<td>发送命令</td>
</tr>
<tr>
<td>LIST</td>
<td>请服务器返回远程主机当前目录的文件列表</td>
</tr>
<tr>
<td>RETR filename</td>
<td>从远程主机的当前目录检索文件 (gets)</td>
</tr>
<tr>
<td>STOR filename</td>
<td>向远程主机的当前目录存放文件 (puts)</td>
</tr>
</tbody>
</table>
<p><font color=red>返回码示例</font></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>331</td>
<td>Username OK, password required</td>
</tr>
<tr>
<td>125</td>
<td>data connection already open; transfer starting</td>
</tr>
<tr>
<td>425</td>
<td>Can’t open data connection</td>
</tr>
<tr>
<td>452</td>
<td>Error writing file</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——11EMail</title>
    <url>/2024/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9411EMail/</url>
    <content><![CDATA[<h1>EMail</h1>
<h2 id="电子邮件-email">电子邮件（EMail）</h2>
<p><font color=red>3个主要组成部分</font></p>
<ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议：<strong>SMTP</strong></li>
</ul>
<p><font color=red>用户代理</font></p>
<ul>
<li>又名“邮件阅读器”</li>
<li>撰写、编辑和阅读邮件</li>
<li>输入和输出邮件保存在服务器上</li>
</ul>
<p><img src="/images/wl_11_1.png" alt=""></p>
<p><font color=red>邮件服务器</font></p>
<ul>
<li><font color=red>邮箱</font>中管理和维护发送给用户的邮件</li>
<li>输出<font color=red>报文队列</font>保持待发送邮件报文</li>
<li>邮件服务器之间的<font color=red><strong>SMTP</strong>协议</font>：发送<strong>emmail</strong>报文
<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
</li>
</ul>
<h2 id="email：smtp-rfc-2821">EMail：SMTP[RFC 2821]</h2>
<ul>
<li>使用TCP在客户端和服务器之间传送报文，端口号为25</li>
<li>直接传输：从发送方服务器到接收方服务器</li>
<li>传输的三个阶段
<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul>
</li>
<li>命令/相应交互
<ul>
<li>命令：ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul>
</li>
<li>报文必须为7位ASCII码</li>
</ul>
<h2 id="邮件发送流程">邮件发送流程</h2>
<h3 id="举例：alice给bob发送报文">举例：Alice给Bob发送报文</h3>
<p><img src="/images/wl_11_2.png" alt=""></p>
<ul>
<li>Alice使用用户代理撰写邮件并发送给 <a href="mailto:bob@someschool.edu">bob@someschool.edu</a></li>
<li>Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中</li>
<li>SMTP的客户端打开到Bob邮件服务器的TCP连接（建立TCP连接）</li>
<li>SMTP客户端通过TCP连接发送Alice的邮件</li>
<li>Bob的邮件服务器将邮件放到Bob的邮箱（POP3，）</li>
<li>Bob调用他的用户代理阅读邮件</li>
</ul>
<h3 id="简单的smtp交互">简单的SMTP交互</h3>
<p>以下是两个右键服务器进行SMTP交互的流程</p>
<ul>
<li>C：客户，发送方邮件服务器</li>
<li>S：服务器，接收方邮件服务器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S: 220 hamburger.edu</span><br><span class="line">C: HELO crepes.fr</span><br><span class="line">S: 250 Hello crepes.fr, pleased to meet you</span><br><span class="line">C: MAIL FROM: &lt;alice@crepes.fr&gt; #邮件来自的邮箱</span><br><span class="line">S: 250 alice@crepes.fr... Sender ok #接受成功</span><br><span class="line">C: RCPT TO: &lt;bob@hamburger.edu&gt; #邮件去往的邮箱</span><br><span class="line">S: 250 bob@hamburger.edu ... Recipient ok # 接受成功</span><br><span class="line">C: DATA  # 邮件信息</span><br><span class="line">S: 354 Enter mail, end with &quot;.&quot; on a line by itself</span><br><span class="line">C: Do you like ketchup?</span><br><span class="line">C: How about pickles?</span><br><span class="line">C: .</span><br><span class="line">S: 250 Message accepted for delivery</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 hamburger.edu closing connection</span><br></pre></td></tr></table></figure>
<h2 id="smtp-总结">SMTP 总结</h2>
<ul>
<li>SMTP使用持久连接</li>
<li>SMTP要求报文（首部和主体）为７位ASCII编码</li>
<li>SMTP服务器使用CRLF，CRLF决定报文的尾部</li>
</ul>
<p><font color=red>HTTP比较</font></p>
<ul>
<li>HTTP：拉（pull）</li>
<li>SMTP：推（push）</li>
<li>二者都是ASCII形式的命令/响应交互、状态码</li>
<li>HTTP：每个对象封装在各自的响应报文中</li>
<li>SMTP：多个对象包含在一个报文中</li>
</ul>
<h2 id="邮件报文格式">邮件报文格式</h2>
<p>SMTP：交换email报文的协议<br>
RFC 822：文本交换的标准</p>
<ul>
<li>
<p>首部行：如</p>
<ul>
<li>To:</li>
<li>From:</li>
<li>Subject:</li>
</ul>
<p>与SMTP命令不同</p>
</li>
<li>
<p>主体</p>
<ul>
<li>报文，只能是ASCII码字符</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_11_3.png" alt=""></p>
<h3 id="报文格式：多媒体拓展">报文格式：多媒体拓展</h3>
<ul>
<li>MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056</li>
<li>在报文首部用额外的行申明MIME内容类型</li>
</ul>
<p><img src="/images/wl_11_4.png" alt=""></p>
<h2 id="邮件访问协议">邮件访问协议</h2>
<p><img src="/images/wl_11_5.png" alt=""></p>
<ul>
<li>SMTP: 传送到接收方的邮件服务器</li>
<li>邮件访问协议：从服务器访问邮件 （3种方式）
<ul>
<li>POP3：邮局访问协议（Post Office Protocol）[RFC 1939]
<ul>
<li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li>
</ul>
</li>
<li>IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730]
<ul>
<li>更多特性和功能 (更复杂) ；在服务器上处理存储的报文</li>
</ul>
</li>
<li>HTTP：Hotmail , Yahoo! Mail等
<ul>
<li>方便</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pop3协议">POP3协议</h2>
<p><font color=red><strong>用户确认阶段</strong></font></p>
<ul>
<li>客户端命令：
<ul>
<li>user: 申明用户名</li>
<li>pass: 口令</li>
</ul>
</li>
<li>服务器响应
<ul>
<li>+OK</li>
<li>-ERR</li>
</ul>
</li>
</ul>
<p><font color=red><strong>事物处理阶段</strong></font></p>
<p>客户端：</p>
<ul>
<li>list: 报文号列表</li>
<li>retr: 根据报文号检索报文</li>
<li>dele: 删除</li>
<li>quit：关闭连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用户确认阶段</span><br><span class="line">S: +OK POP3 server ready</span><br><span class="line">C: user bob</span><br><span class="line">S: +OK</span><br><span class="line">C: pass hungry</span><br><span class="line">S: +OK user successfully logged on</span><br><span class="line"># 事物处理阶段</span><br><span class="line">C: list</span><br><span class="line">S: 1 498</span><br><span class="line">S: 2 912</span><br><span class="line">S: .</span><br><span class="line">C: retr 1</span><br><span class="line">S: &lt;message 1 contents&gt;</span><br><span class="line">S: .</span><br><span class="line">C: dele 1</span><br><span class="line">C: retr 2</span><br><span class="line">S: &lt;message 1 contents&gt;</span><br><span class="line">S: .</span><br><span class="line">C: dele 2</span><br><span class="line">C: quit</span><br><span class="line">S: +OK POP3 server signing off</span><br></pre></td></tr></table></figure>
<ul>
<li>先前的例子使用 “下载 并删除”模式。
<ul>
<li>如果改变客户机，Bob不 能阅读邮件</li>
</ul>
</li>
<li>“下载并保留”：不同 客户机上为报文的拷贝</li>
<li>POP3在会话中是无状态的</li>
</ul>
<p><font color=red><strong>IMAP</strong></font></p>
<ul>
<li>IMAP服务器将每个报文 与一个文件夹联系起来</li>
<li>允许用户用目录来组织 报文</li>
<li>允许用户读取报文组件</li>
<li>IMAP在会话过程中保留 用户状态：
<ul>
<li>目录名、报文ID与目录名 之间映射</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——12DNS</title>
    <url>/2024/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9412DNS/</url>
    <content><![CDATA[<h1>DNS</h1>
<h2 id="dns的必要性">DNS的必要性</h2>
<ul>
<li>IP地址标识主机、路由器</li>
<li>但IP地址不好记忆，不便于人类用使用（没有意义）</li>
<li>人类一般倾向于使用一些有意义的字符串来标识Internet上的设备</li>
<li>存在着“字符串”——IP地址的转换的必要性</li>
<li>人类用户提供要访问机器的“字符串”名称</li>
<li>由DNS负责转换为二进制的网络地址</li>
</ul>
<h2 id="dns系统需要解决的问题">DNS系统需要解决的问题</h2>
<ul>
<li>问题1：如何命名设备
<ul>
<li>用有意义的字符串：好记，便于人类用使用</li>
<li>解决一个平面命名的重名问题：层次化命名</li>
</ul>
</li>
<li>问题2：如何完成名字到IP地址的转换
<ul>
<li>分布式的数据库维护和响应名字查询</li>
</ul>
</li>
<li>问题3：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</li>
</ul>
<h2 id="dns的历史">DNS的历史</h2>
<ul>
<li>APRANET的名字解析解决方案
<ul>
<li>主机名：没有层次的一个字符串（一个平面）</li>
<li>存在着一个（集中）维护站：维护者一张主机名-IP地址的映射文件：Hosts.txt</li>
<li>每台主机定时从维护站取文件</li>
</ul>
</li>
<li>APRAnet解决方案的问题
<ul>
<li>当网络中主机数量很大时
<ul>
<li>没有层次的主机名称很难分配</li>
<li>文件的管理、发布、查找都很麻烦</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="dns总体思路和目标">DNS总体思路和目标</h2>
<ul>
<li>DNS的主要思路
<ul>
<li><font color=red>分层</font>的、基于域的命名机制</li>
<li>若干<font color=red>分布</font>式的数据库完成名字到IP地址的转换</li>
<li>运行在UDP之上端口号为53的<font color=red>应用</font>服务</li>
<li>核心的Internet功能，但以应用层协议实现
<ul>
<li>在网络边缘处理复杂性</li>
</ul>
</li>
</ul>
</li>
<li>DNS主要目的
<ul>
<li>实现主机名-IP地址的转换</li>
<li>其他目的
<ul>
<li><font color=red>主机别名</font>到<font color=red>规范名字</font>的转换</li>
<li>邮件服务器<font color=red>别名</font>到邮件服务器的<font color=red>正规名字</font>的转换</li>
<li><font color=red>负载均衡</font></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="问题1：dns命名空间">问题1：DNS命名空间</h2>
<p>DNS域名结构</p>
<ul>
<li>一个层面命名设备会有很多重名</li>
<li>DNS采用层次树状结构的命名方法</li>
<li>Internet根被划为几百个顶级域
<ul>
<li>通用的：
<ul>
<li>.com; .edu ; .gov ; .int ; .mil ; .net ; .org .firm ; .hsop ; .web ; .arts ; .rec ;</li>
</ul>
</li>
<li>国家的：
<ul>
<li>.cn ; .us ; .nl ; .jp</li>
</ul>
</li>
</ul>
</li>
<li>每个（子）域下面可划分为若干子域</li>
<li>树叶是主机</li>
</ul>
<h3 id="dns名字空间">DNS名字空间</h3>
<p><img src="/images/wl_12_1.png" alt=""></p>
<p>域名：</p>
<ul>
<li>从本域往上，直到树根</li>
<li>中间使用“.”间隔不同的级别</li>
<li>域的域名：可以用于表示一个域</li>
<li>主机的域名：一个域上的一个主机</li>
</ul>
<p>域名的管理：</p>
<ul>
<li>一个域管理其下的子域</li>
<li>创建一个新的域，必须征得它所属域的同意</li>
</ul>
<p>域与物理网络无关</p>
<ul>
<li>域遵从组织界限，而不是物理网络
<ul>
<li>一个域的主机可以不在一个网络</li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的</li>
</ul>
<h2 id="问题2：解析问题-名字服务器">问题2：解析问题-名字服务器</h2>
<p>一个名字服务器的问题：</p>
<ul>
<li>可靠性问题：单点故障</li>
<li>拓展性问题：通信容量</li>
<li>维护问题：远距离的集中式数据库</li>
</ul>
<p>区域：</p>
<ul>
<li>区域的划分由区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li>
<li>名字服务器：
<ul>
<li>每个区域都有一个名字服务器，维护着它所管辖区域的权威信息</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
</ul>
<h3 id="名字空间换分为若干区域：zone">名字空间换分为若干区域：Zone</h3>
<p><img src="/images/wl_12_2.png" alt=""><br>
<font color=red>权威DNS服务器</font>：组织机构的DNS服务器，提供组织机构服务器（如Web和mail）可访问的主机和IP之间的映射</p>
<p>组织机构可以选择实现自己维护或由某个服务器提供商来维护</p>
<h3 id="tld服务器">TLD服务器</h3>
<ul>
<li><font color=red>顶级域(TLD)服务器</font>：负责顶级域名和所有国家级的顶级域名
<ul>
<li>Network solutions 公司维护com TLD服务器</li>
<li>Educause 公司维护edu TLD服务器</li>
</ul>
</li>
</ul>
<h3 id="区域名字服务器维护资源记录">区域名字服务器维护资源记录</h3>
<p>资源记录</p>
<ul>
<li>作用：维护域名-IP地址（其他）的映射关系</li>
<li>位置：Name Server的分布式数据库中</li>
</ul>
<p>RR格式</p>
<ul>
<li>Domain_name：域名</li>
<li>Ttl: time to live：生存时间，就是某个资源记录插入到表当中，生存时间是多少；根据Ttl是否无穷大，记录划分为权威记录和缓冲记录</li>
<li>Class类别：对于Internet，值为IN</li>
<li>Value：可以是数字，域名或ASCII串</li>
<li>Type类别：资源记录的类型</li>
</ul>
<h3 id="dns记录">DNS记录</h3>
<p><font color=red>DNS</font>保存资源记录（<font color=red>RR</font>）的分布式数据库</p>
<blockquote>
<p>RR 格式：(domain_name, ttl, type,class,Value)</p>
</blockquote>
<table>
<thead>
<tr>
<th>Type类型</th>
<th>Name的含义</th>
<th>Value的含义</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>主机</td>
<td>ip地址</td>
<td></td>
</tr>
<tr>
<td>CNAME</td>
<td>别名</td>
<td>规范名字</td>
<td><a href="http://www.ibm.xn--comservereast-ko1ux19dbv0acn6hh90bu20a.backup2.ibm.com">www.ibm.com的规范名字为servereast.backup2.ibm.com</a></td>
</tr>
<tr>
<td>NS</td>
<td>域名(<a href="http://xn--foo-eo8e.com">如foo.com</a>)</td>
<td>该域名的权威服务器的名字</td>
<td>NAME仅仅具体到了域名，还没有到主机</td>
</tr>
<tr>
<td>MX</td>
<td>邮件</td>
<td>name对应的邮件服务器的名字</td>
<td></td>
</tr>
</tbody>
</table>
<p>TTL：生存时间，决定了资源记录应当从缓存中删除的时间</p>
<p>例子：<br>
<img src="/images/wl_12_3.png" alt=""></p>
<h3 id="dns">DNS</h3>
<p>DNS大致工作过程</p>
<ul>
<li>应用调用解析器</li>
<li>解析器作为客户向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文</li>
</ul>
<p><img src="/images/wl_12_4.png" alt=""></p>
<h3 id="本地名字服务器">本地名字服务器</h3>
<ul>
<li>并不严格属于层次机构</li>
<li>每个ISP（居民的ISP、公司、大学）都有一个本地DNS服务器
<ul>
<li>也称为“默认名字服务器”</li>
</ul>
</li>
<li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器
<ul>
<li>起着代理的作用，将查询结果转发到层次结构中</li>
</ul>
</li>
</ul>
<h3 id="名字服务器">名字服务器</h3>
<p>名字解析过程</p>
<ul>
<li>目标名字在Local Name Server中
<ul>
<li>情况1：查询的名字在该区域内部</li>
<li>情况2：缓存</li>
</ul>
</li>
</ul>
<p>当本地名字服务器不能解析名字时，联系根名字服务器顺着根-TLD一直找到权威名字服务器</p>
<p><img src="/images/wl_12_5.png" alt=""></p>
<h3 id="递归查询">递归查询</h3>
<p><font color=red>递归查询</font></p>
<ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
<li>问题：根服务器的负担太重</li>
<li>解决：迭代查询</li>
</ul>
<p><img src="/images/wl_12_6.png" alt=""></p>
<h3 id="迭代查询">迭代查询</h3>
<ul>
<li><a href="http://xn--cis-g88dt65i.poly.edu">主机cis.poly.edu</a> 想知道主机 <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a> 的IP地址</li>
<li>根（及各级域名）服务器返回的不是查询结果，而 是下一个NS的地址</li>
<li>最后由权威名字服务器给出解析结果</li>
<li>当前联络的服务器给出可以联系的服务器的名字</li>
<li>“我不知道这个名字，但可以向这个服务器请求”</li>
</ul>
<p><img src="/images/wl_12_7.png" alt=""></p>
<h3 id="dns协议-报文">DNS协议、报文</h3>
<p>DNS协议：<font color=red>查询和响应</font>报文的<font color=red>报文格式相同</font><br>
<img src="/images/wl_12_8.png" alt=""></p>
<h3 id="提高性能：缓存">提高性能：缓存</h3>
<ul>
<li>一旦名字服务器学到了一个映射，就将该映射缓存起来</li>
<li>根服务器通常都在本地服务器中缓存着
<ul>
<li>使得根服务器不用经常被访问</li>
</ul>
</li>
<li>目的：提高效率</li>
<li>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</li>
<li>解决方案：TTL（默认两天）</li>
</ul>
<h2 id="问题3：维护问题：新增一个域">问题3：维护问题：新增一个域</h2>
<ul>
<li>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址<br>
（Type = NS、 Type = A 相当于指针）</li>
<li>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析:名字-&gt;IP地址
<ul>
<li>例子:在com域中建立一个“Network Utopia”</li>
</ul>
</li>
<li><a href="http://xn--networkutopia-he1va63x07l7qs6z2ekhb685dda4847c0m2g.com">到注册登记机构注册域名networkutopia.com</a>
<ul>
<li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字和IP地址</li>
<li>登记机构在com TLD服务器中插入两条RR记录:
<ul>
<li>(<a href="http://networkutopia.com">networkutopia.com</a>,<a href="http://dns1.networkutopia.com">dns1.networkutopia.com</a>,NS )</li>
<li>(<a href="http://dns1.networkutopia.com">dns1.networkutopia.com</a>,212.212.212.1,A)</li>
</ul>
</li>
</ul>
</li>
<li>在networkutopia.com的权威服务器中确保有
<ul>
<li>用于Web服务器的www.networkuptopia.com的类型为A的记录</li>
<li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里以添加为例，删改查是一样的</p>
</blockquote>
<h3 id="攻击dns">攻击DNS</h3>
<p>DDoS 攻击</p>
<ul>
<li>对根服务器进行流量轰炸攻击：发送大量ping
<ul>
<li>没有成功</li>
<li>原因１：根目录服务器配置 了流量过滤器，防火墙</li>
<li>原因２：Local DNS 服务器 缓存了TLD服务器的IP地址, 因此无需查询根服务器</li>
</ul>
</li>
<li>向TLD服务器流量轰炸攻击 ：发送大量查询
<ul>
<li>可能更危险</li>
<li>效果一般，大部分DNS缓存了TLD</li>
</ul>
</li>
</ul>
<p>重定向攻击</p>
<ul>
<li>中间人攻击
<ul>
<li>截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点</li>
</ul>
</li>
<li>DNS中毒
<ul>
<li>发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果</li>
</ul>
</li>
<li>技术上较困难：分布式截获和伪造</li>
</ul>
<p>利用DNS基础设施进行DDoS</p>
<ul>
<li>伪造某个IP进行查询， 攻击这个目标IP</li>
<li>查询放大，响应报文比查询报文大</li>
<li>效果有限</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——13P2P应用</title>
    <url>/2024/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9413P2P%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1>P2P应用</h1>
<h2 id="纯p2p架构">纯P2P架构</h2>
<ul>
<li>没有（或极少）一直运行额服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用peer的服务能力</li>
<li>Peer节点间歇上网，每次IP地址都有可能变化</li>
</ul>
<p>例子：</p>
<ul>
<li>文件分发</li>
<li>流媒体</li>
<li>VoIP</li>
</ul>
<h2 id="文件分发：c-s-vs-p2p">文件分发：C/S vs P2P</h2>
<p><font color=red><em>问题</em></font>：从一台服务器分发文件（大小F）到N个Peer需要多少时间</p>
<ul>
<li>Peer节点上下载能力是有限的资源</li>
</ul>
<p><img src="/images/wl_13_1.png" alt=""></p>
<h3 id="文件分发时间：c-s模式">文件分发时间：C/S模式</h3>
<ul>
<li><font color=red><em>服务器传输</em></font>：都是由服务器发送给peer，服务器必须顺序传输（上载）N个文件拷贝：
<ul>
<li>发送一个copy：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">F/u_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>发送N个copy：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>F</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">NF/u_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li><font color=red><em>客户端</em></font>：每个客户端必须下载一个文件拷贝
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">d_{min} =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>客户端最小的下载速度</li>
<li>下载带宽最小的客户端下载的时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi mathvariant="normal">/</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F/d_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>采用C/S方法将一个F大小的文件分发给N个客户端耗时： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>c</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_{c/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> max{NF/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">u_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,F/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>}</li>
</ul>
<h3 id="文件分发时间：p2p模式">文件分发时间：P2P模式</h3>
<ul>
<li><font color=red><em>服务器传输</em></font>：最少需要上载一份拷贝
<ul>
<li>发送一个拷贝的时间：F/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">u_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li><font color=red><em>客户端</em></font>：每个客户端必须下载一个拷贝
<ul>
<li>最小下载带宽客户单耗时：F/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li><font color=red><em>客户端</em></font>：所有客户端总体下载量NF：
<ul>
<li>最大上载带宽是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">u_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>除了服务器可以上载，其他所有的peer节点都可以上载</li>
</ul>
</li>
<li>采用P2P方法将一个F大小的文件分发给N个客户端耗时：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>p</mi><mn>2</mn><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_{p2p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> max{F/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">u_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,NF/(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">u_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)}</li>
<li>分子随着N线性变化，每个节点需要下载，整体下载量随着N增大；分母也是如此,随着peer节点的增多，每个peer也带了服务能力</li>
</ul>
<p><img src="/images/wl_13_2.png" alt=""></p>
<h3 id="p2p文件共享">P2P文件共享</h3>
<p><font color=red>例子</font></p>
<ul>
<li>Alice在其笔记本电脑上 运行P2P客户端程序</li>
<li>间歇性地连接到 Internet，每次从其 ISP得到新的IP地址</li>
<li>请求“双截棍.MP3”</li>
<li>应用程序显示其他有“ 双截棍.MP3” 拷贝的对 等方</li>
<li>Alice选择其中一个对等方， 如Bob.</li>
<li>文件从Bob’s PC传送到 Alice的笔记本上：HTTP</li>
<li>当Alice下载时，其他用户也 可以从Alice处下载</li>
<li>Alice的对等方既是一个Web 客户端，也是一个瞬时Web 服务器</li>
</ul>
<p>所有的对等方都是服务器 = 可扩展性好</p>
<h2 id="p2p：集中式目录">P2P：集中式目录</h2>
<p>最初的“Napster”设计就是这个架构</p>
<ul>
<li>当对等方连接时，它告知中心服务器：
<ul>
<li>IP地址</li>
<li>内容</li>
</ul>
</li>
<li>Alice查询 “双截棍 .MP3” ，服务器返回Bob拥有这个文件</li>
<li>Alice从Bob处请求文件</li>
</ul>
<p><img src="/images/wl_13_3.png" alt=""></p>
<h3 id="p2p：集中式目录中存在的问题">P2P：集中式目录中存在的问题</h3>
<ul>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>侵犯版权</li>
</ul>
<blockquote>
<p>文件传输是分散的，而定位内容是高度集中的</p>
</blockquote>
<h2 id="查询洪泛：gnutella">查询洪泛：Gnutella</h2>
<ul>
<li>全分布式
<ul>
<li>没有中心服务器</li>
</ul>
</li>
<li>开放文件共享协议</li>
<li>许多<strong>Gnutella</strong>客户端实现了<strong>Gnutella</strong>协议
<ul>
<li>类似<strong>HTTP</strong>有许多的浏览器</li>
</ul>
</li>
</ul>
<p><font color=red>覆盖网络：图</font></p>
<ul>
<li>如果X和Y之间有一个TCP连接，则二者之间存在一条边</li>
<li>所有活动的对等方和边就是覆盖网络</li>
<li>边并不是物理链路</li>
<li>给定一个对等方，通常所连接的节点少于 10 个</li>
</ul>
<h3 id="gnutella：协议">Gnutella：协议</h3>
<ul>
<li>在已有的TCP连接上发送查询报文</li>
<li>对等方转发查询报文</li>
<li>以反方向返回查询命中报文</li>
</ul>
<blockquote>
<p>可拓展性：限制范围的洪泛查询<br>
<img src="/images/wl_13_4.png" alt=""></p>
</blockquote>
<h3 id="gnutella：对等方加入">Gnutella：对等方加入</h3>
<ul>
<li>对等方X必须首先发现某些已经覆盖在网络中的其他对等方：使用可用对等方列表
<ul>
<li>自己维持一张对等方列表（经常开机的对等方的IP）</li>
<li>联系维持列表二Gnutella结点</li>
</ul>
</li>
<li>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</li>
<li>X向Y发送一个Ping报文，Y转发该Ping报文</li>
<li>所有收到Ping报文的对等方以Ping报文格式响应
<ul>
<li>IP地址，共享文件的数量及总字节数</li>
</ul>
</li>
<li>X收到许多Ping报文然后它能建立其他TCP连接</li>
</ul>
<h2 id="利用不匀称性：kazaa">利用不匀称性：KaZaA</h2>
<ul>
<li>每个对等方要么是一个组长，要么隶属与一个组长
<ul>
<li>对等方与其组长之间有TCP连接</li>
<li>组长对之间有TCP连接</li>
</ul>
</li>
<li>组长跟踪其所有的孩子的内容</li>
<li>组长与其他组长联系
<ul>
<li>转发查询到其他组长</li>
<li>获得其他组长的数据拷贝</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_13_5.png" alt=""></p>
<h3 id="kazaa：查询">KaZaA：查询</h3>
<ul>
<li>每个文件有一个散列标识码和一个描述符</li>
<li>客户端向其组长发送关键字查询</li>
<li>组长用匹配进行相应：
<ul>
<li><font color=red>对每个匹配：元数据、散列标识码和IP地址</font></li>
</ul>
</li>
<li>如果组长将查询转发给其他组长，其他组长也以匹配进行相应</li>
<li>客户端选择要下载的文件
<ul>
<li><font color=red>向拥有文件的对等方发送一个带散列标识码的HTTP请求</font></li>
</ul>
</li>
</ul>
<h2 id="p2p文件分发：bittorrent">P2P文件分发：BitTorrent</h2>
<ul>
<li>文件被分为一个个块256KB</li>
<li>网路中的这些peers发送接收文件块，相互服务</li>
</ul>
<p><img src="/images/wl_13_6.png" alt=""></p>
<p>Peer加入torrent：</p>
<ul>
<li>一开始没有块，但是将会通过其他节点处理积累文件块</li>
<li>向跟踪服务器注册，获得peer节点列表，和部分peer节点构成邻居关系（“连接”）</li>
</ul>
<blockquote>
<ul>
<li>当peer下载时，该peer可以同时向其他节点提供上载服务</li>
<li>Peer可能会变换用于交换块的peer节点</li>
<li><font color=red><em>扰动churn</em></font>：peer节点可能会上线或者下线</li>
<li>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</li>
</ul>
</blockquote>
<h3 id="bittorrent：请求-发送文件块">BitTorrent：请求，发送文件块</h3>
<p><font color=red><em>请求块</em></font>：</p>
<ul>
<li>在任何给定时间，不同peer节点拥有一个文件块的子集</li>
<li>周期性的，Alice节点向邻居询问他们拥有哪些块的信息</li>
<li>Alice向peer节点请求他希望的块，稀缺的块</li>
</ul>
<p><font color=red><em>发送块：一报还一报 tit-for-tat</em></font></p>
<ul>
<li>Alice向4个peer发送块，这些块向他自己提供最大带宽的服务
<ul>
<li>其他peer被Alice阻塞（将不会从Alice处获得服务）</li>
<li>每10秒重新评估一次：前4位</li>
</ul>
</li>
<li>每隔30秒，随机选择其他peer节点，向这个节点发送块
<ul>
<li>“优化疏通”这个节点</li>
<li>新选择的节点可以加入这个top 4</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——14CDN</title>
    <url>/2024/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9414CDN/</url>
    <content><![CDATA[<h1>CDN</h1>
<h2 id="视频流化服务和cdn：上下文">视频流化服务和CDN：上下文</h2>
<ul>
<li>视频流量：占据着互连网大部分的带宽
<ul>
<li>Netflix，YouTube：占据37%，16%的下行流量</li>
</ul>
</li>
<li>挑战：规模性-如何服务~1B用户？
<ul>
<li>单个超级服务器无法提供服务（为什么）</li>
</ul>
</li>
<li>挑战：异构性
<ul>
<li>不同用户拥有不同的能力</li>
</ul>
</li>
<li><font color=red><em>解决方案</em></font>：分布式的，应用层面的基础设施</li>
</ul>
<h2 id="多媒体：视频">多媒体：视频</h2>
<ul>
<li>视频：固定速度显示的图像序列</li>
<li>网络视频特点：
<ul>
<li>高码率：&gt;10x于音频,高的网络带宽需求</li>
<li>可以被压缩</li>
<li>90%%以上的网络流量是视频</li>
</ul>
</li>
<li>数字化图像：像素的阵列
<ul>
<li>每个像素被若干bits表示</li>
</ul>
</li>
<li>编码：使用图像内和图像间的冗余来降低编码的比特数
<ul>
<li>空间冗余（图像内）</li>
<li>时间冗余（相邻的图像间）<br>
<img src="/images/wl_14_1.png" alt=""></li>
</ul>
</li>
</ul>
<p>编码方式：</p>
<ul>
<li><font color=red>CBR</font>：以固定速率编码</li>
<li><font color=red>VBR</font>：视频编码速率随时间的变化而变化</li>
</ul>
<h2 id="多媒体流化服务：dash">多媒体流化服务：DASH</h2>
<ul>
<li>服务器：
<ul>
<li>将视频文件分割成多个块</li>
<li>每个块独立存储，编码于不同码率（8-10种）</li>
<li>告示文件：提供不同块的URL</li>
</ul>
</li>
<li>客户端
<ul>
<li>先获取告示文件</li>
<li>周期性的测量服务器到客户端的带宽</li>
<li>查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围
<ul>
<li>如果带宽足够，选择最大的码率的视频块</li>
<li>会话中的不同时刻，可以切换请求不同的编码块（取决于当时的可用带宽）</li>
</ul>
</li>
</ul>
</li>
<li>智能客户端：客户端自适应决定
<ul>
<li><font color=red>什么时候</font>请求块（不至于缓存挨饿或者溢出）</li>
<li>请求<font color=red>什么编码速率</font>的视频块（当带宽足够用时，请求高质量的视频块）</li>
<li><font color=red>哪里</font>去请求块（可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求）</li>
</ul>
</li>
</ul>
<h2 id="cdn">CDN</h2>
<ul>
<li><font color=red><em>挑战</em></font>：服务器如何通过网络向上百万用户同时流化视频内容</li>
<li><font color=red><em>选择1</em></font>：单个的、大的超级服务中心&quot;mega-server&quot;
<ul>
<li>服务器到客户端路径上跳数越多，瓶颈链路的带宽小导致停顿</li>
<li>“二八规律”决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、贷款浪费、效果差）</li>
<li>单点故障点，性能瓶颈</li>
<li>周边网络的拥塞</li>
</ul>
</li>
</ul>
<blockquote>
<p>评述：相当简单，但是这个方法<font color=red>不可拓展</font></p>
</blockquote>
<ul>
<li>
<p><font color=red><em>选择2</em></font>：通过<font color=red>CDN</font>，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p>
<ul>
<li><em>enter deep</em>：将CDN服务器深入到许多接入网
<ul>
<li>更接近用户、数量多、离用户近、管理困难</li>
<li>Akamai，1700个位置</li>
</ul>
</li>
<li><em>bring home</em>：部署在少数（10个左右）关键位置，如将服务器蔟安装于POP附近（离若干<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mrow><mi>s</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">1^{st}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7935559999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span></span>ISP POP较近）
<ul>
<li>采用租用线路将服务器蔟连接起来</li>
<li>Limelight</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CDN：在CDN节点中存储内容的多个拷贝</p>
</li>
<li>
<p>用户从CDN种请求内容：</p>
<ul>
<li>重定向到最近的拷贝，请求内容</li>
</ul>
</li>
</ul>
<p>Netflix的例子:<br>
<img src="/images/wl_14_2.png" alt=""></p>
<h3 id="cdns">CDNs</h3>
<p><img src="/images/wl_14_3.png" alt=""></p>
<p>OTT挑战：在拥塞的互联网上复制内容</p>
<ul>
<li>从哪个CDN节点中获取内容</li>
<li>用户在网络拥塞时的行为</li>
<li>在哪些CDN节点中存储什么内容</li>
</ul>
<h3 id="cdn：-简单-内容访问场景">CDN：“简单”内容访问场景</h3>
<ul>
<li>Bob(客户端)请求视频http://netcinema.com/6Y7B23V-</li>
<li>视频存储在CDN，位于http://KingCDN.com/NetC6y&amp;B23V</li>
<li>下图中的authorative是权威服务器</li>
</ul>
<p><img src="/images/wl_14_4.png" alt=""></p>
<h3 id="netflix案例">Netflix案例</h3>
<p><img src="/images/wl_14_5.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——15套接字编程</title>
    <url>/2024/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9415%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1>套接字编程</h1>
<h2 id="socket编程">Socket编程</h2>
<p>Socket编程：应用进程使用传输层提供的服务才能够交换报文，实现应用协议，实现应用<br>
TCP/IP：应用进程使用Socket API访问传输服务<br>
地点：界面上的SAP<br>
方式：Socket API</p>
<p><font color=red>目标</font>：学习如何构建能借助sockets进行通信的C/S应用程序<br>
<font color=red>socke</font>：分布式应用进程之间的门，传输层协议提供的端到端服务接口</p>
<p><img src="/images/wl_15_1.png" alt=""></p>
<p>2种传输层服务的socket类型</p>
<ul>
<li>TCP：可靠的、字节流的服务</li>
<li>UDP：不可靠（数据UDP数据报）服务</li>
</ul>
<h3 id="tcp套接字编程">TCP套接字编程</h3>
<p><font color=red>套接字</font>：应用进程与端到端传输协议(TCP或UDP）之间的门户<br>
<font color=red>TCP服务</font>：从一个进程向另一个进程可靠的传输字节流</p>
<p><font color=red>服务器首先运行，等待连接建立</font><br>
服务器进程必须先处于运行状态</p>
<ul>
<li>创建欢迎socket</li>
<li>和本地端口捆绑</li>
<li>在欢迎socket上阻塞式等待接受用户的连接</li>
</ul>
<p><font color=red>客户端主动和服务器建立连接</font><br>
创建客户端本地套接字（<font color=red>隐式捆绑</font>到本地port）</p>
<ul>
<li>指定服务器进程的IP地址和端口号，与服务器进程连接</li>
</ul>
<p>当与客户端连接请求到来时</p>
<ul>
<li>服务器接受来自客户端的请求，接触阻塞式等待，返回一个新的socket（与欢迎socket不一样），与客户端通信
<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用的IP和源端口来区分不同的客户端</li>
</ul>
</li>
</ul>
<p>连接API调用有效时，客户端P与服务器之间建立了TCP连接</p>
<p><font color=red>从应用程序的角度</font><br>
TCP在客户端和服务器进程之间提供了可靠的、字节流（管道）服务</p>
<h3 id="c-s模式的应用样例">C/S模式的应用样例</h3>
<ul>
<li>客户端从标准输入装置读取一行字符，发送给服务器</li>
<li>服务器从socket读取字符</li>
<li>服务器将字符串装换成大写，然后返回给客户端</li>
<li>客户端从socket种读取一行字符，然后打印出来</li>
</ul>
<p>实际上，这里描述了C-S之间交互的动作次序</p>
<h3 id="数据结构sockaddr-in">数据结构sockaddr_in</h3>
<p><font color=red>IP地址和port捆绑关系的数据结构（标示进程的端节点）</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socketaddr_in</span>&#123;</span></span><br><span class="line">    <span class="type">short</span> sin_family;   <span class="comment">//AF_INET</span></span><br><span class="line">    u_short sin_port;   <span class="comment">//port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">//IP address unsigned long</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">//align</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sin_family</td>
<td>地址簇，这个结构体不仅仅用于IP的通信，还可以用于其他的通信，这里设置为常量AF_INET，表明是TCP/IP的协议簇</td>
</tr>
<tr>
<td>sin_port</td>
<td>端口号</td>
</tr>
<tr>
<td>sin_addr</td>
<td>ip地址</td>
</tr>
<tr>
<td>sin_zero</td>
<td>起对其作用，因为ipx的地址长度比ip的长度，其他地址也是</td>
</tr>
</tbody>
</table>
<h3 id="数据结构hostent">数据结构hostent</h3>
<p><font color=red>域名和IP地址的数据结构</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span> </span><br><span class="line">    <span class="type">char</span> *h_name;	<span class="comment">//域名</span></span><br><span class="line">    <span class="type">char</span> **h_aliases;	<span class="comment">//别名</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;	</span><br><span class="line">    <span class="type">int</span> h_length; <span class="comment">//地址长度</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list;	<span class="comment">//IP地址</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h_name</td>
<td>字符串</td>
<td>主机域名</td>
</tr>
<tr>
<td>h_aliases</td>
<td>字符串数组</td>
<td>主机的一系列别名</td>
</tr>
<tr>
<td>h_addrtype</td>
<td></td>
<td></td>
</tr>
<tr>
<td>h_length</td>
<td>数字</td>
<td>地址长度</td>
</tr>
<tr>
<td>h_addr_list</td>
<td>字符串数组</td>
<td>ip地址，可以将其复制到sockaddr_in的ip中</td>
</tr>
</tbody>
</table>
<p>作为调用域名解析函数时的参数 返回后，将IP地址拷贝到 sockaddr_in的IP地址部分</p>
<h3 id="c-s-socket交互：tcp">C/S socket交互：TCP</h3>
<p><img src="/images/wl_15_2.png" alt=""></p>
<h3 id="例子：c客户端-tcp">例子：C客户端（TCP）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// sad表示 server addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server */</span></span><br><span class="line">    <span class="type">int</span> clientSocket; <span class="comment">/* socket descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span></span><br><span class="line">    <span class="type">char</span> Sentence[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> modifiedSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//	argv[0]是程序的名字</span></span><br><span class="line">    host = argv[<span class="number">1</span>]; <span class="comment">// argv[1] 表示服务器的域名</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]); <span class="comment">// argv[2]表示服务端的端口</span></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这里底层自动使用了bind</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sad先清0</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span></span><br><span class="line">    <span class="comment">// port先转换成短整形，然后设置成网络次序</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);</span><br><span class="line">    ptrh = gethostbyname(host);</span><br><span class="line">    <span class="comment">/* Convert host name to IP address */</span></span><br><span class="line">    <span class="comment">//将IP地址拷贝到sad.sin_addr</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length);</span><br><span class="line">    connect(clientSocket, (<span class="keyword">struct</span> sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line"></span><br><span class="line">    gets(Sentence); <span class="comment">// get input stream from client</span></span><br><span class="line">    n=write(clientSocket, Sentence, <span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>); <span class="comment">// send line to server</span></span><br><span class="line">    n=read(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence)); <span class="comment">// read line from server</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n&quot;</span>,modifiedSentence);</span><br><span class="line">    close(clientSocket);  <span class="comment">// close the connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子：c服务器-tcp">例子：C服务器（TCP）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 只有一个参数，就是服务端的端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/*client */</span></span><br><span class="line">    <span class="type">int</span> welcomeSocket, connectionSocket; <span class="comment">/* socket descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span></span><br><span class="line">    <span class="type">char</span> clientSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> capitalizedSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">// port</span></span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    welcomeSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span></span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span></span><br><span class="line">    <span class="comment">// 此处赋值，在表中进行赋值</span></span><br><span class="line">    bind(welcomeSocket, (<span class="keyword">struct</span> sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// specify the maximum number of clients that can be queued</span></span><br><span class="line">    listen(welcomeSocket, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            connectionSocket=accept(welcomeSocket, (<span class="keyword">struct</span> sockaddr *)&amp;cad, &amp;alen);</span><br><span class="line">            n=read(connectionSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence));</span><br><span class="line">            <span class="comment">// capitalize Sentence and store the result in capitalizedSentence</span></span><br><span class="line">            n=write(connectionSocket, capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>);</span><br><span class="line">            close(connectionSocket);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="udp-socket编程">UDP Socket编程</h2>
<p><font color=red>UDP在客户端和服务器之间没有连接</font></p>
<ul>
<li>没有握手</li>
<li>发送端在每一个报文中明确地指明目标的IP地址和端口号</li>
<li>服务器必须从收到的分组中提取出发送端的IP地址和端口号</li>
</ul>
<p><font color=red>传送的数据可能乱序，也可能丢失</font></p>
<p><font colore=red>进程视角看UDP服务</font><br>
UDP为客户端和服务器提供不可靠的字节组的传送服务</p>
<h3 id="c-s交互：udp">C/S交互：UDP</h3>
<p><img src="/images/wl_15_3.png" alt=""></p>
<h3 id="例子：c客户端">例子：C客户端</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address */</span></span><br><span class="line">    <span class="type">int</span> clientSocket; <span class="comment">/* socket descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span></span><br><span class="line">    <span class="type">char</span> Sentence[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> modifiedSentence[<span class="number">128</span>];</span><br><span class="line">    host = argv[<span class="number">1</span>]; port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* determine the server&#x27;s address */</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);</span><br><span class="line">    ptrh = gethostbyname(host);</span><br><span class="line">    <span class="comment">/* Convert host name to IP address */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length);</span><br><span class="line">    gets(Sentence);</span><br><span class="line">    addr_len =<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    n=sendto(clientSocket, Sentence, <span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>, (<span class="keyword">struct</span> sockaddr *) &amp;sad, addr_len);</span><br><span class="line">    n=recvfrom(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence),(<span class="keyword">struct</span> sockaddr *) &amp;sad, &amp;addr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n&quot;</span>,modifiedSentence);</span><br><span class="line">    close(clientSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子：c服务器">例子：C服务器</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">int</span> serverSocket; <span class="comment">/* socket descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span></span><br><span class="line">    <span class="type">char</span> clientSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> capitalizedSentence[<span class="number">128</span>];</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    serverSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span></span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span></span><br><span class="line">    bind(serverSocket, (<span class="keyword">struct</span> sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        n=recvfrom(serverSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence), <span class="number">0</span></span><br><span class="line">                   (<span class="keyword">struct</span> sockaddr *) &amp;cad, &amp;addr_len );</span><br><span class="line">        <span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span></span><br><span class="line">        n=sendto(serverSocket , capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>,</span><br><span class="line">                 (<span class="keyword">struct</span> sockaddr *) &amp;cad, &amp;addr_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——16概述和传输层服务</title>
    <url>/2024/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9416%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1>概述和传输层服务</h1>
<h2 id="传输服务与协议">传输服务与协议</h2>
<ul>
<li>为运行在不同主机上的应用进程提供<font color=red>逻辑通信</font></li>
<li>传输协议运行在端系统
<ul>
<li>发送方：将应用层的报文分成<font color=red>报文段</font>，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供应用选择
<ul>
<li>Internet：TCP和UDP</li>
</ul>
</li>
</ul>
<h2 id="传输层-vs-网络层">传输层 vs 网络层</h2>
<ul>
<li>网络层服务：主机之间的逻辑通信</li>
<li>传输层服务：进程间的逻辑通信
<ul>
<li>依赖于网络层的服务
<ul>
<li>延时、带宽</li>
</ul>
</li>
<li>并对网络层的服务进行增强
<ul>
<li>数据丢失、顺序混乱，加密</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><font color=red>有些服务是可以加强的：不可靠 -&gt; 可靠：安全<br>
但有些服务是不可以被加强的：带宽，延迟</font></p>
<h2 id="internet传输协议">Internet传输协议</h2>
<ul>
<li>可靠的、保序的传送：TCP
<ul>
<li>多路复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li>不可靠、不保序的传输：UDP
<ul>
<li>多路复用</li>
<li>没有为尽力而为的IP服务添加更多的其他额外服务</li>
</ul>
</li>
<li>都不提供的服务
<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——17多路复用和解复用</title>
    <url>/2024/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9417%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E8%A7%A3%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1>多路复用和解复用</h1>
<h2 id="多路复用-解复用">多路复用/解复用</h2>
<p><font color=red>在发送方主机多路复用</font><br>
从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装（连头部信息用于以后的解复用）</p>
<p><font color=red>在接收方主机多路解复用</font><br>
根据报文段的头部信息中的IP地址和端口号接收到的报文段发给正确的套接字（和对应的应用进程）</p>
<h2 id="多路解复用工作原理">多路解复用工作原理</h2>
<ul>
<li>解复用原理
<ul>
<li>TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程</li>
</ul>
</li>
<li>主机收到IP数据报
<ul>
<li>每个数据报有源IP地址和目标地址</li>
<li>每个数据包承载一个传输层报文段</li>
<li>每个报文段有一个源端口号和目标端口号（特定应用有著名的端口号）</li>
</ul>
</li>
<li>主机联合使用<font color=red>IP地址和端口号</font>将报文段发送给合适的套接字</li>
</ul>
<p><img src="/images/wl_17_1.png" alt=""></p>
<h2 id="无连接-udp-多路解复用">无连接（UDP）多路解复用</h2>
<ul>
<li>在接收端，UDP套接字用二元组标识(<font color=red>目标IP地址、目标端口号</font>)</li>
<li>当主机接收到UDP段时：
<ul>
<li>检查UDP段中的目标端 口号</li>
<li>将UDP段交给具备那个端口号的套接字</li>
</ul>
</li>
<li>如果两个不同源IP地址/源端口号的数据报，但是<font color=red>有相同的目标IP地址和端口号</font>，则被定位到相同的套接字</li>
</ul>
<h2 id="面向连接-tcp-的多路解复用">面向连接（TCP）的多路解复用</h2>
<ul>
<li>TCP套接字:四元组本 地标识：
<ul>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ul>
</li>
</ul>
<p>解复用：接收主机用 这四个值来将数据报 定位到合适的套接字</p>
<ul>
<li>服务器能够在一个TCP端口上同时支持多个TCP套接字：
<ul>
<li>每个套接字由其四元组标识（有不同的源IP和源PORT）</li>
</ul>
</li>
<li>Web服务器对每个连接客户端有不同的套接字
<ul>
<li>非持久对每个请求有不同的套接字</li>
</ul>
</li>
</ul>
<h2 id="无连接的解复用：例子">无连接的解复用：例子</h2>
<p><img src="/images/wl_17_2.png" alt=""></p>
<p><img src="/images/wl_17_3.png" alt=""></p>
<h2 id="面向连接的解复用：例子">面向连接的解复用：例子</h2>
<p><img src="/images/wl_17_4.png" alt=""></p>
<p><img src="/images/wl_17_5.png" alt=""></p>
<p><img src="/images/wl_17_6.png" alt=""></p>
<p><img src="/images/wl_17_7.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——18无连接传输UDP</title>
    <url>/2024/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9418%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93UDP/</url>
    <content><![CDATA[<h1>无连接传输UDP</h1>
<h2 id="udp">UDP</h2>
<ul>
<li>“尽力而为的”服务，报文段可能
<ul>
<li>丢失</li>
<li>送到应用进程的报文段乱序</li>
</ul>
</li>
<li><font color=red>无连接</font>
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立的处理</li>
</ul>
</li>
<li>UDP被用于
<ul>
<li>流媒体</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li>在UDP上实现可靠传输
<ul>
<li><font color=red>在应用层增加可靠性</font></li>
<li><font color=red>应用特定的差错格式</font></li>
</ul>
</li>
</ul>
<h2 id="udp：用户数据报协议">UDP：用户数据报协议</h2>
<p><font color=red>为什么要有UDP</font></p>
<ul>
<li>不建立连接（会增加延时）</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li><font color=red>报文段的头部很小（开销小）</font></li>
<li><font color=red>无拥塞控制和流量控制</font>：UDP可以尽可能快的发送报文段
<ul>
<li>应用 -&gt; 传输的速率 = 主机 -&gt; 网格的速率</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_18_1.png" alt=""></p>
<h2 id="udp校验和">UDP校验和</h2>
<p><font color=red>目标</font>：检测在被传输报文段中的差错（如比特反转）</p>
<p><font color=red>发送方</font></p>
<ul>
<li>将报文段的内容视为16比特的整数</li>
<li>校验和：报文段的加法和（1的补运算）</li>
<li>发送方将校验和放在UDP的校验和字段</li>
</ul>
<p><font color=red>接收方</font></p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查计算出的校验和与校验和字段的内容是否相等
<ul>
<li>不相等——检测到差错</li>
<li>相等：没有检测到差错 ，但也许还是有差错 (残存错误，未检测出来)</li>
</ul>
</li>
</ul>
<h2 id="internet校验和的例子">Internet校验和的例子</h2>
<ul>
<li>注意：当数字相加时，在最高位的进位要回卷（加到最低位上），再加到结果上</li>
</ul>
<p><img src="/images/wl_18_2.png" alt=""></p>
<ul>
<li>目标端：校验范围+校验和=1111111111111111 通过校验
<ul>
<li>否则没有通过校验</li>
</ul>
</li>
<li>注：求和时，必须将进位回卷到结果上（进位回滚）</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——19可靠数据传输的原理</title>
    <url>/2024/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9419%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1>可靠数据传输的原理</h1>
<h2 id="可靠数据传输的原理">可靠数据传输的原理</h2>
<ul>
<li>rdt在应用层、传输层和数据链路层都很重要</li>
<li>是网络Top 10问题之一</li>
</ul>
<p><img src="/images/wl_19_1.png" alt=""></p>
<blockquote>
<p>信道的不可靠特点决定了可靠数据传输协议的复杂性</p>
</blockquote>
<h2 id="可靠数据传输：问题描述">可靠数据传输：问题描述</h2>
<p><img src="/images/wl_19_2.png" alt=""></p>
<p><font color=red>我们将</font>：</p>
<ul>
<li>渐增式的开发可靠数据传输协议的发送方和接收方</li>
<li>只考虑单项数据传输
<ul>
<li>但控制信息是双向流动的</li>
</ul>
</li>
<li>双向的数据传输问题实际上是2个单项数据传输问题的综合</li>
<li>使用有限状态机（FSM）来描述发送方和接收方</li>
</ul>
<p><img src="/images/wl_19_3.png" alt=""></p>
<p><font color=red>状态</font>：在该状态时，下一个状态只由下一个事件唯一确定</p>
<h2 id="rdt1-0-在可靠信道上的可靠数据传输">Rdt1.0:在可靠信道上的可靠数据传输</h2>
<ul>
<li>下层的信道是完全可靠的
<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li>发送方和接收方的FSM
<ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_19_4.png" alt=""></p>
<h2 id="rdt2-0">Rdt2.0</h2>
<h3 id="rdt2-0：具有比特差错的信道">Rdt2.0：具有比特差错的信道</h3>
<ul>
<li>下层信道可能会出错：将分组中的比特翻转
<ul>
<li>用校验和来检测比特差错</li>
</ul>
</li>
<li>问题：怎样从差错中恢复
<ul>
<li><font color=red>确认（ACK）</font>：接收方显式的告诉发送方分组已被正确接收</li>
<li><font color=red>否定确认（NAK）</font>：接收方显式的告诉发送方分组发生了差错
<ul>
<li>发送方接收到NAK后，发送方重传分组</li>
</ul>
</li>
</ul>
</li>
<li>rdt2.0的新机制：采用差错控制编码进行差错检测
<ul>
<li>发送方差错控制编码：缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK、NAK）：接收方 -&gt; 发送方</li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
</ul>
<h3 id="rdt2-0：fsm描述">Rdt2.0：FSM描述</h3>
<p><img src="/images/wl_19_5.png" alt=""></p>
<h3 id="流程">流程</h3>
<p><img src="/images/wl_19_6.png" alt=""></p>
<h3 id="rdt2-0的致命缺陷-rdt2-1">rdt2.0的致命缺陷 -&gt; rdt2.1</h3>
<p><font color=red>如果ACK/NAK出错</font></p>
<ul>
<li>发送方不知道接收方发生了什么事情</li>
<li>发送方如何做
<ul>
<li>重传可能重复</li>
<li>不重传可能死锁</li>
</ul>
</li>
<li>需要引入新的机制
<ul>
<li>序号</li>
</ul>
</li>
</ul>
<p><font color=red>处理重复</font></p>
<ul>
<li>发送方在每个分组中加入序号</li>
<li>如果ACK/NAK出错，发送方<font color=red>重传</font>当前分组</li>
<li>接收方丢弃（不发给上层）重复分组</li>
</ul>
<p><font color=red>停等协议</font><br>
发送方发送一个分组，然后等待接收方的应答</p>
<h2 id="rdt2-1">rdt2.1</h2>
<h3 id="rdt2-1：发送方处理出错的ack-nak">rdt2.1：发送方处理出错的ACK/NAK</h3>
<p><img src="/images/wl_19_7.png" alt=""></p>
<h3 id="rdt2-1：接收方">rdt2.1：接收方</h3>
<p><img src="/images/wl_19_8.png" alt=""></p>
<h3 id="rdt2-1：讨论">rdt2.1：讨论</h3>
<p><font color=red>发送方</font>：</p>
<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了
<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测ACK/NAK是否出错（需要EDC）</li>
<li>状态数变成了两倍
<ul>
<li>必须记住当前分组的序列号是0还是1</li>
</ul>
</li>
</ul>
<p><font color=red>接收方</font></p>
<ul>
<li>必须检测接收到的分组是否是重复的
<ul>
<li>状态会指示希望接收到的分组序号是0还是1</li>
</ul>
</li>
</ul>
<p><font color=red>注意</font>：接收方并不知道发送方是否正确收到了ACK/NAK</p>
<ul>
<li>没有安排确认的确认</li>
</ul>
<h3 id="rdt2-1的运行">rdt2.1的运行</h3>
<p><img src="/images/wl_19_9.png" alt=""></p>
<p>接收方不知道他最后发送的ACK/NAK是否被正确的收到</p>
<ul>
<li>发送方不对收到的ack/nak给确认，<font color=red>没有所谓的确认的确认</font></li>
<li>发送方发送ack，如果后面接收方收到的是：
<ul>
<li>老分组p0，则ack错误</li>
<li>下一个分组p1，则ack正确</li>
</ul>
</li>
</ul>
<h2 id="rdt2-2">rdt2.2</h2>
<h3 id="rdt2-2：无nak的协议">rdt2.2：无NAK的协议</h3>
<ul>
<li>功能同rdt2.1，但只是用ACK（Ack只要编号）</li>
<li>接收方对<font color=red>最后</font>正确接收的分组发ACK，以代替NAK
<ul>
<li>接收方必须显式的包含被正确分组的<font color=red>序号</font></li>
</ul>
</li>
<li>当收到重复的ACK时，发送方与收到NAK采取相同的动作，重传当前分组</li>
<li>为后面的一次发送多个数据单元做一个准备
<ul>
<li>一次能发送多个</li>
<li>每一个的应答都有：ACK，NACK：麻烦</li>
<li>使用对前一个数据单元的ACK，代替本数据单元的NAK</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
<h3 id="rdt2-2的运行">rdt2.2的运行</h3>
<p><img src="/images/wl_19_10.png" alt=""><br>
<img src="/images/wl_19_11.png" alt=""></p>
<h3 id="rdt2-2：发送方和接收方片段">rdt2.2：发送方和接收方片段</h3>
<p><img src="/images/wl_19_12.png" alt=""></p>
<h2 id="rdt3-0">Rdt3.0</h2>
<h3 id="rdt3-0：具有比特差错和分组丢失的通信">Rdt3.0：具有比特差错和分组丢失的通信</h3>
<p><font color-red>新的假设</font>:下层通道可能会丢失分组（数据或ACK）</p>
<ul>
<li>会死锁</li>
<li>机制还不够处理这种状况：
<ul>
<li>校验和</li>
<li>序列号</li>
<li>ACK</li>
<li>重传</li>
</ul>
</li>
</ul>
<p><font color=red>方法</font>：发送方等待ACK一段<font color=red>合理的时间</font></p>
<ul>
<li>发送端超时重传：如果到时没有收到ACK -&gt; 重传</li>
<li>问题：如果分组（或ACK）只是被延时了：
<ul>
<li>重传将会导致数据重复，但利用<font color=red>序列号</font>已经可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li>需要一个倒数计时器</li>
</ul>
<p>链路层的timeout时间确定的 （比较集中）<br>
传输层timeout时间是适应式的 （不太集中）</p>
<h3 id="rdt3-0的运行">rdt3.0的运行</h3>
<p><img src="/images/wl_19_13.png" alt=""></p>
<p><img src="/iamges/wl_19_14.png" alt=""></p>
<ul>
<li><font color=red>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的</font></li>
<li><font color=red>设置一个合理的超时时间也是比较重要的</font></li>
</ul>
<h3 id="rdt3-0的性能">rdt3.0的性能</h3>
<p>rdt3.0可以工作，但链路容量比较大的情况下，性能很差</p>
<ul>
<li>链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力</li>
</ul>
<p><img src="/images/wl_19_15.png" alt=""></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>s</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">U_{sender}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：利用率 – 忙于发送的时间比例<br>
每30ms发送1KB的分组 -&gt; 270kbps=33.75kB/s 的吞吐量（在1 Gbps 链路上）<br>
瓶颈在于：网络协议限制了物理资源的利用</p>
<h3 id="rdt3-0-停-等操作">rdt3.0 停-等操作</h3>
<p><img src="/images/wl_19_16.png" alt=""></p>
<h2 id="流水线协议">流水线协议</h2>
<h3 id="流水线：提高链路利用率">流水线：提高链路利用率</h3>
<p><img src="/images/wl_19_17.png" alt=""></p>
<h3 id="流水线协议">流水线协议</h3>
<p><font color=red>流水线</font>：允许发送方在<font color=red>未得到对方确认</font>的情况下一次发送<font color=red>多个</font>分组</p>
<ul>
<li>必须增加序号的范围:用多个bit表示分组的序号(用n位表示序号，那么序号的空间为2n)</li>
<li>在发送方/接收方要有缓冲区
<ul>
<li>发送方缓冲的作用：未得到确认，可能需要重传(以便于检错重发和超时重发)；</li>
<li>接收方缓存的作用：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_19_18.png" alt=""></p>
<p>两种通用的流水线协议：<font color=red>回退N步(GBN)</font>和<font color=red>选择重传(SR)</font></p>
<h3 id="通用：滑动窗口协议">通用：滑动窗口协议</h3>
<ul>
<li>发送缓冲区
<ul>
<li>形式：内存中的一个区域，落入缓冲区的分组可以发送</li>
<li>功能：用于存放已发送，但是没有得到确认的分组</li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组
<ul>
<li>停止等待协议=1</li>
<li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100%</li>
</ul>
</li>
<li>发送缓冲区中的分组
<ul>
<li>&lt;font color=red未发送的</font>：落入发送缓冲区的分组，可以连续发送出去；</li>
<li><font color=red>已经发送出去的、等待对方确认的分组</font>：发送缓冲区的分组只有得到确认才能删除</li>
</ul>
</li>
</ul>
<h4 id="发送窗口">发送窗口</h4>
<ul>
<li>发送窗口：发送缓冲区内容的一个范围
<ul>
<li>那些<font color=red>已发送</font>但是<font color=red>未经确认</font>分组的序号构成的空间</li>
</ul>
</li>
<li>发送窗口的最大值&lt;=发送缓冲区的值</li>
<li>一开始：没有发送任何一个分组
<ul>
<li>后沿=前沿</li>
<li>之间为发送窗口的尺寸=0</li>
</ul>
</li>
<li>每发送一个分组，前沿前移一个单位</li>
</ul>
<p><img src="/images/wl_19_19.png" alt=""></p>
<p><strong>发送窗口的移动 -&gt; 前沿移动</strong></p>
<ul>
<li>发送窗口前沿移动的极限：不能够超过发送缓冲区的大小</li>
</ul>
<p><img src="/images/wl_19_20.png" alt=""></p>
<p><strong>发送窗口滑动过程-相对表示方法</strong></p>
<ul>
<li>采用相对移动方式表示，分组不动</li>
<li>可缓冲范围移动，代表一段可以发送的权力</li>
</ul>
<p><img src="/images/wl_19_21.png" alt=""></p>
<p><strong>发送窗口的移动 -&gt; 后沿移动</strong><br>
发送窗口后沿移动</p>
<ul>
<li>条件：收到老分组的确认</li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送</li>
<li>移动的极限：不能够超过前沿</li>
</ul>
<p><img src="/images/wl_19_22.png" alt=""></p>
<p><img src="/images/wl_19_23.png" alt=""></p>
<h4 id="接收窗口">接收窗口</h4>
<p><strong>接收窗口 (receiving window) = 接收缓冲区</strong></p>
<ul>
<li>接收窗口用于控制哪些分组可以接收；
<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃；</li>
</ul>
</li>
<li>接收窗口尺寸Wr=1，则只能顺序接收；</li>
<li>接收窗口尺寸Wr&gt;1 ，则可以乱序接收
<ul>
<li>但提交给上层的分组，要按序</li>
</ul>
</li>
</ul>
<p>例子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">W_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>＝1，在0的位置；只有0号分组可以接收；向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃。</p>
<p><img src="/images/wl_19_24.png" alt=""></p>
<p><strong>接收窗口的滑动和发送确认</strong></p>
<ul>
<li>滑动：
<ul>
<li>低序号的分组到来，接收窗口移动；</li>
<li>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</li>
</ul>
</li>
<li>发送确认：
<ul>
<li>接收窗口尺寸=1 ； 发送连续收到的最大的分组确认（累计确认）</li>
<li>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认，比如发送ACK3表示收到3分组，但是并不代表2分组就收到了）</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_19_25.png" alt=""></p>
<p><img src="/images/wl_19_26.png" alt=""></p>
<h4 id="正常情况下2个窗口的互动">正常情况下2个窗口的互动</h4>
<p><img src="/images/wl_19_27.png" alt=""></p>
<h2 id="gbn协议">GBN协议</h2>
<h3 id="异常状态下gbn的2窗口互动">异常状态下GBN的2窗口互动</h3>
<ul>
<li>发送窗口
<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li>超时重发机制让发送端将发送窗口中的所有分组发送出去（就是将所有已发送但是未确认的分组都发送出去）</li>
<li>来了老分组的重复确认→后沿不向前滑动→新的分组无法落入发送缓冲区的范围团(此时如果发送缓冲区有新的分组可以发送)</li>
</ul>
</li>
<li>接收窗口
<ul>
<li>收到乱序分组，没有落入到接收窗口范界内，抛弃（假如现在接收窗口罩到了2，表明收到了1，但是收到了3，即收到乱序分组，则会抛弃3）</li>
<li>(重复）发送老分组的确认，累计确认（已经收到了1，此时会发送ACK1）</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_19_28.png" alt=""></p>
<h3 id="gbn协议和sr协议的异同">GBN协议和SR协议的异同</h3>
<ul>
<li>相同之处
<ul>
<li>发送窗口&gt;1</li>
<li>一次能够可发送多个 未经确认的分组</li>
</ul>
</li>
<li>不同之处
<ul>
<li>GBN :接收窗口尺寸=1
<ul>
<li>接收端：只能顺序接收</li>
<li>发送端：从表现来看，一旦一个 分组没有发成功，如：0,1,2,3,4 ; 假如1未成功，234都发送出去 了，<font color=red>要返回1再发送；GB1(go back 1)</font></li>
</ul>
</li>
</ul>
</li>
<li>SR: 接收窗口尺寸&gt;1
<ul>
<li>接收端：可以乱序接收</li>
<li>发送端：发送0,1,2,3,4，一旦1 未成功，2,3,4,已发送，无需重发，<font color=red>选择性发送1</font></li>
</ul>
</li>
</ul>
<h3 id="gbn-发送方拓展的fsm">GBN:发送方拓展的FSM</h3>
<p><img src="/images/wl_19_29.png" alt=""></p>
<h3 id="gbn：接收方拓展的fsm">GBN：接收方拓展的FSM</h3>
<p><img src="/images/wl_19_30.png" alt=""></p>
<ul>
<li>只发送ACK：对顺序接收的最高序号的分组
<ul>
<li>可能会产生重复的ACK</li>
<li>只需记住expectedseqnum；接收窗口=1
<ul>
<li>只一个变量就可表示接收窗口</li>
</ul>
</li>
</ul>
</li>
<li>对乱序的分组：
<ul>
<li>丢弃（不缓存）→ <font color=red>在接收方不被缓存</font></li>
<li>对顺序接收的最高序号的分组进行确认-累计确认</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_19_31.png" alt=""></p>
<p><img src="/images/wl_19_32.png" alt=""></p>
<h2 id="选择重传sr">选择重传SR</h2>
<ul>
<li>接收方对每个正确接收的分组，分别发送ACKn（非累积确认）
<ul>
<li>接收窗口&gt;1
<ul>
<li>可以缓存乱序的分组</li>
</ul>
</li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li>发送方只对那些没有收到ACK的分组进行重发-选择性重发
<ul>
<li>发送方为每个未确认的分组设定一个定时器</li>
</ul>
</li>
<li>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</li>
</ul>
<p>发送方：</p>
<ul>
<li><font color=red>从上层接受数据</font>
<ul>
<li>如果下一个可用于该分组的序号可在发送窗口中，则发送</li>
</ul>
</li>
<li><font color=red>timeout(n)</font>
<ul>
<li>重新发送分组n，重新设定定时器</li>
</ul>
</li>
<li><font color=red>ACK(n)</font> in [sendbase,sendbase+N]：
<ul>
<li>将分组n标记为已接收</li>
<li>如n为最小未确认的分组序号，将base移到下一个未确认序号</li>
</ul>
</li>
</ul>
<p>接收方：</p>
<ul>
<li><font color=red>分组n</font> [rcvbase, rcvbase+N-1]
<ul>
<li>发送ACK(n)</li>
<li>乱序：缓存</li>
<li>有序：该分组及以前缓存的序号连续的分组交付给上层，然后将窗口移到下一个仍未被接收的分组</li>
</ul>
</li>
<li><font color=red>分组n</font> [rcvbase-N, rcvbase-1]
<ul>
<li>ACK(n)</li>
</ul>
</li>
<li><font color=red>其它</font>：
<ul>
<li>忽略该分组</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_19_33.png" alt=""></p>
<h2 id="对比gbn和sr">对比GBN和SR</h2>
<table>
<thead>
<tr>
<th></th>
<th>GBN</th>
<th>SR</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>简单，所需资源少（接收方一个 缓存单元）</td>
<td>出错时，重传一个代价小</td>
</tr>
<tr>
<td>缺点</td>
<td>一旦出错，回退N步代价大</td>
<td>复杂，所需要资源多（接收方多个 缓存单元）</td>
</tr>
</tbody>
</table>
<p>适用范围</p>
<ul>
<li>出错率低：比较适合GBN，出错非常罕见，没有必 要用复杂的SR，为罕见的事件做日常的准备和复杂处理</li>
<li>链路容量大（延迟大、带宽大、出错率也就比较大）：比较适合SR而不 是GBN，一点出错代价太大</li>
</ul>
<h2 id="窗口的最大尺寸">窗口的最大尺寸</h2>
<p>假设用n bit表示序号，则发送窗口的最大尺寸如下（超过这个尺寸会出问题）</p>
<ul>
<li>GBN: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>SR:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
<p>例如：n=2; 序列号：0, 1, 2, 3</p>
<ul>
<li>GBN =3</li>
<li>SR=2</li>
</ul>
<p>SR的例子：</p>
<p><img src="/images/wl_19_34.png" alt=""></p>
<p>接收方看不到二者的区别<br>
将重复数据误认为新数据 (a)</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——20面向连接的传输：TCP</title>
    <url>/2024/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9420%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93%EF%BC%9ATCP/</url>
    <content><![CDATA[<h1>面向连接的传输：TCP</h1>
<h2 id="tcp：概述">TCP：概述</h2>
<p><font color=red>点对点</font></p>
<ul>
<li>一个发送方、一个接收方</li>
</ul>
<p><font color=red>可靠的、按顺序的字节流</font></p>
<ul>
<li>没有报文边界</li>
</ul>
<p><font color=red>管道化（流水线）</font></p>
<ul>
<li>TCP拥塞控制和流量控制设置窗口大小</li>
</ul>
<p><font color=red>发送和接收缓存</font></p>
<p><font color=red>全双工数据</font></p>
<ul>
<li>在同一连接中数据流双向流动</li>
<li>MSS：最大报文段大小</li>
</ul>
<p><font color=red>面向连接</font></p>
<ul>
<li>在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量</li>
</ul>
<p><font color=red>有流量控制</font></p>
<ul>
<li>发送方不会淹没接收方</li>
</ul>
<h2 id="tcp报文段结构">TCP报文段结构</h2>
<p><img src="/images/wl_20_1.png" alt=""></p>
<h3 id="tcp序号-确认号">TCP序号，确认号</h3>
<p><font color=red>序号</font></p>
<ul>
<li>报文段首字节的在字节流的编号</li>
</ul>
<p><font color=red>确认号</font></p>
<ul>
<li>期望从另一方收到的下一个字节的序号</li>
<li>累计确认</li>
</ul>
<p>接收方如何处理乱序的报文段-没有规定</p>
<p><img src="/images/wl_20_2.png" alt=""></p>
<h3 id="tcp往返延时-rtt-和超时">TCP往返延时（RTT）和超时</h3>
<p>怎样设置TCP超时</p>
<ul>
<li>比RTT要长
<ul>
<li>但RTT是变化的</li>
</ul>
</li>
<li>太短：太早超时
<ul>
<li>不必要的重传</li>
</ul>
</li>
<li>太长：对报文段丢失反应太慢，消极</li>
</ul>
<p>怎样估计RTT</p>
<ul>
<li><strong>SampleRTT</strong>：测量从报文段发出到收到确认的时间
<ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li><strong>SampleRTT</strong>会变化，因此估计的RTT应该比较平滑
<ul>
<li>对几个最近的测量值求平均，而不是仅用当前的<strong>SampleRTT</strong></li>
</ul>
</li>
</ul>
<h3 id="tcp序号和确认号">TCP序号和确认号</h3>
<p><img src="/images/wl_20_3.png" alt=""></p>
<h3 id="tcp往返延时和超时">TCP往返延时和超时</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>a</mi><mo>∗</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">EstimatedRTT = (1- a)*EstimatedRTT + a*SampleRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></p>
<ul>
<li>指数加权移动平均</li>
<li>过去样本的影响呈指数衰减</li>
<li>推荐值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0.125</mn></mrow><annotation encoding="application/x-tex">a = 0.125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span></span></span></span></li>
</ul>
<p><img src="/images/wl_20_4.png" alt=""></p>
<p><font color=red>设置超时</font></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">EstimtedRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> + 安全边界时间
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">EstimatedRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>变化大(方差大) → 较大的安全边界时间</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">SampleRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>会偏离<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">EstimatedRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>多远：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>β</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>−</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">DevRTT = (1-β)*DevRTT + β*|SampleRTT-EstimatedRTT|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">∣</span></span></span></span></li>
<li>推荐值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>0.25</mn></mrow><annotation encoding="application/x-tex">β = 0.25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span></span></span></span></li>
</ul>
</li>
</ul>
<p>超时时间间隔设置为：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mn>4</mn><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">TimeoutInterval = EstimatedRTT + 4*DevRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></li>
</ul>
<h2 id="tcp：可靠数据传输">TCP：可靠数据传输</h2>
<ul>
<li>TCP在IP不可靠服务的基础上建立了rdt
<ul>
<li>管道化的报文段
<ul>
<li>GBN or SR</li>
</ul>
</li>
<li>累计确认</li>
<li>单个重传定时器</li>
<li>是否可以接受乱序的，没有规范</li>
</ul>
</li>
<li>通过以下事件触发重传
<ul>
<li>超时（只重发那个最早的未确认段：SR）</li>
<li>重复的确认</li>
</ul>
</li>
<li>首先考虑简化的TCP发送方：
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<h3 id="tcp发送方-简化版">TCP发送方（简化版）</h3>
<p><img src="/images/wl_20_5.png" alt=""></p>
<h3 id="tcp发送方事件">TCP发送方事件</h3>
<p>&lt;font color=red从应用层接收数据</font>：</p>
<ul>
<li>用nextseq创建报文段</li>
<li>序号nextseq为报文段首字节的字节流编号</li>
<li>如果还没有运行，启动定时器
<ul>
<li>定时器与最早未确认的报文段关联（单个重传定时器）</li>
<li>过期间隔：TimeOutInterval</li>
</ul>
</li>
</ul>
<p><font color=red>超时</font>：</p>
<ul>
<li>重传后沿最老的报文段</li>
<li>重新启动定时器</li>
</ul>
<p><font color=red>收到确认</font>：</p>
<ul>
<li>如果是对尚未确认的报文段确认
<ul>
<li>更新已被确认的报文序号（后沿移动）</li>
<li>如果当前还有未被确认的报文段，重新启动定时器 (发完，就关掉定时器)</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_20_6.png" alt=""></p>
<h3 id="伪代码">伪代码</h3>
<p>上述操作的伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">NextSeqNum = InitialSeqNum</span><br><span class="line">SendBase = InitialSeqNum</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直循环</span></span><br><span class="line">loop (forever) &#123;</span><br><span class="line">	<span class="comment">// 判断事件</span></span><br><span class="line">	<span class="keyword">switch</span>(event)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果收到了应用层的数据</span></span><br><span class="line">    event: data received from application above</span><br><span class="line">    	<span class="comment">// 用NextSeqNum创建TCPsegment</span></span><br><span class="line">		create TCP segment with sequence number NextSeqNum</span><br><span class="line">		<span class="comment">// 如果定时器不在运行的话，开始</span></span><br><span class="line">		<span class="keyword">if</span> (timer currently not running)</span><br><span class="line">			start timer</span><br><span class="line">		<span class="comment">// 传给IP</span></span><br><span class="line">		pass segment to IP</span><br><span class="line">		<span class="comment">// 前沿移动</span></span><br><span class="line">		NextSeqNum = NextSeqNum + length(data)</span><br><span class="line"></span><br><span class="line">    event: timer timeout</span><br><span class="line">		retransmit not-yet-acknowledged segment with</span><br><span class="line">		smallest sequence number</span><br><span class="line">	start timer</span><br><span class="line"></span><br><span class="line">    event: ACK received, with ACK field value of y</span><br><span class="line">		<span class="keyword">if</span> (y &gt; SendBase) &#123;</span><br><span class="line">			SendBase = y</span><br><span class="line">			<span class="keyword">if</span> (there are currently not-yet-acknowledged segments)</span><br><span class="line">			start timer</span><br><span class="line">		&#125;</span><br><span class="line">&#125; <span class="comment">/* end of loop forever */</span></span><br></pre></td></tr></table></figure>
<p>注释：</p>
<ul>
<li>SendBase-1: 最后一个累积确认的字节</li>
<li>例：
<ul>
<li>SendBase-1 = 71；y= 73, 因此接收方期望73+ ; y是ACK的值</li>
<li>y &gt; SendBase，因此新的数据被确认</li>
</ul>
</li>
</ul>
<h3 id="tcp：重传">TCP：重传</h3>
<p><img src="/images/wl_20_7.png" alt=""></p>
<p><img src="/images/wl_20_8.png" alt=""></p>
<h3 id="接收方产生tcp-ack的建议">接收方产生TCP ACK的建议</h3>
<table>
<thead>
<tr>
<th>接收方的事件</th>
<th>TCP接收方动作</th>
<th>补充</th>
</tr>
</thead>
<tbody>
<tr>
<td>所期望序号的报文段按序到达。所有在期望序号之前的数据都已经被确认</td>
<td>延迟发送ACK（提高效率，少发一个ACK）。对另一个按序报文段的到达最多等待500ms。如果下一个报文段在这个时间间隔内没有到达，则发送一个ACK。</td>
<td>就是当接受到y0之后，不发送ACK=y0+1，而是当顺序接受到y1之后，发送ACK=y1+1注意必须是顺序接受到，如果是乱序，仍然请求y0+1,如果超时还未接受到，再发y0+1</td>
</tr>
<tr>
<td>有期望序号的报文段到达。 另一个按序报文段等待发送ACK</td>
<td>立即发送单个累积ACK，以确认两个按序报文段。</td>
<td>就是上一条说的情况</td>
</tr>
<tr>
<td>比期望序号大的报文段乱序到达。 检测出数据流中的间隔</td>
<td>立即发送重复的ACK，指明下一个期待字节的序号</td>
<td>如果收到了y0，然后乱序收到了y2，那么重新请求ACK=y0 + 1</td>
</tr>
<tr>
<td>能部分或完全填充接收数据间隔 的报文段到达</td>
<td>若该报文段起始于间隔（gap）的低端，则立即发送ACK（给确认。反映下一段的需求）。</td>
<td>请求ACK=y0+1，此时已经乱序收到了y2的内容请求之后得到的gap并不能填充y0到y2的空间，只能达到y1，因此重新请求ACK=y1 + 1</td>
</tr>
</tbody>
</table>
<h2 id="快速重传">快速重传</h2>
<ul>
<li>超时周期往往太长
<ul>
<li>在重传丢失报文段之前的延时太长</li>
</ul>
</li>
<li>通过&lt;font color=red重复</font>的ACK来检测 报文段丢失
<ul>
<li>发送方通常连续发送大量 报文段</li>
<li>如果报文段丢失，通常会引起多个重复的ACK</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_20_9.png" alt=""></p>
<ul>
<li>如果发送方收到同一数据 的3个冗余ACK，重传最 小序号的段：
<ul>
<li><font color=red>快速重传</font>：在定时器过时之前重发报文段</li>
<li>它假设跟在被确认的数据 后面的数据丢失了
<ul>
<li>第一个ACK是正常的；（比如第一个ACK=50，表明收到了49，是正常的，请求50）</li>
<li>收到第二个该段的ACK，表 示接收方收到一个该段后的乱序段； （因为再次请求50）</li>
<li>收到第3，4个该段的ack，表 示接收方收到该段之后的2个 ，3个乱序段，可能性非常大段丢失了</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/iamges/wl_20_10.png" alt=""></p>
<h3 id="快速重传算法">快速重传算法</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">event: ACK received, with ACK field value of y</span><br><span class="line">	<span class="title function_">if</span> <span class="params">(y &gt; SendBase)</span> &#123;</span><br><span class="line">		SendBase = y</span><br><span class="line">		<span class="keyword">if</span> (there are currently not-yet-acknowledged segments)</span><br><span class="line">			start timer</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">// 已确认报文段的一个重复确认</span></span><br><span class="line">		increment count of dup ACKs received <span class="keyword">for</span> y</span><br><span class="line">		<span class="keyword">if</span> (count of dup ACKs received <span class="keyword">for</span> y = <span class="number">3</span>) &#123;</span><br><span class="line">		resend segment with sequence number y  <span class="comment">// 快速重传</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tcp-流量控制">TCP 流量控制</h2>
<p>接收方控制发送方，不让发送方发送的太多、太快以至于让 接收方的缓冲区溢出</p>
<p><img src="/images/wl_20_11.png" alt=""></p>
<ul>
<li>接收方在其向发送方的TCP段 头部的rwnd字段“通告”其空闲buffer大小
<ul>
<li>RcvBuffer大小通过socket选项设置 (典型默认大小为4096 字节)</li>
<li>很多操作系统自动调整 RcvBuffer</li>
<li>发送方限制未确认(“inflight”)字节的个数≤接收 方发送过来的 rwnd 值</li>
</ul>
</li>
<li>保证接收方不会被淹没</li>
</ul>
<p><img src="/images/wl_20_12.png" alt=""></p>
<p><img src="/images/wl_20_13.png" alt=""></p>
<h2 id="tcp连接管理">TCP连接管理</h2>
<p>在正式交换数据之前，发送方和接收方握手建立通信关系:</p>
<ul>
<li>同意建立连接（每一方都知道对方愿意建立连接）</li>
<li>同意连接参数</li>
</ul>
<p><img src="/images/wl_20_14.png" alt=""></p>
<h3 id="同意建立连接">同意建立连接</h3>
<p><img src="/images/wl_20_15.png" alt=""></p>
<p>在网络中，2次握手建 立连接总是可行吗？</p>
<ul>
<li>变化的延迟（连接请求的段没有丢，但可能超时）</li>
<li>由于丢失造成的重传 (e.g. req_conn(x))</li>
<li>报文乱序</li>
<li>相互看不到对方</li>
</ul>
<p>以下是两次握手的问题：</p>
<ul>
<li>半连接</li>
<li>接受老数据问题</li>
</ul>
<p><img src="/images/wl_20_16.png" alt=""></p>
<p>三次握手<br>
<img src="/images/wl_20_17.png" alt=""></p>
<h3 id="三次握手解决：半连接和接收老数据问题">三次握手解决：半连接和接收老数据问题</h3>
<p><img src="/images/wl_20_18.png" alt=""></p>
<h3 id="tcp三次握手-fsm">TCP三次握手 FSM</h3>
<p><img src="/images/wl_20_19.png" alt=""></p>
<h2 id="tcp关闭连接">TCP关闭连接</h2>
<ul>
<li>客户端，服务器分别关闭它自己这一侧的连接
<ul>
<li>发送FIN bit = 1的TCP段</li>
</ul>
</li>
<li>一旦接收到FIN，用ACK回应
<ul>
<li>接到FIN段，ACK可以和它自己发出的FIN段一起发 送</li>
</ul>
</li>
<li>可以处理同时的FIN交换</li>
</ul>
<p><img src="/images/wl_20_20.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——21拥塞控制原理</title>
    <url>/2024/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9421%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1>拥塞控制原理</h1>
<h2 id="概述">概述</h2>
<p><font color=red>拥塞</font></p>
<ul>
<li>非正式的定义：“太多的数据需要网络传输，超过了网络的处理能力”</li>
<li>与流量控制不同</li>
<li>拥塞的表现
<ul>
<li>分组丢失（路由器缓冲区溢出）</li>
<li>分组经历比较长时间的延迟（在路由器的队列中排队）</li>
</ul>
</li>
<li>网络中前10位的问题</li>
</ul>
<h2 id="拥塞的原因-代价">拥塞的原因/代价</h2>
<h3 id="场景一：缓冲无限大-无重传">场景一：缓冲无限大、无重传</h3>
<ul>
<li>2个发送端，2个接收端</li>
<li>一个路由器，具备无限大的缓冲</li>
<li>输出链路带宽：R</li>
<li>没有重传</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">λ_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为输入的速率，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">λ_{out}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为输出的速率</li>
</ul>
<p><img src="/images/wl_21_1.png" alt=""></p>
<p><img src="/images/wl_21_2.png" alt=""></p>
<ul>
<li>每个连接的最大吞吐量：R / 2</li>
<li>当进入的速率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">λ_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>接近链路带宽R时，延迟增大</li>
</ul>
<h3 id="场景二：缓冲有限-有重传">场景二：缓冲有限，有重传</h3>
<ul>
<li>一个路由器，有限的缓冲</li>
<li>分组丢失时，发送端重传
<ul>
<li>应用层的输入 = 应用层的输出：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><msub><mi>λ</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">λ_{in} = λ_{out}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>传输层的输入包括重传：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>λ</mi><mrow><mi>i</mi><mi>n</mi></mrow><msup><mrow></mrow><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></msubsup><mo>≥</mo><msub><mi>λ</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">λ^{&#x27;&#x27;}_{in} \geq λ_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.201144em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<p><img src="/images/wl_21_3.png" alt=""></p>
<p><strong>理想化：发送端有完美的信息</strong><br>
发送端知道什么时候路由器的缓冲是可用的</p>
<ul>
<li>只在缓冲可用时发送</li>
<li>不会丢失<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>λ</mi><mrow><mi>i</mi><mi>n</mi></mrow><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msubsup><mo>=</mo><msub><mi>λ</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">λ^{&#x27;}_{in} = λ_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.201144em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p><img src="/images/wl_21_4.png" alt=""></p>
<p><img src="/images/wl_21_5.png" alt=""></p>
<p><strong>理想化：<font color=red>掌握丢失信息</font></strong><br>
分组可以丢失，在路由器由于缓冲器满而被丢弃</p>
<ul>
<li>如果发送端知道分组丢失了，发送方重传</li>
</ul>
<p><img src="/images/wl_21_6.png" alt=""></p>
<p><img src="/images/wl_21_7.png" alt=""></p>
<p><strong>现实情况：<font color=red>重复</font></strong></p>
<ul>
<li>分组可能丢失，由于缓冲器满而被丢弃</li>
<li>发送端最终<font color=red>超时</font>，发送第二个拷贝，2个分组都被传出</li>
</ul>
<p><img src="/images/wl_21_8.png" alt=""></p>
<p><strong><font color=red>拥塞的“代价”</font></strong></p>
<ul>
<li>为了达到一个有效输出，网络需要更多的输入速率（重传）</li>
<li>没有必要的重传（加剧了网络的拥塞），链路中包括了多个分组的拷贝
<ul>
<li>是那些没有丢失，经历的时间比较长（拥塞状态）但是超时的分组</li>
<li>降低了的“goodput”</li>
</ul>
</li>
</ul>
<h3 id="场景三：死锁">场景三：死锁</h3>
<p>四个发送端：A→D，D→A，B→C，C→B（就是AD，BC相互连接）</p>
<p><img src="/images/wl_21_9.png" alt=""></p>
<ul>
<li>当红色的增加时，所有到来的蓝色分组都在最上方的队列中丢弃了，蓝色吞吐-&gt;0</li>
<li>同理，绿色的也可能抢走红色的（在右边的路由器）</li>
<li>粉色的可能抢走绿色的（下边的路由器）</li>
<li>蓝色的抢走粉色的（左边的路由器）</li>
<li>总之，网络中有输入，但是没有输出</li>
</ul>
<p><img src="/images/wl_21_10.png" alt=""></p>
<p><strong><font color=red>又一个拥塞的“代价”</font></strong></p>
<ul>
<li>当分组丢失时，任何“关于这个分组的上游传输能力” 都被浪费了</li>
</ul>
<h2 id="拥塞控制方法">拥塞控制方法</h2>
<p>2种常用的拥塞控制方法:</p>
<ul>
<li><font color=red>端到端拥塞控制</font>
<ul>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件推断是否有拥塞</li>
<li>（TCP采用的方法）</li>
</ul>
</li>
<li><font color=red>网络辅助的拥塞控制</font>:
<ul>
<li>路由器提供给端系统以反馈信息</li>
<li>单个bit置位，显示有拥塞 (SNA, DECbit, TCP/IP ECN, ATM)</li>
<li>显式提供发送端可以采用的速率</li>
</ul>
</li>
</ul>
<h2 id="atm-abr拥塞控制">ATM ABR拥塞控制</h2>
<h3 id="atm网络">ATM网络</h3>
<p>ATM：异步传输网络，是物联网掺杂的网络</p>
<ul>
<li>数据传输单元(分组)是信元：53个字节，5个字节的头部，另外48个字节是数据部</li>
<li>分组很小（53个字节），而且是固定长度</li>
<li>所以在每个交换节点的存储转发时间很小而且可以控制</li>
<li>线路交换在数据交换节点的延迟是1bit的延迟，分组交换的延迟是1个分组的延迟</li>
<li>由于ATM的分组—信元大于1bit，但是远小于普通的一个分组，因此其延迟位于线路交换和分组交换之间</li>
<li>而且延迟时间固定(一位信元字节数固定)，而且容易调度</li>
<li>因此具有线路交换和分组交换的特性</li>
<li>ATM本来认为是很有希望的网络形式</li>
<li>后来因为网络技术比较复杂并没有流行开来</li>
<li>但是在一些专用网络，比如银行网络使用的还是比较多的</li>
</ul>
<p>ATM有很多模式，ABR是其中一个</p>
<h2 id="abr模式">ABR模式</h2>
<p>ABR: available bit rate:</p>
<ul>
<li>弹性服务：
<ul>
<li>如果网络轻载(不发送拥塞)，可以尽可能使用网络带宽</li>
<li>如果网络拥塞了 ，发送方限制其发送的速度到一个 最小保障速率 上</li>
</ul>
</li>
</ul>
<p>在ATM网络中有两种信元：数据信元(data cell)和资源信元(RM cell)<br>
RM (资源管理) 信元:</p>
<ul>
<li>由发送端发送,在数据信元中间隔插入</li>
<li>RM信元中的比特被交换机设置 (网络辅助)
<ul>
<li>NI bit: no increase in rate (轻微拥塞)速率不要增加了</li>
<li>CI bit: congestion indication 拥塞指示（表明已经拥塞了）</li>
</ul>
</li>
<li>发送端发送的RM 信元被接收端返回, 接收端不做任何 改变</li>
</ul>
<p><img src="/images/wl_21_11.png" alt=""></p>
<ul>
<li>
<p>数据信元中的EFCI bit: 被拥塞的交换机设置成1</p>
<ul>
<li>如果在管理信元RM前面的数据信元EFCI被设置成了1, 接收端在 返回的RM信元中设置CI bit</li>
<li>在RM信元中的2个字节 ER (explicit rate)字段 多大带宽</li>
</ul>
</li>
<li>
<p>拥塞的交换机可能会降低信元中ER的值（但是不会提高）</p>
<ul>
<li>发送端接受到的RM的ER字段表示路由器可以支持的最低的速率</li>
<li>发送端发送速度因此是最低的可支持速率</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——22TCP拥塞</title>
    <url>/2024/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9422TCP%E6%8B%A5%E5%A1%9E/</url>
    <content><![CDATA[<h1>TCP拥塞</h1>
<h2 id="tcp拥塞控制机制">TCP拥塞控制机制</h2>
<p><font color=red>端到端的拥塞控制机制</font></p>
<ul>
<li>路由器不向主机有关拥塞的反馈信息
<ul>
<li>路由器的负担较轻</li>
<li>符合网络核心简单的TCP/IP架构原则</li>
</ul>
</li>
<li>端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</li>
</ul>
<p><font color=red>拥塞控制的几个问题</font></p>
<ul>
<li>如何检测拥塞
<ul>
<li>轻微拥塞</li>
<li>拥塞</li>
</ul>
</li>
<li>控制策略
<ul>
<li>在拥塞发送时如何动作，降低速率
<ul>
<li>轻微拥塞，如何降低</li>
<li>拥塞时，如何降低</li>
</ul>
</li>
<li>在拥塞缓解时如何动作，增加速率</li>
</ul>
</li>
</ul>
<h2 id="tcp拥塞感知">TCP拥塞感知</h2>
<p><font color=red>发送端如何探测到拥塞</font></p>
<ul>
<li>某个段超时了（丢失事件 ）：<font color=red>拥塞</font>
<ul>
<li>超时时间到，某个段的确认没有来</li>
<li>原因1：<font color=red>网络拥塞</font>（某个路由器缓冲区没空间了，被丢弃）<font color=red>概率大</font></li>
<li>原因2：<font color=red>出错被丢弃了</font>（各级错误，没有通过校验，被丢弃）<font color=red>概率小</font></li>
<li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_22_1.png" alt=""></p>
<ul>
<li>有关某个段的3次重复ACK：轻微拥塞
<ul>
<li>段的第1个ack，正常，确认绿段，期待红段</li>
<li>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达</li>
<li>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了 ，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了， 红段都没到）</li>
<li>网络这时还能够进行一定程度的传输，拥塞但情况要比上面好</li>
</ul>
</li>
</ul>
<h2 id="tcp速率控制方法">TCP速率控制方法</h2>
<p><font color=red>如何控制发送端发送的速率</font></p>
<ul>
<li>维持一个拥塞窗口的值(主要手段) ：CongWin （表示发送方往网络中的注入字节数）</li>
<li>发送端限制 已发送但是未确认 的数据量（的上限）: LastByteSent - LastByteAcked ≤ CongWin</li>
<li>从而粗略地控制发送方的往网络中注入的速率</li>
</ul>
<p><img src="/images/wl_22_2.png" alt=""></p>
<ul>
<li>CongWin是动态的，是感知到的网络拥塞程度的函数
<ul>
<li>超时或者3个重复ack，CongWin下降
<ul>
<li><font color=red>超时时</font>：CongWin降为1MSS，进入SS阶段然后再倍增到<font color=red> CongWin(原) / 2（每个RTT）</font>，从而进入CA阶段</li>
<li><font color=red>3个重复ack</font> ：CongWin降为<font color=red>CongWin/2</font>,CA阶段</li>
</ul>
</li>
<li>否则（正常收到Ack，没有发送以上情况）：CongWin跃跃欲试上升（这是为了满足“在不发生拥塞的情况下提高吞吐率”的目的）</li>
</ul>
</li>
</ul>
<h2 id="tcp拥塞控制和流量控制的联合动作">TCP拥塞控制和流量控制的联合动作</h2>
<p><font color=red>联合控制的方法</font></p>
<ul>
<li>发送端控制<em>发送但是未确认</em>的量同时也不能超过接收窗口，满足流量控制要求
<ul>
<li>SendWin = min { CongWin , RecvWin }</li>
<li>同时满足 拥塞控制和流量控制要求</li>
</ul>
</li>
</ul>
<h2 id="tcp慢启动">TCP慢启动</h2>
<ul>
<li>连接刚建立, CongWin = 1 MSS
<ul>
<li>如: MSS = 1460bytes &amp; RTT = 200 msec</li>
<li>初始速率 = 58.4kbps</li>
</ul>
</li>
<li>可用带宽可能 &gt;&gt; MSS/RTT
<ul>
<li>应该尽快加速，到达希望的速率</li>
</ul>
</li>
<li>当连接开始时，指数性增加发送速率，直到发生丢失的事件
<ul>
<li>启动初值很低</li>
<li>但是速度很快</li>
</ul>
</li>
<li>当连接开始时，指数性增 加（每个RTT）发送速率 直到发生丢失事件
<ul>
<li>每一个RTT， CongWin加倍</li>
<li>每收到一个ACK时， CongWin加1（相当于每个RTT，CongWin加倍）</li>
<li>慢启动阶段：只要不超时或 3个重复ack，一个RTT， CongWin加倍</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_22_3.png" alt=""></p>
<ul>
<li>总结:
<ul>
<li>初始速率很慢，但是加速却是指数性的</li>
<li>指数增加，SS时间很短，长期来看可以忽略</li>
</ul>
</li>
</ul>
<h2 id="aimd">AIMD</h2>
<ul>
<li>乘性减: 丢失事件后将CongWin降为1(ss阶段通常可忽略，故相当于直接减少到 CongWin/2 )，将CongWin/2作为阈值，进入慢启动阶段（倍增直到 CongWin/2）</li>
<li>加性增： 当 CongWin &gt;阈值时，一个 RTT 如没有发生丢失事件，将 CongWin 加1MSS : 探测（也就是主键添加，探测是否到达阈值）</li>
</ul>
<p><img src="/images/wl_22_4.png" alt=""></p>
<p><strong>改进</strong></p>
<ul>
<li>Q：什么时候应该将指数性增长变成线性？</li>
<li>A：在超时之前，当CongWin变成上次发生超时的窗口的一半</li>
</ul>
<p><img src="/images/wl_22_5.png" alt=""></p>
<p><font color=red>实现</font>:</p>
<ul>
<li>变量：Threshold</li>
<li>出现丢失（超时或者3个ACK），Threshold设置成CongWin的1/2</li>
</ul>
<h2 id="总结：tcp拥塞控制">总结：TCP拥塞控制</h2>
<ul>
<li>当CongWin＜Threshold, 发送端处于慢启动阶段（ slow-start）, 窗口指数性增长.</li>
<li>当CongWin &gt; Threshold, 发送端处于拥塞避免阶段 （congestion-avoidance）, 窗口线性增长.</li>
<li>当收到三个重复的ACKs (triple duplicate ACK), Threshold设置成 CongWin/2， CongWin=Threshold+3.</li>
<li>当超时事件发生时timeout, Threshold=CongWin/2 CongWin=1 MSS，进入SS阶段</li>
</ul>
<h2 id="tcp发送端拥塞控制">TCP发送端拥塞控制</h2>
<table>
<thead>
<tr>
<th>事件</th>
<th>状态</th>
<th>TCP发送端行为</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>以前没有收到ACK的data，被ACKed</td>
<td>慢启动(SS)</td>
<td>CongWin = CongWin + MSS,If (CongWin &gt; Threshold)，状态变成“CA”</td>
<td>每一个RTT CongWin 加倍</td>
</tr>
<tr>
<td>以前没有收到ACK的data，被ACKed	拥塞避免(CA)</td>
<td>CongWin = CongWin+MSS * (MSS/CongWin)</td>
<td>线性增加, 每一个RTT对CongWin 加一个1 MSS</td>
<td></td>
</tr>
<tr>
<td>通过收到3个重复的ACK，发现丢失的事件</td>
<td>SS or CA</td>
<td>Threshold = CongWin/2, CongWin = Threshold+3, 状态变成“CA”</td>
<td>快速重传, 实现乘性的减，CongWin 没有变成1MSS.</td>
</tr>
<tr>
<td>超时</td>
<td>SS or CA</td>
<td>Threshold = CongWin/2,CongWin = 1 MSS,状态变成“SS”</td>
<td>进入slow start</td>
</tr>
<tr>
<td>重复的ACK</td>
<td>SS or CA</td>
<td>对被ACKed 的segment， 增加重复ACK的计数</td>
<td>CongWin and Threshold不变</td>
</tr>
</tbody>
</table>
<h2 id="tcp拥塞控制fsm">TCP拥塞控制FSM</h2>
<p><img src="/images/wl_22_6.png" alt=""></p>
<h2 id="tcp吞吐量">TCP吞吐量</h2>
<p>TCP的平均吞吐量是多少，使用窗口window尺寸W和RTT来 描述?<br>
(忽略慢启动阶段，假设发送端总有数据传输)</p>
<ul>
<li>W：发生丢失事件时的窗口尺寸（单位：字节）
<ul>
<li>平均窗口尺寸（#in-flight字节）：3/4W</li>
<li>平均吞吐量：一个RTT时间吞吐3/4W， avg TCP thruput = 3/4 * (W/RTT) bytes/sec<br>
由下图所示，w/2→w所需要的时间是2RTT</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_22_7.png" alt=""></p>
<p>因此 T = (w/2 + w) / (2*RTT) = 3w/4RTT</p>
<p><img src="/images/wl_22_8.png" alt=""></p>
<h2 id="tcp-公平性">TCP 公平性</h2>
<p>公平性目标: 如果 K个TCP会话分享一个链路带宽为R的 瓶颈，每一个会话的有效带宽为 R/K</p>
<p>2个竞争的TCP会话:</p>
<p><img src="/images/wl_22_9.png" alt=""></p>
<p><img src="/images/wl_22_10.png" alt=""></p>
<p><font color=red>公平性和 UDP</font></p>
<ul>
<li>多媒体应用通常不是用 TCP
<ul>
<li>应用发送的数据速率希望 不受拥塞控制的节制</li>
</ul>
</li>
<li>使用UDP:
<ul>
<li>音视频应用泵出数据的速率是恒定的, 忽略数据的丢失<br>
也就是UDP会抢占TCP的资源</li>
</ul>
</li>
</ul>
<p><font color=red>公平性和并行TCP连接</font></p>
<ul>
<li>2个主机间可以打开多个并行的TCP连接</li>
<li>例如: 带宽为R的链路支持了 9个连接;
<ul>
<li>如果新的应用要求建1个TCP连接,获得带宽R/10</li>
<li>如果新的应用要求建11个TCP连接,获得带宽R/2</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——23网络层导论</title>
    <url>/2024/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9423%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1>网络层导论</h1>
<h2 id="网络层服务">网络层服务</h2>
<ul>
<li>在发送主机和接收主机对之间传送<font color=red>段</font>（segment）</li>
<li>在发送端将段封装到数据报中</li>
<li>在接收端，将段上交给传输层实体</li>
<li>网络层协议存在于每一个主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报的头部</li>
</ul>
<h2 id="网络层的关键功能">网络层的关键功能</h2>
<p><font color=red>网络层功能</font></p>
<ul>
<li>转发: 将分组从路由器的输入接口转发到合适的输出接口</li>
<li>路由: 使用路由算法来决定分组从发送主机到目标接收主机的路径
<ul>
<li>路由选择算法</li>
<li>路由选择协议</li>
</ul>
</li>
</ul>
<h2 id="数据平面-控制平面">数据平面、控制平面</h2>
<p><font color=red>数据平面</font></p>
<ul>
<li>本地，每个路由器功能</li>
<li>决定从路由器输入端口到达的分组如何转发到输出端口</li>
<li>转发功能：
<ul>
<li>传统方式：基于目标 地址+转发表</li>
<li>SDN方式：基于多个字段+流表</li>
</ul>
</li>
</ul>
<p><font color=red>控制平面</font></p>
<ul>
<li>网络范围内的逻辑</li>
<li>决定数据报如何在路由器之间 路由，决定数据报从源到目标主机之间的端到端路径</li>
<li>2个控制平面方法:
<ul>
<li>传统的路由算法: 在路由器中被实现（功能单一：根据目标的IP地址进行转发）</li>
<li>software-defined networking (SDN): 在远程的服务器中实现（匹配很多字段，功能更多：泛洪、转发、修改字段）</li>
</ul>
</li>
</ul>
<h2 id="传统方式：每一路由器-per-router-控制平面">传统方式：每一路由器(Per-router)控制平面</h2>
<p>在<font color=red>每一个路由器</font>中的单独路由器算法元件，在控制平面进行交互</p>
<p><img src="/images/wl_23_1.png" alt=""></p>
<p><img src="/images/wl_23_2.png" alt=""></p>
<h2 id="sdn方式：逻辑集中的控制平面">SDN方式：逻辑集中的控制平面</h2>
<p>一个不同的（通常是远程的）控制器与本地控制代理（CAs） 交互</p>
<p><img src="/images/wl_23_3.png" alt=""></p>
<h2 id="网络服务模型">网络服务模型</h2>
<p>从发送方主机到接收方主机传输数据报的“通道” ，网络提供什么样的服务模型？</p>
<p><font color=red>对于单个数据报的服务</font>:</p>
<ul>
<li>可靠传送</li>
<li>延迟保证，如：少于 40ms的延迟</li>
</ul>
<p><font color=red>对于数据报流的服务</font>:</p>
<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组之间的延迟差（延迟差为0，那么发送就会立即接受到，对于多媒体来说很好）</li>
</ul>
<h2 id="连接建立">连接建立</h2>
<ul>
<li>在某些网络提供有连接的网络
<ul>
<li>ATM, frame relay, X.25</li>
</ul>
</li>
<li>在分组传输之前，在两个主机之间，在通过一些 路由器所构成的路径上建立一个网络层连接
<ul>
<li>涉及到路由器</li>
</ul>
</li>
<li>网络层和传输层连接服务区别:
<ul>
<li><font color=red>网络层</font>: 在2个主机之间，涉及到路径上的一些路由器 —— 有连接</li>
<li><font color=red>传输层</font>: 在2个进程之间，很可能只体现在端系统上 (TCP连接) —— 面向连接</li>
</ul>
</li>
</ul>
<h2 id="网络层服务模型">网络层服务模型</h2>
<table>
<thead>
<tr>
<th>网络架构</th>
<th>服务模型</th>
<th>是否保证带宽</th>
<th>是否保证丢失</th>
<th>是否保序</th>
<th>是否保证延迟</th>
<th>拥塞反馈</th>
</tr>
</thead>
<tbody>
<tr>
<td>Internet</td>
<td>best effort(尽力而为)</td>
<td>none</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no(inferred via loss)</td>
</tr>
<tr>
<td>ATM</td>
<td>CBR恒定速率</td>
<td>constant rate</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no congestion</td>
</tr>
<tr>
<td>ATM</td>
<td>VBR 变化速率</td>
<td>guaranteed rate</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no congestion</td>
</tr>
<tr>
<td>ATM</td>
<td>ABR 可用比特率</td>
<td>guaranteed rate</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>ATM</td>
<td>UBR 不指明比特率</td>
<td>one</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——24路由器组成</title>
    <url>/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9424%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<h1>路由器组成</h1>
<h2 id="路由器的结构概况">路由器的结构概况</h2>
<p>高层面(非常简化的)通用路由器体系架构</p>
<ul>
<li>路由：运行<font color=red>路由</font>选择算法／协议 (RIP, OSPF, BGP) - 生成 路由表</li>
<li>转发：从输入到输出链路交换数据报 - 根据路由表进行分组的<font color=red>转发</font></li>
</ul>
<p><img src="/images/wl_24_1.png" alt=""></p>
<h2 id="输入端口功能">输入端口功能</h2>
<p><img src="/images/wl_24_2.png" alt=""></p>
<p><strong>分布式交换</strong>：</p>
<ul>
<li>根据数据报（网络层分组）头部的信息如：目的地址，在输入端口内存中的转发表中查找合适的输出端口（匹配+行动）</li>
<li><font color=red>基于目标的转发</font>：仅仅依赖于IP数据报的目标IP地址（传统方法）</li>
<li><font color=red>通用转发</font>：基于头部字段的任意集合进行转发</li>
</ul>
<p>功能如下：</p>
<ul>
<li>物理层：链路上的数字信号（比如电信号、光信号等）转换成bit(有的是bit，有的是word)</li>
<li>数据链路层：将转换成的bit分成帧(判断哪里是帧头，哪里是帧尾)，检查有无出错，判断帧的目标Mac和网卡的Mac是否一致（判断是否接受这个帧），然后取出帧中的数据部分（也就是IP的分组，数据链路层将IP的分组包装成帧了）</li>
<li>数据链路层将IP分组交给网络层实体，网络层实体在链路当中排队，排到队头的按照路由表交给合适的端口输出</li>
<li>传统的IP分组是根据分组头部的目标ip，根据路由表来转发</li>
<li>如果是SDN，则会查头部的多个信息，匹配相应流表的字段，按照流标的操作</li>
</ul>
<h2 id="输入端口缓存">输入端口缓存</h2>
<ul>
<li>交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队
<ul>
<li><font color=red><em>排队延迟和由于输入缓存溢出造成丢失</em></font></li>
</ul>
</li>
<li><font color=red>Head-of-the-Line (HOL) blocking</font>: 排在队头的数据报 阻止了队列中其他数据报向前移动</li>
</ul>
<p><img src="/images/wl_24_3.png" alt=""></p>
<h2 id="交换结构">交换结构</h2>
<ul>
<li>将分组从输入缓冲区传输到合适的输出端口</li>
<li>交换速率：分组可以按照该速率从输入传输到输 出
<ul>
<li>运行速度经常是输入/输出链路速率的若干倍 (因为输入端口和输出端口有多个)</li>
<li>N 个输入端口：交换机构的交换速度是输入线路速度的N倍比较理 想，才不会成为瓶颈</li>
</ul>
</li>
</ul>
<p><strong>三种典型的交换机构</strong></p>
<p><img src="/images/wl_24_4.png" alt=""></p>
<h3 id="通过内存交换">通过内存交换</h3>
<p><font color=red>第一代路由器</font></p>
<ul>
<li>在CPU直接控制下的交换，采用传统的计算机（通过计算机的软件来实现）</li>
<li>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li>
<li>分组要过系统总线两次（input→memory，memory→output），因此系统总线成为了速率的瓶颈（转发速率被内存的带宽限制）</li>
<li>一次只能转发一个分组</li>
</ul>
<p><img src="/images/wl_24_5.png" alt=""></p>
<h3 id="通过总线交换">通过总线交换</h3>
<ul>
<li>数据报通过共享总线，从输入端转发到输出端口</li>
<li>分组加上输出端口的地址被送往总线，分组通过bus的时候所有的输出分组都能够读到，如果是本输出端口的地址就拿到</li>
<li><font color=red>总线竞争</font>: 交换速度受限于总线带宽</li>
<li>1次处理一个分组，分组只经过一次bus</li>
<li>1 Gbps bus, Cisco 1900； 32 Gbps bus, Cisco 5600；</li>
<li>对于接 入或企业级路由器，速度足够（ 但不适合区域或骨干网络）</li>
</ul>
<p><img src="/images/wl_24_6.png" alt=""></p>
<h3 id="通过互联网络-crossbar等-的交换">通过互联网络(crossbar等)的交换</h3>
<ul>
<li>同时并发转发多个分组，克服总线带宽限制</li>
<li>Banyan(榕树〉网络，crossbar(纵横)和其它的互联网络被开发，将多个处理器连接成多处理器</li>
<li>当分组从端口A到达，转给端口Y;控制器短接相应的两个总线</li>
<li>高级设计:将数据报分片为固定长度的信元，通过交换网络交换</li>
<li>Cisco12000:以60Gbps的交换速率通过互联网络</li>
</ul>
<p><img src="/images/wl_24_7.png" alt=""></p>
<h2 id="输出端口">输出端口</h2>
<p><img src="/iamges/wl_24_8.png" alt=""></p>
<ul>
<li>当数据报从交换机构的到达速度比传输速率快就需要输出端口<font color=red>缓存</font>（数据报（分组）可能会被丢弃，由于拥塞，缓冲区没有空间）</li>
<li>由<font color=red>调度规则</font>选择排队的数据报进行传输</li>
</ul>
<h3 id="输出端口排队">输出端口排队</h3>
<p><img src="/images/wl_24_9.png" alt=""></p>
<ul>
<li>假设交换速率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>s</mi><mi>w</mi><mi>i</mi><mi>t</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{switch}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{line}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的N倍（N：输入端口的数量）</li>
<li>当多个输入端口同时向输出端口发送时，缓冲该分组（当通 过交换网络到达的速率超过输出速率则缓存）</li>
<li><font color=red>排队带来延迟，由于输出端口缓存溢出则丢弃数据报</font></li>
</ul>
<h3 id="调度机制">调度机制</h3>
<ul>
<li><em><font color=red>调度</font></em>: 选择下一个要通过链路传输的分组</li>
</ul>
<h4 id="fifo-first-in-first-out-scheduling">FIFO (first in first out) scheduling</h4>
<ul>
<li>按照分组到来的次序发送</li>
<li>丢弃策略: 如果分组到达一个满的队列，哪个分组将会 被抛弃?
<ul>
<li>tail drop: 丢弃刚到达的分组</li>
<li>priority: 根据优先权丢失/移除分组（分组是有优先权的，比如有VIP）</li>
<li>random: 随机地丢弃/移除</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_24_10.png" alt=""></p>
<h4 id="优先权">优先权</h4>
<p><em><font color=red>优先权调度</font></em>：发送最高优先权的分组</p>
<ul>
<li>多类，不同类别有不同的 优先权
<ul>
<li>类别可能依赖于标记或者其 他的头部字段, e.g. IP source/dest, port numbers, ds，etc.</li>
<li>先传高优先级的队列中的分 组，除非没有</li>
<li>高（低）优先权中的分组传 输次序：FIFO</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_24_11.png" alt=""></p>
<h4 id="round-robin-rr-scheduling">Round Robin (RR) scheduling</h4>
<ul>
<li>多类</li>
<li>循环扫描不同类型的队列, 发送完一类的一个分组 ，再发送下一个类的一个分组，循环所有类</li>
</ul>
<p><img src="/images/wl_24_12.png" alt=""></p>
<h4 id="weighted-fair-queuing-wfq">Weighted Fair Queuing (WFQ)</h4>
<ul>
<li>一般化的Round Robin</li>
<li>在一段时间内，每个队列得到的服务时间是： Wi /(XIGMA(Wi )) *t ，和权重成正比</li>
<li>每个类在每一个循环中获得不同权重的服务量</li>
<li>现实例子</li>
</ul>
<p><img src="/images/wl_24_13.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——25Internet Protocol</title>
    <url>/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9425Internet-Protocol/</url>
    <content><![CDATA[<h1>Internet Protocol</h1>
<h2 id="互联网中的网络层">互联网中的网络层</h2>
<p>主机、路由器中的网络层功能</p>
<p><img src="/images/wl_25_1.png" alt=""></p>
<h2 id="ip数据报格式">IP数据报格式</h2>
<p><img src="/images/wl_25_2.png" alt=""></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ver</td>
<td>版本号，如Ipv4就是0100</td>
</tr>
<tr>
<td>head len</td>
<td>头部的长度，一般头部是20个字节(也就是上图中的5行)，但是也有可选项，也就是头部是变长的，因此可以使用head len来计算可选项</td>
</tr>
<tr>
<td>type of service</td>
<td>数据段的类型，本来为输出队列的调度机制提供参考的，但后来废弃了</td>
</tr>
<tr>
<td>length</td>
<td>数据报总厂</td>
</tr>
<tr>
<td>16-bit的id，flags fragment offset</td>
<td>后面的分片/重组</td>
</tr>
<tr>
<td>time to live（TTL）</td>
<td>可用以ICMP协议</td>
</tr>
<tr>
<td>upper layer</td>
<td>将负载交给的上层协议，比如说TCP，还是UDP，还是ICMP，实际上是根据端口号区分的</td>
</tr>
<tr>
<td>Internet checksum</td>
<td>校验头部的</td>
</tr>
</tbody>
</table>
<h2 id="ip分片和重组">IP分片和重组</h2>
<ul>
<li>网络链路有MTU (最大传输单元) –链路层帧所携带的最大数据长度
<ul>
<li>不同的链路类型</li>
<li>不同的MTU</li>
</ul>
</li>
<li>大的IP数据报在网络上被分片 (“fragmented”)
<ul>
<li>一个数据报被分割成若干个小 的数据报
<ul>
<li>相同的ID</li>
<li>不同的偏移量</li>
<li>最后一个分片标记为0</li>
</ul>
</li>
<li>“重组”只在最终的目标主机进行：减少路由器的负担，要是每个路由器都重组再分片压力太大</li>
<li>IP头部的信息被用于标识，排序相关分片</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_25_3.png" alt=""></p>
<p>例子：</p>
<p><img src="/images/wl_25_4.png" alt=""></p>
<ul>
<li>（接受到了）4000 字节数据报：
<ul>
<li>20字节头部</li>
<li>3980字节数据</li>
</ul>
</li>
<li>MTU = 1500 bytes
<ul>
<li>第一片：20字节头部+1480字节数据；偏移量：0</li>
<li>第二片：20字节头部+1480字节数据（1480字节应用数据）；偏移量：1480/8=185</li>
<li>第三片：20字节头部+1020字节数据（应用数据）；偏移量：2960/8=370</li>
</ul>
</li>
</ul>
<h2 id="ip编址：引论">IP编址：引论</h2>
<ul>
<li><font color=red>IP地址</font>: 32位标示，对主机或者路由器的接口编址</li>
<li><font color=red>接口</font>: 主机/路由器和物 理链路的连接处
<ul>
<li>路由器通常拥有多个接口</li>
<li>主机也有可能有多个接口</li>
<li>IP地址和每一个接口关联</li>
</ul>
</li>
<li><font color=red>一个IP地址和一个接口相关联</font></li>
</ul>
<p><img src="/images/wl_25_5.png" alt=""></p>
<p><img src="/images/wl_25_6.png" alt=""></p>
<h2 id="子网">子网</h2>
<ul>
<li>IP地址：
<ul>
<li>子网部分（高位bits）</li>
<li>主机部分（低位bits）</li>
</ul>
</li>
<li>什么是子网？
<ul>
<li>一个子网内的节点（主 机或者路由器）它们的<font color=red>IP地址的高位部分相同</font> ，这些节点构成的网络的一部分叫做子网</li>
<li>子网内节点的分组的收发<font color=red>无需路由器介入（借助交换机即可）</font>，子网内各主机可以在物理上相互直接到达 ——只需要交换机即可，一跳可达</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_25_7.png" alt=""></p>
<h3 id="划分子网方法">划分子网方法</h3>
<ul>
<li>要判断一个子网, 将每一个接口从主机或者路由 器上分开,构成了一个个网络的孤岛</li>
<li><font color=red>每一个孤岛（网络）都 是一个都可以被称之为 subnet</font>.</li>
</ul>
<p><img src="/images/wl_25_8.png" alt=""></p>
<h2 id="ip地址类型">IP地址类型</h2>
<h3 id="ip地址分类">IP地址分类</h3>
<p><img src="/images/wl_25_9.png" alt=""></p>
<h3 id="特殊ip地址">特殊IP地址</h3>
<ul>
<li>一些约定：
<ul>
<li>子网(网络)部分全为0，表示本网络</li>
<li>主机部分全为0，表示本主机</li>
<li>主机部分全为1表示，广播地址，这个网络的所有主机</li>
<li>除了前面的类号 全为1——在本地网络广播</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_25_10.png" alt=""></p>
<h3 id="内网-专用-ip地址">内网(专用)IP地址</h3>
<ul>
<li>专用地址：地址空间的一部份供专用地址使用</li>
<li>永远不会被当做公用地址来分配, 不会与公用地址重复</li>
<li>只在局部网络中有意义，区分不同的设备</li>
<li>路由器不对目标地址是专用地址的分组进行转发</li>
<li>专用地址范围</li>
</ul>
<table>
<thead>
<tr>
<th>IP类型</th>
<th>专用地址范围</th>
<th>MASK</th>
</tr>
</thead>
<tbody>
<tr>
<td>A类</td>
<td>10.0.0.0-10.255.255.255</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B类</td>
<td>172.16.0.0-172.31.255.255</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C类</td>
<td>192.168.0.0-192.168.255.255</td>
<td>255.255.255.0</td>
</tr>
</tbody>
</table>
<h3 id="cidr-无类域间路由">CIDR(无类域间路由)</h3>
<ul>
<li>子网部分可以在任意的位置（而不必是固定的位置）</li>
<li>地址格式: <font color=red>a.b.c.d/x</font>, 其中 x 是 地址中子网号的长度</li>
</ul>
<p>实例：</p>
<p><img src="/images/wl_25_11.png" alt=""></p>
<h3 id="转发表和转发算法">转发表和转发算法</h3>
<table>
<thead>
<tr>
<th>Destination Subnet Num</th>
<th>Mask</th>
<th>Next hop</th>
<th>Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>202.38.73.0</td>
<td>255.255.255.192</td>
<td>IPx</td>
<td>Lan1</td>
</tr>
<tr>
<td>202.38.64.0</td>
<td>255.255.255.192</td>
<td>IPy</td>
<td>Lan2</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Default</td>
<td></td>
<td>IPz</td>
<td>Lan0</td>
</tr>
</tbody>
</table>
<ul>
<li>获得IP数据报的目标地址IP Des addr</li>
<li>遍历转发表中的每一个表项
<ul>
<li>如 (IP Des addr) &amp; (mask) == destination, 则按照表项 对应的接口转发该数据报</li>
<li>如果都没有找到,则使用默认表项转发数据报，一般是整个网络的出口 default Gateway</li>
</ul>
</li>
</ul>
<h2 id="如何获得一个ip地址">如何获得一个IP地址</h2>
<ul>
<li>系统管理员将地址配置在一个文件中
<ul>
<li>Wintel: control-panel-&gt;network- &gt;configuration-&gt;tcp/ip-&gt;properties</li>
<li>UNIX: /etc/rc.config</li>
</ul>
</li>
<li>DHCP：从服务器中动态获取一个IP地址
<ul>
<li>“plug-and-play”</li>
</ul>
</li>
</ul>
<h3 id="dhcp-dynamic-host-configuration-protocol">DHCP: Dynamic Host Configuration Protocol</h3>
<p>目标:</p>
<ul>
<li>允许主机在加入网络的时候，动态地从服务器那里获得IP地址
<ul>
<li>可以更新对主机在用IP地址的租用期-租期快到了</li>
<li>重新启动时，允许重新使用以前用过的IP地址</li>
<li>支持移动用户加入到该网络（短期在网）</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_25_12.png" alt=""></p>
<p>DHCP工作概况:</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>含义</th>
<th>源地址</th>
<th>目标地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>主机上限时广播“DHCP discover”报文</td>
<td>问一下有活着的DHCP服务器吗</td>
<td>0.0.0.0,32全0的本机地址，因为此时还没有分配ip地址</td>
<td>255.255.255.255,（32位全1的广播地址，因为不知道DHCP服务在哪）</td>
</tr>
<tr>
<td>DHCP服务器用“DHCP offer”单播提供报文响应</td>
<td>DHCP服务器表明自己的存在；并且包含分配给主机的关于ip的配套信息(包括那四项)</td>
<td>DHCP服务器的地址</td>
<td>255.255.255.255,也是全局广播，根据事务号来区分</td>
</tr>
<tr>
<td>主机单播请求IP地址:发送“DHCP request”报文</td>
<td>主机向DHCP服务器确定ip配置信息</td>
<td>0.0.0.0,也是表示自己的地址</td>
<td>255.255.255.255,也是广播</td>
</tr>
<tr>
<td>DHCP服务器发送地址:“DHCP ack”报文</td>
<td>DHCP把配置信息给主机</td>
<td>DHCP服务器的地址</td>
<td>255.255.255.255,广播</td>
</tr>
</tbody>
</table>
<p><img src="/images/wl_25_13.png" alt=""></p>
<p>示例：</p>
<p><img src="/images/wl_25_14.png" alt=""></p>
<h3 id="机构获取ip子网部分">机构获取ip子网部分</h3>
<p>假设某个学校，有八个校区，要获取ip子网</p>
<ul>
<li>首先从ISP获取大的网络，ISP’s block 11001000 00010111 00010000 00000000 200.23.16.0/20</li>
<li>然后再划分，由于有8个校区，也就是要划分成8个部分，用原有的20位后面的3位来表示子网，从而进行划分</li>
</ul>
<h3 id="isp获取地址块">ISP获取地址块</h3>
<p>Q：一个ISP如何获得一个地址块?</p>
<p>A：向ICANN申请</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名，解决冲突</li>
</ul>
<h2 id="ip层次编址-路由聚集">IP层次编址/路由聚集</h2>
<h3 id="路由聚集">路由聚集</h3>
<p><img src="/images/wl_25_15.png" alt=""></p>
<h3 id="最长精确匹配">最长精确匹配</h3>
<p><img src="/images/wl_25_16.png" alt=""></p>
<h2 id="nat-网络地址转换">NAT: 网络地址转换</h2>
<h3 id="原理">原理</h3>
<p><img src="/images/wl_25_17.png" alt=""></p>
<p>特点:本地网络只有一个有效IP地址</p>
<p>NAT 路由器必须:</p>
<ul>
<li>外出数据包：替换源地址:端口号为 NAT的IP地址:新的端口号，目标IP和端口不变；远端的C/S将会用NAP IP地址，新端口号作为目标地址</li>
<li>记住每个转换替换对(映射)（在NAT转换表中）源IP:端口 vs NAP IP:新端口</li>
<li>进入数据包：替换目标IP地址和端口号，采用存储在NAT表中的mapping表项，用（源IP，端口）</li>
</ul>
<h3 id="流程">流程</h3>
<p><img src="/images/wl_25_18.png" alt=""></p>
<h3 id="优点">优点</h3>
<p>省钱：不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备<br>
可以在局域网改变设备的地址情况下而无须通知外界<br>
可以改变ISP（地址变化）而不需要改变内部的设备地址<br>
安全：局域网内部的设备没有明确的地址，对外是不可见的</p>
<h3 id="nat的争议和问题">NAT的争议和问题</h3>
<p>NAT能够篡改接受的分组的端口信息</p>
<ul>
<li>路由器只应该对第3层做信息处理，而这里对端口号（4层）作了处理</li>
<li>违反了end-to-end 原则
<ul>
<li>端到端原则：复杂性放到网络边缘
<ul>
<li>无需借助中转和变换，就可以直接传送到目标主机</li>
</ul>
</li>
<li>NAT可能要被一些应用设计者考虑, eg, P2P applications</li>
<li>外网的机器无法主动连接到内网的机器上</li>
</ul>
</li>
<li>问题，NAT穿越： 如果客户端需要连接在NAT后面的服务器，如何操作</li>
</ul>
<p>地址短缺问题可以被IPv6 解决（因为NAT一开始解决的就是地址短缺的问题）</p>
<h3 id="nat-穿越问题">NAT 穿越问题</h3>
<p><img src="/images/wl_25_19.png" alt=""></p>
<p>客户端需要连接地址为 10.0.0.1的服务器</p>
<ul>
<li>服务器地址10.0.0.1 LAN本地地址 (客户端不能够使用其作为目标地址)</li>
<li>整网只有一个外部可见地址: 138.76.29.7</li>
</ul>
<p><strong>静态配置NAT</strong><br>
方案1: 静态配置NAT：转发 进来的对服务器特定端口连接 请求</p>
<ul>
<li>(123.76.29.7, port 2500) 总是转发到10.0.0.1 port 25000</li>
</ul>
<p><strong>IGD/UPnP</strong><br>
方案2: Universal Plug and Play (UPnP) Internet Gateway Device (IGD) 协议. 允许 NATted主机可以: 动态分配端口</p>
<ul>
<li>获知网络的公共 IP地址 (138.76.29.7)</li>
<li>列举存在的端口映射</li>
<li>增/删端口映射 (在租用时间内)</li>
</ul>
<p><img src="/images/wl_25_20.png" alt=""></p>
<p><strong>中继</strong><br>
方案3：中继(used in Skype)</p>
<p><img src="/images/wl_25_21.png" alt=""></p>
<h2 id="ipv6协议">IPV6协议</h2>
<h3 id="目的">目的</h3>
<ul>
<li>初始动机: 32-bit地址空间将会被很快用完，为了增加地址数量</li>
<li>另外的动机:
<ul>
<li>改变头部格式，帮助加速处理和转发
<ul>
<li>TTL-1（之前的ICPM协议每次都要TTL-2）</li>
<li>头部checksum （之前都会校验头部）</li>
<li>分片 （当MTU小于分组的时候，要分片）</li>
</ul>
</li>
<li>头部格式改变帮助QoS</li>
</ul>
</li>
</ul>
<h3 id="ipv6数据报">IPV6数据报</h3>
<p>IPv6 数据报格式:</p>
<ul>
<li>固定的40字节头部</li>
<li>IP地址由原先的32位改成了128位（16个字节）</li>
<li>数据报传输过程中，不允许分片</li>
</ul>
<p><strong>IPV6头部</strong></p>
<p><img src="/images/wl_25_22.png" alt=""></p>
<ul>
<li>Priority: 标示流中数据报的优先级（优先级是与非技术方面结合的，比如收费等）</li>
<li>Flow Label: 标示多个数据报在一个“flow” ( “flow”的概念没有被严格的定义)</li>
<li>Next header: 标示上层协议（就是网络层以上传给哪个协议，TCP/UDP）</li>
</ul>
<p><strong>和IPv4的其它变化</strong></p>
<ul>
<li><font color=red>Checksum</font>: 被移除掉，降低在每一段中的处理 速度</li>
<li><font color=red>Options</font>: 允许，但是在头部之外, 被 “Next Header” 字段标示 (Next Header的格式是TLV type-length-value)</li>
<li><font color=red>ICMPv6</font>: ICMP的新版本
<ul>
<li>附加了报文类型, e.g. “Packet Too Big”</li>
<li>多播组管理功能</li>
</ul>
</li>
</ul>
<h3 id="从ipv4到ipv6的过渡：隧道">从IPv4到IPv6的过渡：隧道</h3>
<p><img src="/images/wl_25_23.png" alt=""></p>
<p>隧道: 在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报</p>
<p><img src="/images/wl_25_24.png" alt=""></p>
<p><img src="/images/wl_25_25.png" alt=""></p>
<h3 id="ipv6的应用">IPv6的应用</h3>
<ul>
<li>Google: 8% 的客户通过IPv6访问谷歌服务（当然现在还在增加）</li>
<li>NIST: 全美国1/3的政府域支持IPv6</li>
<li>估计还需要很长时间进行部署 （20年）</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——26通用转发和SDN</title>
    <url>/2024/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9426%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E5%92%8CSDN/</url>
    <content><![CDATA[<h1>通用转发和SDN</h1>
<p><em><font color=red>网络层功能</font></em>：</p>
<ul>
<li><em>转发</em>： 对于从某个端口 到来的分组转发到合适的 输出端口</li>
<li><em>路由</em>： 决定分组从源端 到目标端的路径</li>
</ul>
<h2 id="网络层">网络层</h2>
<h3 id="传统路由器的功能">传统路由器的功能</h3>
<p>每个路由器(Per Route)的控制平面 （传统）</p>
<ul>
<li>每个路由器上都有实现路由算法元件（它们之间需要相互交互），形成传统IP实现方式的控制平面</li>
<li>控制平面式分布式的，由各个路由器的各自完成，难于管理</li>
</ul>
<p><img src="/images/wl_26_1.png" alt=""></p>
<p>路由器的网络层功能：</p>
<ul>
<li>IP转发：对于到来的分组按照路由表决定如何转发，数据平面</li>
<li>路由：决定路径，计算路由表；处在控制平面</li>
</ul>
<h3 id="传统的网络设备">传统的网络设备</h3>
<p>还有其他种类繁多网络设备（中间盒）：</p>
<ul>
<li>交换机；防火墙；NAT；IDS；负载均衡设备</li>
<li>未来：不断增加的需求和相应的网络设备</li>
<li>需要不同的设备去实现不同的网络功能
<ul>
<li>每台设备集成了控制平面和数据平面的功能</li>
<li>控制平面分布式地实现了各种控制平面功能</li>
<li>升级和部署网络设备非常困难</li>
</ul>
</li>
</ul>
<h3 id="网络设备控制平面的实现方式特点">网络设备控制平面的实现方式特点</h3>
<p>互联网网络设备：传统方式都是通过分布式，每台设备的方法来实现数据平面和控制平面功能</p>
<ul>
<li>垂直集成：每台路由器或其他网络设备，包括：
<ul>
<li>硬件、在私有的操作系统；</li>
<li>互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现</li>
<li>从上到下都由一个厂商提供（代价大、被设备上“绑架”“）</li>
</ul>
</li>
<li>每个设备都实现了数据平面和控制平面的事情
<ul>
<li>控制平面的功能是分布式实现的</li>
</ul>
</li>
<li>设备基本上只能（分布式升级困难）按照固定方式工作， 控制逻辑固化。</li>
<li>不同的网络功能需要不同的 “middleboxes”：防火墙、负载均衡设备、NAT boxes, .</li>
<li>（数据+控制平面）集成&gt;（控制逻辑）分布-&gt;固化
<ul>
<li>代价大；升级困难；管理困难等</li>
</ul>
</li>
</ul>
<h3 id="问题">问题</h3>
<ul>
<li>垂直集成造成价格昂贵</li>
<li>不便于创新的生态（垄断）</li>
<li>分布式、固化设备功能造成网络设备种类繁多
<ul>
<li>无法改变路由等工作逻辑，无法实现流量工程等高级 特性</li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设 备：管理困难</li>
<li>要增加新的网络功能，需要设计、实现以及部署新的 特定设备，设备种类繁多</li>
</ul>
</li>
<li>~2005：开始重新思考网络控制平面的处理方式
<ul>
<li>集中：远程的控制器集中实现控制逻辑</li>
<li>远程：数据平面和控制平面的分离</li>
</ul>
</li>
</ul>
<h2 id="sdn：逻辑上集中的控制平面">SDN：逻辑上集中的控制平面</h2>
<p>一个不同的（通常是远程）控制器和CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑</p>
<p><img src="/images/wl_26_2.png" alt=""></p>
<h3 id="sdn的主要思路">SDN的主要思路</h3>
<ul>
<li>网络设备数据平面和控制平面分离</li>
<li>数据平面 - 分组交换机
<ul>
<li>将路由器、交换机和目前大多数网络设备的功能进一步抽象成：<strong>按照流表（由控制平面设置的控制逻辑）进行PDU（帧、分组）的动作（包括转发、丢弃、拷贝、泛洪、阻塞）</strong></li>
<li>统一化设备功能：SDN交换机（分组交换机），执行控制逻辑</li>
</ul>
</li>
<li>控制平面 - 控制器 + 网络应用
<ul>
<li>分离、集中</li>
<li>计算和下发控制逻辑：流表</li>
</ul>
</li>
</ul>
<h3 id="sdn控制平面和数据平面分离的优势">SDN控制平面和数据平面分离的优势</h3>
<ul>
<li><font color=red>水平集成</font>控制平面的<font color=red>开放实现</font>（而非私有实现），创造出好的产业状态，促进发展
<ul>
<li>分组交换机、控制器和各种控制逻辑网络应用APP可由不同厂商生产，专业化，引入竞争形成良好生态</li>
</ul>
</li>
<li><font color=red><strong>集中</strong></font>式实现控制逻辑，网络<font color=red>管理容易</font>
<ul>
<li>集中式控制器了解网络状况，编程简单，传统方式困难</li>
<li>避免路由器的误配置</li>
</ul>
</li>
<li>基于流表的<strong>匹配 + 行动</strong>的工作方式允许“<font color=red>可编程的</font>”分组交换机
<ul>
<li>实现流量工程等高级特性</li>
<li>在此框架下实现各种新型（未来）的网络设备</li>
</ul>
</li>
</ul>
<h3 id="类比：主框架到pc的演变">类比：主框架到PC的演变</h3>
<p><img src="/images/wl_26_3.png" alt=""></p>
<h3 id="流量工程：传统路由比较困难">流量工程：传统路由比较困难</h3>
<p><img src="/images/wl_26_4.png" alt=""></p>
<p>Q: 网管如果需要u到z的流量走uvwz,x到z的流量走xwyz，怎么办？<br>
A: 需要定义链路的代价，流量路由算法以此运算（ IP路由面向目标，无法操作） (或者需要新的路由算法)!</p>
<p><img src="/images/wl_26_5.png" alt=""></p>
<p>Q: 如果网管需要将u到z的流量分成2路：uvwz 和uxyz ( 负载均衡)，怎么办?（IP路由面向目标）<br>
A: 无法完成(在原有体系下只有使用新的路由选择算法 ，而在全网部署新的路由算法是个大的事情)</p>
<p><img src="/images/wl_26_6.png" alt=""></p>
<p>Q:如果需要w对蓝色的和红色的流量采用不同的路由，怎么办？<br>
A: 无法操作 (基于目标的转发，采用LS, DV 路由)</p>
<h3 id="sdn特点">SDN特点</h3>
<p><img src="/images/wl_26_7.png" alt=""></p>
<h2 id="sdn架构">SDN架构</h2>
<h3 id="数据平面交换机">数据平面交换机</h3>
<ul>
<li>快速、简单、商业化交换设备，采用硬件实现通用转发功能</li>
<li>流表被控制器计算和安装</li>
<li>基于南向API，SDN控制器访问基于流的交换机
<ul>
<li>定义了哪些可以被控制哪些不能</li>
<li>定义了和控制器的协议</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_26_8.png" alt=""></p>
<h3 id="sdn控制器">SDN控制器</h3>
<ul>
<li>维护网络状态信息</li>
<li>通过上面的北向API和网络应用交互</li>
<li>通过下面的南向API和网络交换机交互</li>
<li>逻辑上集中，但是在实现上通常由于性能、可拓展性、容错性以及鲁棒性采用分布式方法</li>
</ul>
<p><img src="/images/wl_26_9.png" alt=""></p>
<h3 id="控制应用">控制应用</h3>
<ul>
<li>控制的大脑：采用下层提供的服务（SDN控制器提供的API），实现网络功能
<ul>
<li>路由器交换机</li>
<li>接入控制防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul>
</li>
<li><em>非绑定</em>：可以被第三方提供，与控制器厂商以通常上不同，与分组交换机厂商也可以不同</li>
</ul>
<p><img src="/images/wl_26_10.png" alt=""></p>
<h3 id="流表">流表</h3>
<p>每个路由器包含一个<font color=red>流表</font>（被逻辑上集中的控制器计算和分发）</p>
<p><img src="/images/wl_26_11.png" alt=""></p>
<h2 id="openflow">OpenFlow</h2>
<h3 id="openflow数据平面抽象">OpenFlow数据平面抽象</h3>
<ul>
<li>流：由分组（帧）头部字段所定义</li>
<li>通用转发：简单的分组处理规则
<ul>
<li><font color=red><em>模式</em></font>：将分组头部字段和流表进行匹配</li>
<li><font color=red><em>行动</em></font>：<em>对于匹配上的分组，可以是<font color=red>丢弃、转发、修改、将匹配的分组发送给控制器</font></em></li>
<li><font color=red><em>优先权Priority</em></font>：几个模式匹配了，优先采用哪个，消除歧义</li>
<li><font color=red><em>计数器Counters</em></font>：#bytes 以及 #packets</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_26_12.png" alt=""></p>
<h3 id="流表的表项结构">流表的表项结构</h3>
<p><img src="/images/wl_26_13.png" alt=""></p>
<p>例子：</p>
<p><img src="/images/wl_26_14.png" alt=""></p>
<h3 id="openflow抽象">OpenFlow抽象</h3>
<p><font color=red>match + action</font>：统一化各种网络设备提供的功能</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>match</th>
<th>action</th>
</tr>
</thead>
<tbody>
<tr>
<td>路由器</td>
<td>最长前缀匹配</td>
<td>通过一条链路转发</td>
</tr>
<tr>
<td>防火墙</td>
<td>IP地址和TCP/UDP端口号</td>
<td>允许或者禁止</td>
</tr>
<tr>
<td>交换机</td>
<td>目标MAC地址</td>
<td>转发或者泛洪</td>
</tr>
<tr>
<td>NAT</td>
<td>IP地址和端口号</td>
<td>重写地址和端口号</td>
</tr>
</tbody>
</table>
<p>目前几乎所有的设备都可以在这个匹配 + 行动模式框架进行描述，具体化为各种网络设备包括未来的网络设备</p>
<h3 id="openflow例子">OpenFlow例子</h3>
<p><img src="/images/wl_26_15.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——27路由选择算法</title>
    <url>/2024/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9427%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>路由选择算法</h1>
<h2 id="路由协议">路由协议</h2>
<p><font color=red><em>路由协议的目标</em></font>：确定从发送主机到接收主机之间，通过路由器的网络“较好”的路径（等价于路由器的序列）</p>
<ul>
<li>路径：路由器的序列，分组将会沿着该序列从源主机到达最后的目标主机</li>
<li>“较好”：最小“代价”，“最快的”，“最不拥塞”</li>
<li>路由：一个“top-10”网络挑战</li>
</ul>
<h2 id="路由的概念">路由的概念</h2>
<ul>
<li>路由：按照某种指标（传输延迟，所经过的站点数目等）找到一条从源节点到目标节点的较好路径
<ul>
<li>较好路径：按照某种指标较小的路径</li>
<li>指标：站数、延迟、费用，队列长度等，或者是一些单纯指标的加权平均</li>
<li>采用什么样的指标，表示网络使用者希望网络在什么方面表现突出，什么指标网络使用者比较重视</li>
</ul>
</li>
<li>路由器 - 路由器之间的最优路径 = 主机对之间的最优路径
<ul>
<li>路由器连接子网，子网到路由器之间的跳数就一跳，必须要走</li>
<li>路由器到下一跳路由器（节点到节点）之间的最优路径找到了</li>
<li>也就找到了从源子网向目标子网所有主机对之间的最优路径</li>
<li>大大降低了路由计算的规模</li>
<li>在路由计算中按照子网到子网的路径计算为目标，而不是主机到主机</li>
</ul>
</li>
<li>路由选择算法：网络层软件的一部分，完成路由功能</li>
</ul>
<h2 id="网络的图抽象">网络的图抽象</h2>
<h3 id="图抽象">图抽象</h3>
<p><img src="/images/wl_27_1.png" alt=""></p>
<p>图：G = (N,E)<br>
N = 路由集合器 = (u,v,w,x,y,z)<br>
E = 链路集合 = ((u,v),(u,x),(v,x),(v,w),(x,w),(x,y),(w,y),(w,z),(y,z)) 边有代价</p>
<h3 id="边和路径的代价">边和路径的代价</h3>
<ul>
<li>c(x,x’) = 链路的代价(x,x’)</li>
<li>代价可能总为1</li>
<li>或是链路带宽的倒数</li>
<li>或是拥塞情况的倒数</li>
<li>cost of path(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">x_1,x_2,x_3,...,x_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>) = c(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1,x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) + c(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">x_2,x_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) + … + c(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">x_{p-1},x_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)</li>
</ul>
<h3 id="最优化原则">最优化原则</h3>
<p>汇集树</p>
<ul>
<li>此节点到所有其他节点的最优路径形成的树</li>
<li>路由选择算法就是为所有路由器<font color=red>找到</font>并<font color=red>使用</font>汇集树</li>
</ul>
<p><img src="/images/wl_27_2.png" alt=""></p>
<h2 id="路由的原则">路由的原则</h2>
<p>路由选择算法的原则</p>
<ul>
<li>正确性：算法必须是<font color=red>正确</font>的和<font color=red>完整</font>的，使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应的表项；没有处理不了的目标站地址</li>
<li>简单性：算法在计算机上应简单：最优但复杂的算法，时间上延迟很大，不实用，不应为了获取路由信息增加很多的通信量</li>
<li>健壮性：算法应能适应<font color=red>通信量</font>和<font color=red>网络拓扑</font>的变化：通信量变化，网络拓扑的变化算法能很快适应；不向很拥挤的链路发送数据，不向断了的链路发送数据</li>
<li>稳定性：产生的路由不应该摇摆</li>
<li>公平性：对每一个站点都公平</li>
<li>最优性：某一个指标的最优，时间上，费用上等指标，或综合指标；实际上，获取最优的结果代价较高，可能是次优的</li>
</ul>
<h2 id="路由算法分类">路由算法分类</h2>
<p><font color=red>全局或局部路由信息</font><br>
全局：</p>
<ul>
<li>所有的路由器拥有完整的拓扑和边的代价的信息</li>
<li><font color=red>&quot;<strong>link state</strong>&quot;算法</font></li>
</ul>
<p>分布式：</p>
<ul>
<li>路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价值</li>
<li>迭代地与邻居交换路由信息，计算路由信息</li>
<li><font color=red>&quot;**distance vector&quot;算法</font></li>
</ul>
<p><font color=red>静态或动态</font><br>
静态：</p>
<ul>
<li>路由随时间变化缓慢</li>
</ul>
<p>动态：</p>
<ul>
<li>路由变化很快
<ul>
<li>周期性更新</li>
<li>根据链路代价的变化而变化</li>
</ul>
</li>
</ul>
<h2 id="链路静态路由-ls">链路静态路由（LS）</h2>
<h3 id="ls路由的工作过程">LS路由的工作过程</h3>
<p>配置<font color=red>LS路由选择算法</font>的路由工作过程</p>
<ul>
<li>各点通过各种渠道获得<font color=red>整个网络拓扑</font>，网络中所有链路代价等信息（这部分和算法没关系，属于协议和实现）</li>
<li>使用<font color=red>LS路由算法</font>，计算本站点到其他站点的最优路径（汇集树），得到路由表</li>
<li>按照此路由表转发分组(datagram方式)
<ul>
<li>严格意义上说不是路由的一个步骤</li>
<li>分发到输入端口的网络层</li>
</ul>
</li>
</ul>
<h3 id="ls路由的基本工作过程">LS路由的基本工作过程</h3>
<ul>
<li>发现相邻节点，获知对方网络地址</li>
<li>测量到相邻节点的代价（延迟、开销）</li>
<li>组装一个LS分组，描述它到相邻节点的代价情况</li>
<li>将分组通过扩散的方式发到所有其他路由器
<ul>
<li>以上四步让每个路由器获得<font color=red>拓扑</font>和<font color=red>边代价</font></li>
</ul>
</li>
<li>通过Dijkstra算法找出最短路径（这才是路由算法）
<ul>
<li>每个节点独立算出来到其他节点（路由器 = 网络）的最短路径</li>
<li>迭代算法：第k步能够知道本节点到k个其他节点的最短路径</li>
</ul>
</li>
</ul>
<h3 id="链路状态路由选择">链路状态路由选择</h3>
<ol>
<li>发现相邻节点，获知对方网络地址
<ul>
<li>一个路由器上电之后，向所有线路发送Hello分组</li>
<li>其他路由器接收到Hello分组，回送应答，在应答分组中，告知自己的名字（全局唯一）</li>
<li>在LAN中，通过广播Hello分组，获得其他路由器的信息，可以认为引入一个人工节点</li>
</ul>
</li>
</ol>
<p><img src="/images/wl_27_3.png" alt=""></p>
<ol start="2">
<li>测量到相邻节点的代价（延迟、开销）
<ul>
<li>实测法，发送一个分组要求对方立即响应</li>
<li>回送一个ECHO分组</li>
<li>通过测量时间可以估算出延迟情况</li>
</ul>
</li>
<li>组装一个分组，描述相邻节点的情况
<ul>
<li>发送者名称</li>
<li>序号，名称</li>
<li>列表：给出他相邻节点，和它到相邻节点的延迟</li>
</ul>
</li>
</ol>
<p><img src="/images/wl_27_4.png" alt=""></p>
<ol start="4">
<li>将分组通过扩散的方法发送到所有其他路由器
<ul>
<li>序列号：用于控制无穷的扩散，每个路由器都记录（源路由号，顺序号），发现重复的或老的就不扩散
<ul>
<li>具体问题1：循环使用问题</li>
<li>具体问题2：路由器崩溃之后序号从0开始</li>
<li>具体问题3：序号出现错误</li>
</ul>
</li>
<li>解决问题的方法：年龄字段
<ul>
<li>生成一个分组时，年龄字段不为0</li>
<li>每一个时间段，AGE字段减一</li>
<li>AGE字段为0的分组将被抛弃</li>
</ul>
</li>
<li>关于扩散分组的数据结构
<ul>
<li>Source：从哪个节点收到LS分组</li>
<li>Seq,Age：序号，年龄</li>
<li>Send flags：发送标记，必须向指定的哪些相邻站点转发LS分组</li>
<li>ACK flags：本站点必须向哪些相邻站点发送应答</li>
<li>DATA：来自source站点的LS分组</li>
<li>节点B的数据结构</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>Source</th>
<th>Seq</th>
<th>Age</th>
<th>Send flags A</th>
<th>Send flags C</th>
<th>Send flags F</th>
<th>ACK flags A</th>
<th>ACK flags C</th>
<th>ACK flags F</th>
<th>Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>A(相邻)</td>
<td>21</td>
<td>60(初始TTL)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1(A与B相邻，直接获取A的分组，给A ACK)</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>F(相邻)</td>
<td>21</td>
<td>60</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>E(通过A、F获取)</td>
<td>21</td>
<td>59(一次hop)</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1(E通过A获取，给A ACK)</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>C(相邻)</td>
<td>20</td>
<td>60</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>D(通过C、F获取)</td>
<td>21</td>
<td>59</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="5">
<li>通过Dijkstra算法找出最短路径
<ul>
<li>路由器获得各站点LS分组和整个网络的拓扑</li>
<li>通过Dijkstra算法计算出到其他服务器的最短路径（汇集树）</li>
<li>将计算结果安装到路由表中</li>
</ul>
</li>
</ol>
<h4 id="ls的应用情况">LS的应用情况</h4>
<ul>
<li>OSPF协议是一种LS协议，被用于Internet上</li>
<li>IS-IS(intermediate system - intermediate system)：被用于Internet主干中，Netware</li>
</ul>
<h4 id="dijkstra算法">Dijkstra算法</h4>
<p>符号标记</p>
<ul>
<li>c(i,j)：从节点i到j链路代价（初始状态下非相邻节点之间的链路代价为∞）</li>
<li>D(v)：从源节点到节点V的当前路径代价（节点的代价）</li>
<li>p(v)：从源到节点V的路径前序节点</li>
<li>N’：当前已经知道最优路径的节点集合（永久节点的集合）</li>
</ul>
<p><img src="/images/wl_27_5.png" alt=""></p>
<h4 id="ls路由选择算法的工作原理">LS路由选择算法的工作原理</h4>
<p>节点标记：每一个节点使用(D(v),p(v))标记</p>
<ul>
<li>D(v)从源节点由已知最优路径到达本节点的距离</li>
<li>P(v)前序节点来标注</li>
</ul>
<p>2类节点</p>
<ul>
<li>临时节点：还没有找到从源节点到此节点的最优路径的节点</li>
<li>永久节点 N’：已经找到了从源节点到此节点的最优路径的节点</li>
</ul>
<h4 id="算法具体流程">算法具体流程</h4>
<ul>
<li>初始化
<ul>
<li>除了源节点外，所有节点都为临时节点</li>
<li>节点<font color=red>代价</font>除了与源节点代价相邻的节点外，都为∞</li>
</ul>
</li>
<li>从所有临时节点中找到一个<font color=red>节点代价最小</font>的临时节点，将之变为永久节点（当前结点）W</li>
<li>对此节点的<font color=red>所有在临时节点集合中的邻节点</font>(V)
<ul>
<li>如 D(v)&gt;D(w) + c(w,v), 则重新标注此点, (D(W)+C(W,V), W)</li>
<li>否则，不重新标注</li>
</ul>
</li>
<li>开始一个新的循环</li>
</ul>
<h4 id="例子">例子</h4>
<p><img src="/images/wl_27_6.png" alt=""></p>
<p>Dijkstra例子</p>
<p><img src="/images/wl_27_7.png" alt=""></p>
<p><img src="/images/wl_27_8.png" alt=""></p>
<h4 id="dijkstra算法的讨论">Dijkstra算法的讨论</h4>
<p>算法复杂度: n节点</p>
<ul>
<li>每一次迭代: 需要检查所有不在永久集合N中节点</li>
<li>n(n+1)/2 次比较: O(n2 )</li>
<li>有很有效的实现: O(nlogn)</li>
</ul>
<p>可能会出现震荡问题：</p>
<ul>
<li>例如：链路代价 = 链路承载的流量</li>
<li>路径改变次数过多</li>
</ul>
<p><img src="/images/wl_27_9.png" alt=""></p>
<h2 id="距离矢量路由选择">距离矢量路由选择</h2>
<h3 id="基本思想">基本思想</h3>
<ul>
<li>各路由器维护一张路由表，结构如图</li>
</ul>
<table>
<thead>
<tr>
<th>To(目标)</th>
<th>Next(到达目标的代价最小的路径中，下一跳)</th>
<th>cost(到目标的代价)</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Z</td>
<td>14</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<ul>
<li>各路由器与相邻路由器交换路由表(待续)</li>
<li>根据获得的路由信息,更新路由表(待续)</li>
</ul>
<p><img src="/images/wl_27_10.png" alt=""></p>
<ul>
<li>代价及相邻节点间代价的获得
<ul>
<li>跳数(hops), 延迟(delay),队列长度</li>
<li>相邻节点间代价的获得：通过实测</li>
</ul>
</li>
<li>路由信息的更新
<ul>
<li>根据实测 得到本节点A到相邻站点的代价（如:延迟）</li>
<li>根据各相邻站点声称它们到目标站点B的代价，计算出本站点A经过各相邻站点到目标站点B的代价</li>
<li>找到一个最小的代价，和相应的下一个节点Z，到达节点B经过此节点Z，并且代价为A-Z-B的代价</li>
<li>其它所有的目标节点同样的计算方法</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_27_11.png" alt=""></p>
<h3 id="例子1">例子1</h3>
<ul>
<li>以当前节点J为例,相邻节点 A,I,H,K</li>
<li>J测得到A,I,H,K的延迟为 8ms,10ms,12ms,6ms</li>
<li>通过交换DV, 从A,I,H,K获得到 它们到G的延迟为 18ms,31ms,6ms,31ms</li>
<li>因此从J经过A,I,H,K到G的延迟 为26ms(8 + 18),41ms(10 + 31),18ms(12 + 6), 37ms(31 + 6)</li>
<li>将到G的路由表项更新为18ms, 下一跳为：H(18ms对应的节点)</li>
<li>其它目标一样，除了本节点J</li>
</ul>
<p><img src="/images/wl_27_12.png" alt=""></p>
<h3 id="dv的无穷计算问题">DV的无穷计算问题</h3>
<ul>
<li>DV的特点
<ul>
<li>好消息传的快，坏消息传的慢</li>
</ul>
</li>
<li>好消息的传播以每一个交换周期前进一个路由器的速度进行
<ul>
<li>好消息：某个路由器接入或有更短的路径</li>
<li>举例</li>
</ul>
</li>
<li>坏消息的传播速度非常慢(无穷计算问题)</li>
</ul>
<p><img src="/images/wl_27_13.png" alt=""></p>
<ul>
<li>例子:
<ul>
<li>AB之间断开了</li>
<li>第一次交换之后, B从C处获得信息,C可以到达A(C-A, 要经过B本身),但是路径是2,因此B变成3,从C处走</li>
<li>第二次交换,C从B处获得消息, B可以到达A,路径为3, 因此,C到A从B走,代价为3（因为每次改变都会向周围传递Dv ）</li>
<li>无限此之后, 到A的距离变成INF,不可达</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_27_16.png" alt=""></p>
<h3 id="bellman-ford-方程-动态规划">Bellman-Ford 方程（动态规划）</h3>
<p>设 dx(y) := 从x到y的最小路径代价，那么 dx(y) = min {c(x,v) + dv(y) }<br>
其中：v是x的邻居</p>
<h4 id="例子">例子</h4>
<p><img src="/images/wl_27_14.png" alt=""></p>
<p>明显的,<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn><mo separator="true">,</mo><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo separator="true">,</mo><msub><mi>d</mi><mi>w</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">d_v(z) = 5, d_x(z) = 3, d_w(z) = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span><br>
由于B-F方程得到：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>u</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>w</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mn>2</mn><mo>+</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo>+</mo><mn>3</mn><mo stretchy="false">}</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">d_u(z) = min \{ c(u,v) + d_v(z), c(u,x) + d_x(z), c(u,w) + d_w(z) \} = min \{2 + 5, 1 + 3, 5 + 3\} = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">{</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">{</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></p>
<p>那个能够达到目标z最小代价的节点x，就在到目标节点的下一条路径上, 在转发表中使用</p>
<h3 id="思路">思路</h3>
<p><font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_x(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></font> = 节点x到y代价最小值的估计</p>
<ul>
<li>x 节点维护距离矢量<font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>x</mi></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi>D</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>y</mi><mo>∈</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D_x = [D_x (y): y ∈ N ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span></font></li>
</ul>
<p>节点x:</p>
<ul>
<li>知道到所有邻居v的代价: <font color=red>c(x,v)</font></li>
<li>收到并维护一个它邻居的距离矢量集</li>
<li>对于每个邻居, x 维护 <font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>v</mi></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi>D</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>y</mi><mtext>є</mtext><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D_v = [D_v (y): y є N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cyrillic_fallback">є</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span></font></li>
</ul>
<p><font color=red>核心思路</font></p>
<ul>
<li>每个节点都将自己的距离矢量估计值传送给邻居，定时或者DV有变化时，让对方去算</li>
<li>当x从邻居收到DV时，自己运算，更新它自己的距离矢量（采用B-F equation）<br>
<font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>←</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>D</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_x(y) ← min_v\{c(x,v) + D_v(y)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span> 对于每个节点y ∈ N</font></li>
<li>X往y的代价x到邻居v代价v声称到y的代价</li>
<li>Dx(y)估计值最终收敛于实际的最小代价值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_x(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="特点">特点</h3>
<p><font color=red>异步式,迭代</font>: 每次本地迭代被以下事件触发:</p>
<ul>
<li>本地链路代价变化了</li>
<li>从邻居来了DV的更新消息</li>
</ul>
<p><font color=red>分布式</font>:</p>
<ul>
<li>每个节点只是在自己的DV改变之后向邻居通告</li>
<li>然后邻居们在有必要的时候通知他们的邻居</li>
</ul>
<p><img src="/images/wl_27_15.png" alt=""></p>
<h3 id="水平分裂-split-horizon-算法">水平分裂(split horizon)算法</h3>
<p>一种对无穷计算问题的解决办法 —— 结局坏消息传的慢的问题</p>
<ul>
<li>当AB断开之后，C进行交换</li>
<li>C知道要经过B才能到达A，所以C向B报告它到A的距离 为INF；C 告诉D它到A的真实距离2（就这样一边传递INF，一边传递真实举例2，水平方向分裂）</li>
<li>下一阶段，C发现到A的路径断开了，D进行交换</li>
<li>D告诉E,它到A的距离,但D告诉C它通向A的距离为INF</li>
<li>第一次交换: B通过测试发现到A的路径为INF,而C也告 诉B到A的距离为INF,因此,B到A的距离为INF</li>
<li>第二次交换: C从B和D那里获知,到A的距离为INF,因此 将它到A的距离为INF</li>
<li>……坏消息以一次交换一个节点的速度传播</li>
</ul>
<p><img src="/images/wl_27_17.png" alt=""></p>
<p><img src="/images/wl_27_18.png" alt=""></p>
<h3 id="水平分裂算法问题">水平分裂算法问题</h3>
<p>水平分裂的问题:在某些拓扑形式下会失败（存在环路）</p>
<p><img src="/images/wl_27_19.png" alt=""></p>
<ul>
<li>A,B到D的距离为2, C到D的距离为1</li>
<li>如果C-D路径失败</li>
<li>C获知到D为INF,从A,B获知到D的距离为INF,因此C认为D不可达</li>
<li>A从C获知D的距离为INF,但从B处获知它到D的距离为2,因此A到B的距离为3,从B走</li>
<li>B也有类似的问题</li>
<li>经过无限次之后,A和B都知道到D的距离为INF</li>
</ul>
<p><img src="/images/wl_27_20.png" alt=""></p>
<p><img src="/images/wl_27_21.png" alt=""></p>
<p><img src="/images/wl_27_22.png" alt=""></p>
<p><img src="/images/wl_27_23.png" alt=""></p>
<p><img src="/images/wl_27_24.png" alt=""></p>
<p><img src="/images/wl_27_25.png" alt=""></p>
<h3 id="例子">例子</h3>
<p><img src="/images/wl_27_26.png" alt=""></p>
<h2 id="ls和dv算法的比较">LS和DV算法的比较</h2>
<p>消息复杂度（DV胜出） O(NE)<br>
收敛时间（LS胜出） O(NlogN)<br>
健壮性（LS胜出） 节点之间影响较小</p>
<table>
<thead>
<tr>
<th>性能指标</th>
<th>LS特点</th>
<th>DV特点</th>
<th>比较结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息复杂度</td>
<td>有n 节点, E 条链路,发送报文O(nE)个；（局部的路由信息；全局传播）</td>
<td>只和邻居交换信息（全局的路由信息，局部传播）</td>
<td>DV胜出</td>
</tr>
<tr>
<td>收敛时间</td>
<td>O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>) 算法；有可能震荡</td>
<td>收敛较慢；可能存在路由环路；count-to-infinity 问题</td>
<td>LS胜出</td>
</tr>
<tr>
<td>健壮性(路由器故障会发生什么)</td>
<td>节点会通告不正确的链路代价,每个节点只计算自己的路由表,错误信息影响较小，局部，路由较健壮</td>
<td>节点可能通告对全网所有节点的不正确路径代价,每一个节点的路由表可能被其它节点使用,错误可以扩散到全网</td>
<td>LS胜出</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——28自治系统内部的路由选择</title>
    <url>/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9428%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1>自治系统内部的路由选择</h1>
<h2 id="rip">RIP</h2>
<ul>
<li>在1982年发布的BSD-UNIX中实现</li>
<li>Distance vector算法
<ul>
<li>距离矢量：每条链路cost = 1，# of hops(max = 15 hops)跳数</li>
<li>DV每隔30秒和邻居交换DV，通告</li>
<li>每个通告包括：最多25个目标子网</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_28_1.png" alt=""></p>
<h3 id="rip通告">RIP通告</h3>
<ul>
<li>DV：在邻居之间每30秒交换通告报文
<ul>
<li>定期：而且在改变路由的时候发送通告报文</li>
<li>在对方的请求下可以发送通告报文</li>
</ul>
</li>
<li>每一个通告：至多AS内部的25个目标网络的DV
<ul>
<li>目标网络 + 跳数</li>
<li>一次公告最多25个子网，最大跳数为16</li>
</ul>
</li>
</ul>
<h3 id="例子">例子</h3>
<p><img src="/images/wl_28_2.png" alt=""></p>
<p><img src="/images/wl_28_3.png" alt=""></p>
<h3 id="rip链路失效和恢复">RIP链路失效和恢复</h3>
<p>如果180秒没有收到通告信息 → 邻居或者链路失效</p>
<ul>
<li>发现经过这个邻居的路由已失效</li>
<li>新的通告报文会传递给邻居</li>
<li>邻居因此发出新的通告（如果路由变化的话）</li>
<li>链路失效快速（？）地在整网中传输</li>
<li>使用毒性逆转，阻止ping-pong回路（不可达的距离：跳数无限 = 16段）</li>
</ul>
<h3 id="rip进程处理">RIP进程处理</h3>
<ul>
<li>RIP以应用进程的方式实现：route-d</li>
<li>通告报文通过UDP报文传送，周期性重复</li>
<li>网络层的协议使用了传输层的服务，以应用层实体的方式实现</li>
</ul>
<p><img src="/images/wl_28_4.png" alt=""></p>
<h2 id="ospf">OSPF</h2>
<ul>
<li>open：标准可公开获得</li>
<li>使用LS算法
<ul>
<li>LS分组在网络中（一个AS内部）分发</li>
<li>全局网络拓扑，代价在每一个节点中都保持</li>
<li>路由计算采用Dijkstra算法</li>
</ul>
</li>
<li>OSPF通告信息中携带：每一个邻居路由器一个表项</li>
<li>通告信息会传遍AS全部（通过泛洪）
<ul>
<li>在IP数据报上直接传送OSPF报文（而不是通过UDP和TCP）</li>
</ul>
</li>
<li><font color=red>IS-IS路由协议</font>：几乎和OSPF一样</li>
</ul>
<h3 id="ospf-高级-特性-在rip中没有的">OSPF“高级”特性（在RIP中没有的）</h3>
<ul>
<li><font color=red>安全</font>：所有的OSPF报文都是经过认证的（防止恶意的攻击）</li>
<li>允许有<font color=red>多个代价相同</font>的路径存在（在RIP中只能有一个）</li>
<li>对于每一条链路，对于不同的TOS有<font color=red>多重代价矩阵</font>
<ul>
<li>例如：卫星链路代价对于尽力而为的服务代价设置比较低，对实时服务代价设置比较高</li>
<li>支持按照不同的代价计算最优路径，如：按照时间和延迟分别计算最优路径</li>
</ul>
</li>
<li>对单播和多播的集成支持：
<ul>
<li>Multicast OSPF(MOSPF)使用相同的拓扑数据库，就像在OSPF中一样</li>
</ul>
</li>
<li>在大型网络中支持层次性OSPF</li>
</ul>
<h3 id="层次化的ospf">层次化的OSPF</h3>
<p><img src="/images/wl_28_5.png" alt=""></p>
<ul>
<li><font color=red>2个级别的层次性</font>：本地，骨干
<ul>
<li>链路状态通告仅仅在本地区域Area范围内进行</li>
<li>每一个节点拥有本地区域的拓扑信息：
<ul>
<li>关于其他区域，知道去他的方向，通过区域边界路由器（最短路径）</li>
</ul>
</li>
</ul>
</li>
<li><font color=red>区域边界路由器</font>：“汇总（汇集）”到自己区域内网络的距离，向其他区域边界路由器通告</li>
<li><font color=red>骨干路由器</font>：仅仅在骨干区域内，运行OSPF路由</li>
<li><font color=red>边界路由器</font>：连接其他的AS’s</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——29ISP之间的路由选择：BGP</title>
    <url>/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9429ISP%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%9ABGP/</url>
    <content><![CDATA[<h1>ISP之间的路由选择：BGP</h1>
<h2 id="层次路由">层次路由</h2>
<p>一个<font color=red>平面</font>的路由</p>
<ul>
<li>一个网络中的所有路由器的地位一样</li>
<li>通过LS，DV，或者其他路由算法，所有路由器都要知道其他所有路由器（子网）如何走</li>
<li>所有路由器在一个平面</li>
</ul>
<p>平面路由的问题</p>
<ul>
<li><font color=red>规模</font>巨大的网络中，路由信息的存储、传输和计算代价巨大
<ul>
<li>DV：距离矢量很大，而且不能收敛</li>
<li>LS：几百万个节点的LS分组的泛洪传输，存储以及最短路径算法的计算</li>
</ul>
</li>
<li><font color=red>管理</font>问题：
<ul>
<li>不同的网络所有者希望按照自己的方式管理网络</li>
<li>希望对外隐藏自己网格的细节</li>
<li>希望和其他网络互联</li>
</ul>
</li>
</ul>
<p>层次路由：将互联网分成一个个AS（路由器区域）</p>
<ul>
<li>某个区域内的路由器集合，自治系统“<font color=red>autonomounts systems(AS)</font>”</li>
<li>一个AS用AS Number（ASN）唯一标识</li>
<li>一个ISP可能包括1个或者多个AS</li>
</ul>
<p>路由变成了：2个层次路由</p>
<ul>
<li>AS内部路由：在同一个AS内路由器运行相同的路由协议
<ul>
<li><font color=red>“intra-AS” routing protocol</font>：内部网关协议</li>
<li>不同的AS可能运行着不同的内部网关协议</li>
<li>能够解决规模和管理问题</li>
<li><font color=red>网管路由器</font>：AS边缘路由器，可以连接到其他AS</li>
</ul>
</li>
<li>AS间运行AS间路由协议
<ul>
<li><font color=red>“inter-AS” routing protocol</font>：外部网关协议</li>
<li>解决AS之间的路由问题，完成AS之间的互联互通</li>
</ul>
</li>
</ul>
<h3 id="层次路由的优点">层次路由的优点</h3>
<p>解决了规模问题</p>
<ul>
<li>内部网关协议解决：AS内部<font color=red>数量有限</font>的路由器相互到达的问题，AS内部规模可控
<ul>
<li>如AS节点太多，可分割AS，使得AS内部的节点数量有限</li>
</ul>
</li>
<li>AS之间的路由的规模问题
<ul>
<li>增加一个AS，对AS之间的路由从<font color=red>总体上</font>来说，只是增加了一个节点=子网（每个AS可以用一个点表示）</li>
<li>对于其他AS来说只是增加了一个表项，就是这个新增的AS如何走的问题</li>
<li>拓展性强：规模增大，性能不会减的太多</li>
</ul>
</li>
</ul>
<p>解决了管理问题</p>
<ul>
<li>各个AS可以运行不同的内部网关协议</li>
<li>可以使自己网络的细节不向外透露</li>
</ul>
<h2 id="互联网as路由：bgp">互联网AS路由：BGP</h2>
<p><font color=red>BGP</font>：自治区域间路由协议“事实上的”标准</p>
<ul>
<li>“将互联网各个AS粘在一起的胶水”</li>
</ul>
<p>BGP提供给每个AS以以下方法：</p>
<ul>
<li><font color=red>eBGP</font>：从相邻的ASes那里获得子网可达信息</li>
<li><font color=red>iBGP</font>：将从获得的子网可达信息传播到AS内部所有的路由器</li>
<li>根据子网可达信息和<font color=blue>策略</font>来决定子网的“好”路径</li>
</ul>
<p>允许子网向互联网其他网络通告“<font color=blue>我在这里</font>”</p>
<p>基于距离矢量算法（路径矢量）</p>
<ul>
<li>不仅仅是距离矢量，还包括到达各个目标网络的详细路径（AS序号的列表）能够避免简单DV算法的路由环路问题</li>
</ul>
<h3 id="ebgp-ibgp连接">eBGP，iBGP连接</h3>
<p><img src="/images/wl_29_1.png" alt=""></p>
<h3 id="bgp基础">BGP基础</h3>
<p><font color=red>BGP会话</font>：2个BGP路由器在一个半永久的TCP连接上交换BGP报文：</p>
<ul>
<li>通告向不同目标子网前缀的“路径”（BGP是一个“路径矢量”协议）</li>
</ul>
<p><img src="/images/wl_29_2.png" alt=""></p>
<p>当AS3网管路由器3a向AS2的网管路由器2c通告路径：<font color=red>AS3,X</font></p>
<ul>
<li>3a参与AS内路由运算，知道本AS所有子网X信息</li>
<li>语义上：AS3向AS2<font color=red>承诺</font>，它可以向子网X转发数据报</li>
<li>3a是2c关于X的下一跳(next hop)</li>
</ul>
<h3 id="路径的属性-路由">路径的属性 &amp; 路由</h3>
<p>当通告一个子网前缀时，通告包括BGP属性</p>
<ul>
<li>prefix + attributes = “route”</li>
</ul>
<p>两个重要的属性</p>
<ul>
<li><font color=red>AS-PATH</font>：前缀的通告所经过的AS列表：AS 67 AS 17
<ul>
<li>检测环路：多路径选择</li>
<li>在向其他AS转发时，需要将自己的AS号加载路径上</li>
</ul>
</li>
<li><font color=red>NEXT-HOP</font>：从当前AS到下一跳AS有多个链路，在NEXT-HOP属性中，告诉对方通过那个I转发</li>
<li>其他属性：路由偏好指标，如何被插入的属性</li>
</ul>
<p>基于<font color=red>策略</font>的路由</p>
<ul>
<li>当一个网关路由器接收到了一个路由器通告，使用<font color=red>输入策略</font>来接受或过滤
<ul>
<li>过滤原因例子
<ul>
<li>不想经过某个AS，转发某些前缀的分组</li>
<li>已经有了一条往某前缀的偏好分组</li>
</ul>
</li>
</ul>
</li>
<li>策略也决定了是否向它别的邻居<font color=red>通告</font>接收到的这个路由信息</li>
</ul>
<h3 id="bgp路径通告">BGP路径通告</h3>
<p><img src="/images/wl_29_3.png" alt=""></p>
<ul>
<li>路由器AS2.2c从AS3.3a接收到的<font color=red>AS3,X</font>路径通告（通过eBGP）</li>
<li>基于AS2的输入策略，AS2.2c决定接收AS3,X的通告，而且（通过iBGP）向AS2的所有路由器进行通告</li>
<li>基于AS2的策略，AS2路由器2a通过eBGP向AS1.1c路由器通告<font color=red>AS2,AS3,X</font>路由信息
<ul>
<li>路径上加上了AS2自己作为AS序列的一跳</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_29_4.png" alt=""></p>
<p>网关路由器可能获取有关一个子网X的多条路径，从多个eBGP会话上：</p>
<ul>
<li>AS1网关路由器1c从2a学习到路径：<font color=red>AS2,AS3,X</font></li>
<li>AS1网关路由器1c从3a学习到路径：AS3,X</li>
<li>基于策略：AS1路由器1c选择了路径：<font color=red>AS3,X，而且通过iBGP告诉所有AS1内部的路由器</font></li>
</ul>
<h3 id="bgp报文">BGP报文</h3>
<p>使用TCP协议交换BGP报文<br>
BGP报文：</p>
<ul>
<li><font color=red>OPEN</font>：打开TCP连接，认证发送方</li>
<li><font color=red>UPDATE</font>：通告新路径（或者撤销原路径）</li>
<li><font color=red>KEEPALIVE</font>：在没有更新的时候保持连接，也用于对OPEN请求确认</li>
<li><font color=red>NOTIFICATION</font>：报告以前消息的错误，也用来关闭连接</li>
</ul>
<h3 id="bgp-ospf-转发表表项">BGP、OSPF，转发表表项</h3>
<p>路由器是如何设置到这些远程子网前缀的转发表表项的？</p>
<p><img src="/images/wl_29_5.png" alt=""></p>
<p>回顾：1a,1b,1c从1c那里通过iBGP学习到了子网X，“到往子网X的要通过1c”<br>
1d：通过OSPF内部网关协议，为了到达1c，必须通过本地接口1</p>
<h3 id="bgp路径选择">BGP路径选择</h3>
<p>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：</p>
<ol>
<li>本地偏好值属性：偏好策略决定</li>
<li>最短AS-PATH：AS的跳数</li>
<li>最近的NEXT-HOP路由器：热土豆路由</li>
<li>附加的判据：使用BGP标识</li>
</ol>
<p>一个前缀对应着多种路径，采用消除规则直到留下一条路径</p>
<h4 id="热土豆路由">热土豆路由</h4>
<p><img src="/images/wl_29_6.png" alt=""></p>
<p>2d通过iBGP获知，它可以通过2a或者2c到达X<br>
热土豆策略：选择具备最小内部区域的代价的网关作为往X的出口（如：2d选择2a，即使X可能有比较多的AS跳数），不要操心域间的代价</p>
<h2 id="为什么内部网关协议和外部网关协议如此不同">为什么内部网关协议和外部网关协议如此不同</h2>
<p><font color=red>策略</font></p>
<ul>
<li>Inter-AS：管理员需要控制通信路径，谁在使用它的网络进行数据传输</li>
<li>Intra-AS：一个管理者，所以无需策略
<ul>
<li>AS内部的各子网的主机尽可能的利用资源进行快速路由</li>
</ul>
</li>
</ul>
<p><font color=red>规模</font></p>
<ul>
<li>AS间路由必须考虑规模问题，以便支持全网的数据转发</li>
<li>AS内部路由规模不是一个大的问题
<ul>
<li>如果AS太大，可将AS分成小的AS：规模可控</li>
<li>AS之间只不过多了一个点而已</li>
<li>或者AS内部路由支持层次性，层次性路由节约了表空间降低了更新的数据流量</li>
</ul>
</li>
</ul>
<p><font color=red>性能</font></p>
<ul>
<li>Inter-AS：策略可能比性能更重要</li>
<li>Intra-AS：关注性能</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——30SDN控制平面</title>
    <url>/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9430SDN%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h1>SDN控制平面</h1>
<h2 id="sdn架构">SDN架构</h2>
<h3 id="数据平面交换机">数据平面交换机</h3>
<ul>
<li>快速、简单，商业化交换设备采用硬件实现通用转发功能</li>
<li>流表被控制器计算和安装</li>
<li>基于南向API，SDN控制器访问基于流的交换机
<ul>
<li>定义了哪些可以被控制哪些不能</li>
</ul>
</li>
<li>也定义了和控制器的协议</li>
</ul>
<p><img src="/images/wl_30_1.png" alt=""></p>
<h3 id="sdn控制器-网络os">SDN控制器（网络OS）</h3>
<ul>
<li>维护网络状态信息</li>
<li>通过上面的北向API和网络控制应用交互</li>
<li>通过下面的南向API和网络交换机交互</li>
<li>逻辑上集中，但是在实现上通常由于性能、可拓展性、容错性以及鲁棒性采用分布式方法实现</li>
</ul>
<p><img src="/images/wl_30_2.png" alt=""></p>
<h3 id="控制应用">控制应用</h3>
<p>网络控制应用：</p>
<ul>
<li>控制的大脑：采用下层提供的服务（SDN控制器提供的API）实现网络功能
<ul>
<li>路由器、交换机</li>
<li>接入控制防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul>
</li>
<li>非绑定：可以被第三方提供，与控制器厂商以通常上不同，与分组交换机厂商也可以不同</li>
</ul>
<p><img src="/images/wl_30_3.png" alt=""></p>
<h3 id="sdn控制器里的原件">SDN控制器里的原件</h3>
<p><img src="/images/wl_30_4.png" alt=""></p>
<p><font color=red>通信层</font>：SDN控制器和SDN交换机之间进行通信</p>
<p><font color=red>网络范围的状态管理层</font>：网络链路、交互设备和服务的状态：<font color=blue>分布式数据库</font></p>
<p><font color=red>网络控制应用的界面层</font>：抽象API</p>
<h2 id="openflow协议">OpenFlow协议</h2>
<ul>
<li>控制器和SDN交换机交互的协议</li>
<li>采用TCP来交换报文
<ul>
<li>加密可选</li>
</ul>
</li>
<li>3种OpenFlow报文类型
<ul>
<li>控制器 &gt; 交换机</li>
<li>异步（交换机 &gt; 控制器）</li>
<li>对称</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_30_5.png" alt=""></p>
<h3 id="控制器-交换机报文">控制器 - 交换机报文</h3>
<p><em>一些关键的控制器到交换机的报文</em></p>
<ul>
<li><font color=red>特性</font>：交换机<font color=blue>查询</font>交换机特性，交换机应答</li>
<li><font color=red>配置</font>：交换机查询/<font color=blue>设置</font>交换机的配置参数</li>
<li><font color=red>修改状态</font>：增加删除修改OpenFlow表中的流表</li>
<li><font color=red>packet-out</font>：控制器可以将分组通过特定的端口发出</li>
<li><font color=red>分组进入</font>：将分组（和它的控制）传给控制器，见来自控制器的packet-out报文</li>
<li><font color=red>流移除</font>：在交换机上删除流表项</li>
<li><font color=red>端口状态</font>：通告控制器报文端口的变化</li>
</ul>
<p>幸运的是，网络管理员不需要直接通过创建/发送流表来编程交换机，而是采用在控制器上的app自动运算和配置</p>
<h3 id="控制-数据平面交互的例子">控制 - 数据平面交互的例子</h3>
<p><img src="/images/wl_30_6.png" alt=""></p>
<ul>
<li>S1, 经历了链路失效，采用OpenFlow报文通告控制器:端口状态报文</li>
<li>SDN 控制器接收OpenFlow报文，更新链路状态信息</li>
<li>Dijkstra路由算法应用被调用（前面注册过这个状态变化消息）</li>
<li>Dijkstra路由算法访问控制器中的网络拓扑信息，链路状态信息计算新路由</li>
<li>链路状态路由app和SDN控制器中流表计算元件交互，计算出新的所需流表</li>
<li>控制器采用OpenFlow在交换机上安装新的需要更新的流表</li>
</ul>
<h3 id="opendaylight-odl控制器">OpenDaylight()ODL控制器</h3>
<p><img src="/images/wl_30_7.png" alt=""></p>
<ul>
<li>ODL Lithium 控制器</li>
<li>网络应用可以在SDN 控制内或者外面</li>
<li>服务抽象层SAL：和内部以及外部的应用以及服务进行交互</li>
<li>控制应用和控制器分离（应用app在控制器外部）</li>
<li>意图框架：服务的高级规范：描述什么而不是如何</li>
<li>相当多的重点聚焦在分布式核心上，以提高服务的可靠性，性能的可扩展性</li>
</ul>
<h2 id="sdn面临的挑战">SDN面临的挑战</h2>
<ul>
<li>强化控制平面：可信、可靠、性能可扩展性、安全的分布式系统
<ul>
<li>对于失效的鲁棒性： 利用为控制平面可靠分布式系统的强大理论</li>
<li>可信任，安全：从开始就进行铸造</li>
</ul>
</li>
<li>网络、协议要满足特殊任务的需求，例如实时性，超高可靠性、超高安全性</li>
<li>要满足互联网络范围内的扩展性而不是仅仅在一个AS的内部部署，全网部署</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——31数据链路层和局域网引论和服务</title>
    <url>/2024/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9431%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E5%BC%95%E8%AE%BA%E5%92%8C%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1>数据链路层和局域网</h1>
<p>WAN：网络形式采用点到点链路</p>
<ul>
<li>带宽大，距离远（延迟大）
<ul>
<li>贷款延迟积大</li>
</ul>
</li>
<li>如果采用多点连接方式
<ul>
<li>竞争方式：一旦冲突代价大</li>
<li>令牌等协调方式：在其中协调节点的发送代价大</li>
</ul>
</li>
</ul>
<p>点到点链路的链路层服务实现非常简单，封装和解封装</p>
<p>LAN一般采用多点连接方式</p>
<ul>
<li>连接节点非常方便</li>
<li>接到共享型介质上（或网络交换机），就可以连接所有其他节点</li>
</ul>
<p>多点连接方式网络的链路层功能实现相当复杂</p>
<ul>
<li>多点接入：协调各节点对共享型介质的访问和使用</li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生，占有和释放等</li>
</ul>
<h2 id="一些术语">一些术语</h2>
<ul>
<li><font color=red>nodes</font>：主机和路由器是节点（网桥和交换机也是）</li>
<li><font color=red>links</font>：沿着通信路径，连接各个相邻节点通信信道的是链路
<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网、共享性链路</li>
</ul>
</li>
<li><font color=red>frame</font>：第二层协议数据单元帧，封装数据报</li>
</ul>
<p><font color=red>数据链路层</font>负责从一个节点通过链路将（帧中的）数据报发送到<font color=red>物理相邻节点</font></p>
<h2 id="链路层：上下文">链路层：上下文</h2>
<p>数据报（分组）在不同的链路上以不同的链路协议传送：</p>
<ul>
<li>第一跳链路：以太网</li>
<li>中间链路：帧中继链路</li>
<li>最后一跳：802.11 (无线局域网通用的标准)</li>
</ul>
<p>不同的链路协议提供不同 的服务（比如在链路层上提供（ 或没有）可靠数据传送）</p>
<p><font color=red>传输类比</font></p>
<ul>
<li>从Princeton到Lausanne
<ul>
<li>轿车: Princeton to JFK</li>
<li>飞机: JFK to Geneva</li>
<li>火车: Geneva to Lausanne</li>
</ul>
</li>
<li>旅行者=数据报<font color=red>datagram</font></li>
<li>交通段=通信链路 <font color=red>communication link</font></li>
<li>交通模式=链路层协议 : <font color=red>数据链路层和局域网 protocol</font></li>
<li>票务代理=路由算法 <font color=red>routing algorithm</font></li>
</ul>
<h2 id="链路层服务">链路层服务</h2>
<p><font color=red>成帧，链路接入</font></p>
<ul>
<li>将数据报封装在帧中，加上帧头、尾部</li>
<li>如果采用的是共享性介质，信道接入获得信道访问权</li>
<li>在帧头部使用“MAC”（物理）地址来标示源和目的
<ul>
<li>不同于IP地址</li>
</ul>
</li>
</ul>
<p><font color=red>在相邻两个节点完成可靠数据传递</font></p>
<ul>
<li>第三章内容</li>
<li>在低出错率的链路上（光纤和双绞线电缆）很少使用</li>
<li>在无线链路经常使用：出错率高
<ul>
<li>Q：为什么在链路层和传输层都实现了可靠性</li>
<li><font color=red>一般化的链路服务，不是所有的链路层都提供这些服务，一个特定的链路层只是提供其中一部分的服务</font></li>
</ul>
</li>
</ul>
<p><font color=red>在相邻节点间进行可靠的转发</font></p>
<ul>
<li>第一章内容</li>
<li>在低差错链路上很少使用（光纤，一些双绞线）
<ul>
<li>出错率低，没有必要每一个帧中做差错控制的工作，协议复杂
<ul>
<li>发送端对每一帧进行差错控制编码，根据反馈做相应的动作</li>
<li>接收端进行差错控制编码，反馈给发送端（ACK，NAK）</li>
</ul>
</li>
<li>在本层放弃可靠控制的工作，在网络层或者是传输层做可靠控制的工作，或者根本就不做可靠控制的工作</li>
</ul>
</li>
<li>在高差错链路上需要进行可靠的数据传送
<ul>
<li>高差错链路：无线链路</li>
<li>Q：为什么要在采用无线链路的网络上，链路层做可靠数据传输工作；还要在传输层做端到端的可靠性工作？</li>
<li>原因：出错率高，如果在链路层不做无差别控制工作，漏出去的错误比较高；到了上层如果需要可靠控制的数据传输代价会很大
<ul>
<li>不做local recovery工作，总体代价大</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><font color=red>流量控制</font></p>
<ul>
<li>使得相邻的发送和接收方节点的速度匹配</li>
</ul>
<p><font color=red>错误检测</font></p>
<ul>
<li>差错由信号衰减和噪声引起</li>
<li>接收方检测出的错误：
<ul>
<li>通知发送端进行重传或丢弃帧</li>
</ul>
</li>
</ul>
<p><font color=red>差错纠正</font></p>
<ul>
<li>接收端检查和纠正bit错误，不通过重传来<font color=red>纠正</font>错误</li>
</ul>
<p><font color=red>半双工和全双工</font></p>
<ul>
<li>半双工：链路可以双向传输，但一次只有一个方向</li>
</ul>
<h2 id="链路层在哪里实现">链路层在哪里实现</h2>
<p>在每一个主机上</p>
<ul>
<li>也在每一个路由器上</li>
<li>交换器的每个端口上</li>
</ul>
<p>链路层功能在“适配器”上实现（aka <font color=red><em>network interface card</em></font> NIC）或者在一个芯片组上</p>
<ul>
<li>以太网卡，802.11网卡；以太网芯片组</li>
<li>实现链路层和相应的物理层功能</li>
</ul>
<p>接到主机的系统总线上</p>
<p>硬件、软件和固件的综合体</p>
<p><img src="/images/wl_31_1.png" alt=""></p>
<h2 id="适配器通信">适配器通信</h2>
<p><img src="/images/wl_31_2.png" alt=""></p>
<p>发送方：</p>
<ul>
<li>在帧中封装数据报</li>
<li>加上差错控制编码，实现RDT和流量控制功能</li>
</ul>
<p>接收方</p>
<ul>
<li>检查有无差错，执行rdt和流量控制功能等</li>
<li>解封装数据报，将之交给上层</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——32差错检测和纠正</title>
    <url>/2024/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9432%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3/</url>
    <content><![CDATA[<h1>差错检测和纠正</h1>
<h2 id="错误检测">错误检测</h2>
<p>EDC = 差错检测和纠错位（冗余位）<br>
D = 数据由差错检测保护，可以包含头部字段<br>
错误检测不是100%可靠的</p>
<ul>
<li>协议会泄露一些错误，但是很少</li>
<li>更长的EDC字段可以得到更好的检测和纠正效果</li>
</ul>
<p><img src="/images/wl_32_1.png" alt=""></p>
<h2 id="奇偶校验">奇偶校验</h2>
<h3 id="单bit奇偶校验">单bit奇偶校验</h3>
<p>检测单个bit级错误</p>
<p><img src="/images/wl_32_2.png" alt=""></p>
<h3 id="二维奇偶校检">二维奇偶校检</h3>
<p>检测和纠正单个bit错误</p>
<p><img src="/images/wl_32_3.png" alt=""></p>
<p><img src="/images/wl_32_4.png" alt=""></p>
<h2 id="internet校检和">Internet校检和</h2>
<p><font color=red>目标</font>：检测在传输报文时的错误（如位翻转），（注：仅仅用在传输层）<br>
<font color=red>发送方</font></p>
<ul>
<li>将报文段看成16-bit整数</li>
<li>报文段的校检和：和（1’的补码和）</li>
<li>发送方将checksum的值放在’UDP校检和’字段</li>
</ul>
<p><font color=red>接收方</font></p>
<ul>
<li><font color=red>计算</font>接收到的报文段的校检和</li>
<li>检查是否与<font color=red>携带</font>校检和字段值<font color=red>一致</font>
<ul>
<li>不一致：检出错误</li>
<li>一致：没有检出错误，但可能还是有错误</li>
</ul>
</li>
</ul>
<p><font color=red>有更简单的检查方法：全部加起来看是不是全1</font></p>
<h2 id="检验和：crc-循环冗余校检">检验和：CRC（循环冗余校检）</h2>
<ul>
<li>强大的差错检测码</li>
<li>将数据比特<font color=red> D </font>看成是二进制的数据</li>
<li>生成多项式<font color=red> G </font>：双方协商r + 1模式（r次方）
<ul>
<li>生成和检查所使用的位模式</li>
</ul>
</li>
<li>目标：选择r位CRC附加位R，使得
<ul>
<li>&lt;D,R&gt;正好被G整除（modulo 2）</li>
<li>接收方知道G，将&lt;D,R&gt;除以G，如果非0余数：检查出错误</li>
<li>能检出所有少于r + 1位的突发错误</li>
</ul>
</li>
<li>实际中广泛使用（以太网、802.11 WiFi、ATM）</li>
</ul>
<p><img src="/images/wl_32_5.png" alt=""></p>
<h3 id="crc例子">CRC例子</h3>
<p>需要：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>⋅</mo><msup><mn>2</mn><mi>r</mi></msup><mo>×</mo><mi>O</mi><mi>R</mi><mi>R</mi><mo>=</mo><mi>n</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">D\cdot 2^r \times OR R = nG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">G</span></span></span></span><br>
等价于：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>⋅</mo><msup><mn>2</mn><mi>r</mi></msup><mo>=</mo><mi>n</mi><mi>G</mi><mo>×</mo><mi>O</mi><mi>R</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">D\cdot 2^r = nG \times OR R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span><br>
等价于：<br>
两边同除G<br>
得到余数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">R = \cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>r</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>D</mi><mo>⋅</mo><msup><mn>2</mn><mi>r</mi></msup></mrow><mi>G</mi></mfrac></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">R =remainder \begin{bmatrix}
\frac{D\cdot 2^r}{G}
\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.27098em;vertical-align:-0.38549000000000005em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8854899999999999em;"><span style="top:-2.97451em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.91098em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mbin mtight">⋅</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.38549000000000005em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span></p>
<p>最后求得：<br>
<img src="/images/wl_32_6.png" alt=""></p>
<h3 id="crc性能分析">CRC性能分析</h3>
<ul>
<li>突发错误和突发长度</li>
<li>CRC检错性能描述
<ul>
<li>能够检查出所有的1bit错误</li>
<li>能够检查出所有的双bit的错误</li>
<li>能够检测出所有长度 = r或者 &lt;r 位的错误</li>
<li>出现长度为r + 1的突发错误，检查不出的概率是<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msup><mn>2</mn><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2^{r-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>出现长度大于r + 1的突发错误，检查不出的概率<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msup><mn>2</mn><mi>r</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2^r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——33多点访问协议</title>
    <url>/2024/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9433%E5%A4%9A%E7%82%B9%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1>多点访问协议</h1>
<h2 id="多路访问链路和协议">多路访问链路和协议</h2>
<p>两种类型的链路（一个子网内部链路连接形式）</p>
<ul>
<li><font color=red>点对点</font>
<ul>
<li>拨号访问的PPP</li>
<li>以太网交换机和主机之间的点对点链路</li>
</ul>
</li>
<li><font color=red>广播</font>
<ul>
<li>传统以太网</li>
<li>HFC上行链路</li>
<li>802.11无线局域网</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_33_1.png" alt=""></p>
<h2 id="多路访问协议">多路访问协议</h2>
<p>单个共享的广播型链路<br>
2个过更多结点同时传送：<font color=red>冲突</font></p>
<ul>
<li>多个结点在同一个时刻发送，则会收到2个或多个信号叠加</li>
</ul>
<p><font color=red>多路访问协议（介质访问控制协议：MAC）</font></p>
<ul>
<li>分布式算法 - 决定节点如何使用共享信道，即：决定节点什么时候可以发送</li>
<li>关于共享控制的通信必须用借助信道本身传输
<ul>
<li>没有外带的信道，各节点使用其协调信道使用</li>
<li>用于传输控制信息</li>
</ul>
</li>
</ul>
<h2 id="理想的多路访问协议">理想的多路访问协议</h2>
<p><font color=red>给定</font>：Rbps的广播信道<br>
<font color=red>必要条件</font></p>
<ol>
<li>当一个节点要发送时，可以R速率发送</li>
<li>当M个节点要发送，每个可以以R/M的平均速率发送</li>
<li>完全分布的
<ul>
<li>没有特殊节点协调发送</li>
<li>没有时钟和时隙的同步</li>
</ul>
</li>
<li>简单</li>
</ol>
<h2 id="mac-媒体访问控制-协议：分类">MAC（媒体访问控制）协议：分类</h2>
<p>3大类</p>
<ul>
<li><font color=red>信道划分</font>
<ul>
<li>把信道划分为小片（时间、频率、编码）</li>
<li>分配片给每个节点专用</li>
</ul>
</li>
<li><font color=red>随机访问</font>
<ul>
<li>信道不划分，允许冲突</li>
<li>冲突后恢复</li>
</ul>
</li>
<li><font color=red>依次轮流</font>
<ul>
<li>节点依次轮流</li>
<li>但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul>
</li>
</ul>
<h3 id="信道划分mac协议">信道划分MAC协议</h3>
<h4 id="tdma">TDMA</h4>
<p><font color=red>TMDA：time division multiple access</font></p>
<ul>
<li>轮流使用信道，信道的时间分为周期</li>
<li>每个站点使用每周期中固定的时隙（长度 = 帧传输时间）传输帧</li>
<li>如果站点无帧传输，时隙空闲 -&gt; 浪费</li>
<li>如：6站LAN：1,3,4有数据报，时隙2,5,6空闲</li>
</ul>
<p><img src="/images/wl_33_2.png" alt=""></p>
<h4 id="fdma">FDMA</h4>
<p><font color=red>FDMA：frequency division multiple access</font></p>
<ul>
<li>信道的有效频率范围被分为一个个小的频段</li>
<li>每个站点被分配一个固定的频段</li>
<li>分配给站点的频段如果没有被使用，则空闲</li>
<li>例如：6站的LAN，1,3,4有数据报，频段2,5,6空闲</li>
</ul>
<p><img src="/images/wl_33_3.png" alt=""></p>
<h4 id="码分多路访问-cdma">码分多路访问（CDMA）</h4>
<ul>
<li>CDMA(code division multiple access)
<ul>
<li>所有站点在整个频段上同时进行传输，采用编码原理加以区分</li>
<li>完全无冲突</li>
<li>假定：信号同步很好，线性叠加</li>
</ul>
</li>
<li>比方
<ul>
<li>TDM：不同的人在不同的时刻讲话</li>
<li>FDM：不同的组在不同的小房间里通信</li>
<li>CDMA：不同的人使用不同的语言讲话</li>
</ul>
</li>
</ul>
<h3 id="随机存取协议">随机存取协议</h3>
<ul>
<li>当节点有帧要发送时
<ul>
<li>以信道带宽的全部R bps发送</li>
<li>没有节点间的预先协调</li>
</ul>
</li>
<li>两个或更多节点同时传输，会发生 -&gt; 冲突</li>
<li><font color=red>随机存取协议规定</font>
<ul>
<li>如何检测冲突</li>
<li>如何从冲突中恢复（如：通过稍后的重传）</li>
</ul>
</li>
<li>随机MAC协议
<ul>
<li>时隙ALOHA</li>
<li>ALOHA</li>
<li>CSMA、<font color=red>CSMA/CD、CSMA/CA</font></li>
</ul>
</li>
</ul>
<h4 id="时隙aloha">时隙ALOHA</h4>
<p><font color=red>假设</font></p>
<ul>
<li>所有的帧都是等长的</li>
<li>时间被划分成相等的时隙，每个时隙可发送一帧</li>
<li>节点只在时隙开始时发送帧</li>
<li>节点在时钟上是同步的</li>
<li>如果两个或多个节点在一个时隙传输，所有的站点都能检测到冲突</li>
</ul>
<p><font color=red>运行</font></p>
<ul>
<li>当节点获取新的帧，在下一个时隙传输</li>
<li>传输时没有检测到冲突，成功
<ul>
<li>节点能够在下一时刻发送新帧</li>
</ul>
</li>
<li>检测时如果检测到冲突，失败
<ul>
<li>节点在每一个随后的时隙以概率p重传帧直到成功</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_33_4.png" alt=""></p>
<p><font color=red>优点</font></p>
<ul>
<li>节点可以以信道带宽全部连续传输</li>
<li>高度分布：仅需要节点之间在间隙上的同步</li>
<li>简单</li>
</ul>
<p><font color=red>缺点</font></p>
<ul>
<li>存在冲突，浪费时间</li>
<li>即使有帧要发送，仍然有可能存在空闲的时隙</li>
<li>节点检测冲突的时间 &lt; 帧传输的时间
<ul>
<li>必须传完</li>
</ul>
</li>
<li>需要时钟上同步</li>
</ul>
<h5 id="时隙aloha的效率">时隙ALOHA的效率</h5>
<p><font color=red>效率</font>：当有很多节点，每个节点有很多帧要发送时，x%的时隙是成功传输帧的时隙</p>
<ul>
<li>假设N个节点，每个节点都有很多帧要发送，在每个时隙中的传输概率是p</li>
<li>一个节点成功传输概率是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">p(1-p)^{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>任何一个节点的成功概率是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">Np(1-p)^{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>N个节点的最大效率：求出使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">f(P) = Np(1-p)^{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 最大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">p^ *</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></li>
<li>代入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">p^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>得到最大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msup><mi>p</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(p^{*})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>N为无穷大时的极限为1/e = 0.37</li>
</ul>
<p><font color=red>最好情况，信道利用率为37%</font></p>
<h4 id="纯aloha">纯ALOHA</h4>
<ul>
<li>无时隙ALOHA：简单、无需节点间在时间上同步</li>
<li>当有帧需要传输：马上传输</li>
<li>冲突的概率增加：
<ul>
<li>帧在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>发送，和其他在$[t_0 - 1,t_0 + 1]区间内开始发送的帧冲突</li>
<li>和当前帧冲突的区间（其他帧再次区间开始传输）增大了一倍</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_33_5.png" alt=""></p>
<h5 id="纯aloha的效率">纯ALOHA的效率</h5>
<p>P(指定节点成功) = P(节点传输)<br>
P(其他节点在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[t_0 - 1,t_0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>不传)<br>
P(其他节点在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[t_0,t_0 + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>不传)<br>
= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mi>p</mi><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">p \cdot (1-p)^{N-1} \cdot (1-p)^{N-1} =p \cdot (1-p)^{2(N-1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span><br>
选择最佳的p、N趋向无穷大<br>
= 1/(2e) = 17.5%</p>
<p><font color=red>效率比时隙ALOHA更差了</font></p>
<h5 id="csma冲突">CSMA冲突</h5>
<p><font color=red>冲突仍然可能发生</font><br>
由传播延迟造成：两个节点可能侦听不到正在进行的传输</p>
<p><font color=red>冲突</font><br>
整个冲突帧的传输时间都被浪费了，是无效的传输（红黄区域）</p>
<p><font color=red>注意</font><br>
传播延迟（距离）决定了冲突的概率<br>
节点依据本地的信道使用情况来判断全部信道的使用情况</p>
<p><img src="/images/wl_33_6.png" alt=""></p>
<h4 id="csma-cd-冲突检测">CSMA/CD（冲突检测）</h4>
<p><font color=red>CSMA/CD</font></p>
<ul>
<li>载波倾听CSMA：和在CSMA中一样发送前倾听信道</li>
<li>没有传完一个帧就可以在短时间内检测到冲突</li>
<li>冲突发生时则传输终止，减少对信道的浪费</li>
</ul>
<p>冲突检测CD技术，有线局域网中容易实现</p>
<ul>
<li>检测信号强度，比较传输与接收到的信号是否相同</li>
<li>通过周期的过零点检测</li>
</ul>
<p>人类类比：礼貌的对话人</p>
<p><img src="/images/wl_33_7.png" alt=""></p>
<h5 id="以太网csma-cd算法">以太网CSMA/CD算法</h5>
<ol>
<li>适配器获取数据报，创建帧</li>
<li>发送前：监听信道CS
<ol>
<li>闲：开始传输帧</li>
<li>忙：一直等到闲再发送</li>
</ol>
</li>
<li>发送过程中，冲突检测CD
<ol>
<li>没有冲突：成功</li>
<li>检测到冲突：放弃，之后尝试重发</li>
</ol>
</li>
<li>发送方适配器检测到冲突，除放弃外，还发送一个Jam信号，所有听到冲突的适配器也是如此<br>
<font color=red>强化冲突：让所有站点都知道冲突</font></li>
<li>如果放弃，适配器进入指数退避状态<br>
在第m次失败后，适配器随机选择一个(0,1,2,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>)中K，等待<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo>∗</mo></msup><mn>512</mn></mrow><annotation encoding="application/x-tex">K^*512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span>位时，然后转到步骤2<br>
<font color=red>exponential backoff 二进制指数退避算法</font></li>
</ol>
<p><font color=red>指数退避</font></p>
<ul>
<li>目标：适配器试图适应当前负载，在一个变化的碰撞窗口中随机选择时间点尝试重发
<ul>
<li>高负载：重传窗口时间大，减少冲突，但等待时间长</li>
<li>低负载：使得各站点等待时间少，但冲突概率大</li>
</ul>
</li>
<li>首次碰撞：在{0,1}选择K，延迟<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo>∗</mo></msup><mn>512</mn></mrow><annotation encoding="application/x-tex">K^*512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span>位时</li>
<li>第2次碰撞：在{0,1,2,3}选择K</li>
<li>第10次碰撞：在{0,1,2,3,…,1023}选择K</li>
</ul>
<h5 id="csma-cd效率">CSMA/CD效率</h5>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{prop}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> = LAN上2个节点的最大传播延迟</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{trans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 传输最大帧的时间<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mn>5</mn><msub><mi>t</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi></mrow></msub><mi mathvariant="normal">/</mi><msub><mi>t</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">efficiency = \frac{1}{1 + 5t_{prop}/t_{trans}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3874279999999999em;vertical-align:-0.5423199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29634285714285713em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5423199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>效率变为1
<ul>
<li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{prop}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>变成0时</li>
<li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{trans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>变为无穷大时</li>
</ul>
</li>
<li>比起ALOHA更好的性能，而且简单，廉价，分布式</li>
</ul>
<h4 id="无线局域网csma-ca">无线局域网CSMA/CA</h4>
<p><img src="/images/wl_33_8.png" alt=""></p>
<p>WLAN构成</p>
<ul>
<li>基站：AP</li>
<li>无线链路</li>
<li>移动主机节点</li>
</ul>
<h5 id="无线局域网中的mac：csma-ca">无线局域网中的MAC：CSMA/CA</h5>
<ul>
<li>冲突：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">2^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>站点（AP或者站点）在同一时刻发送</li>
<li>802.11：CSMA - 发送前侦听信道
<ul>
<li>不会和其他节点正在进行的传输发生冲突</li>
</ul>
</li>
<li>802.11：没有冲突检测
<ul>
<li>无法检测冲突：自身信号远远大于其他信号节点</li>
<li>即使能CD：冲突 != 成功</li>
<li>目标：<font color=red>avoid collisions</font>：CSMA/C(collision)A(voidance)
<ul>
<li>无法CD：一旦发送一股脑全部发送完毕，不CD</li>
<li>为了避免无CD带来的信道利用率低的问题，事前进行冲突避免</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="无线局域网：csma-ca">无线局域网：CSMA/CA</h5>
<p><font color=red>发送方</font></p>
<ol>
<li>如果站点检测到信道空闲持续DIFS长，则传输整个帧(no CD)</li>
<li>如果检测到信道忙碌，那么选择一个随机回退值，并在信道空闲时递减该值；如果信道忙碌，回退值不会变化；到数到0时（只生在信道闲时）发送整个帧，如果没有收到ACK，增加回退值并对之进行重复</li>
</ol>
<p><font color=red>802.11接收方</font></p>
<ul>
<li>如果帧正确，则在SIFS后发送ACK</li>
</ul>
<p>无线链路特性，需要每帧确认；例如：由于隐藏终端问题，在接收端可能形成干扰，接收方没有正确的收到，链路层可靠机制）</p>
<p><img src="/images/wl_33_9.png" alt=""></p>
<h5 id="ieee-802-11-mac-协议：csma-ca">IEEE 802.11 MAC 协议：CSMA/CA</h5>
<p>在count down时，侦听到了信道空闲为什么不发送，而要等到0时再发送</p>
<ul>
<li>2个站点有数据帧需要发送，第三个节点正在发送</li>
<li><font color=blue>LAN CD：让2者听完第三个节点发完，立即发送
<ul>
<li>冲突：放弃当前的发送，避免了信道的浪费于无用冲突帧的发送</li>
<li>代价不昂贵</font></li>
</ul>
</li>
<li>WLAN:CA
<ul>
<li>无法CD，一旦发送就必须发完，如冲突信道浪费严重，代价高昂</li>
<li>思想：尽量<font color=red>事先避免</font>冲突，而不是在发生冲突时放弃然后重发</li>
<li>听到发送的站点，分别选择随机值，回退到0发送
<ul>
<li>不同的随机值，一个站点会胜利</li>
<li>失败站点会冻结计数器，当胜利节点发完再发</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>无法完全避免冲突</p>
<ul>
<li>两个站点相互隐藏
<ul>
<li>A，B相互隐藏，C在传输</li>
<li>A，B选择了随机回退值</li>
<li>一个节点如A胜利了，发送</li>
<li>而B节点收不到，顺利count down到0发送</li>
<li>A，B的发送在C附近形成了干扰</li>
</ul>
</li>
<li>选择了非常靠近的随机回退值
<ul>
<li>A，B选择的值非常近</li>
<li>A到0后发送</li>
<li>但是这个信号还没到达B时</li>
<li>B也到0了，发送</li>
<li>冲突</li>
</ul>
</li>
</ul>
<h5 id="冲突避免-rts-cts交换">冲突避免 RTS - CTS交换</h5>
<p><font color=red>思路</font>：允许发送方“预约”信道，而不是随机访问该信道：避免长数据帧的冲突（可选项）</p>
<ul>
<li>发送方首先使用CSMA向BS发送一个小的RTS分组
<ul>
<li>RTS可能会冲突（但是由于比较短，浪费信道较少）</li>
</ul>
</li>
<li>BS广播 clear - to - send CTS，作为RTS的相应</li>
<li>CTS能够被所有涉及到的节点听到
<ul>
<li>发送方发送数据帧</li>
<li>其他节点抑制发送</li>
</ul>
</li>
</ul>
<p>采用小的预约分组，可以完全避免数据帧的冲突</p>
<p><img src="/images/wl_33_10.png" alt=""></p>
<h4 id="线缆接入网络">线缆接入网络</h4>
<p><img src="/images/wl_33_11.png" alt=""></p>
<ul>
<li><font color=red>多个</font>40Mps 下行（广播）信道，FDM
<ul>
<li>下行：通过FDM分成若干信道，互联网、数字电视等</li>
<li>互联网信道：只有1个CMTS在其上传输</li>
</ul>
</li>
<li><font color=red>多个</font>30Mps 上行的信道，FDM
<ul>
<li><font color=red>多路访问</font>：所有用户使用：接着TDM分成微时隙</li>
<li>部分时隙分配，部分时隙竞争</li>
</ul>
</li>
</ul>
<p><font color=red>DOCSIS</font>：TDM上行信道</p>
<ul>
<li>采用TDM的方式将上行信道分成若干微时隙：MAP指定</li>
<li>站点采用分配给他的微时隙上行数据传输：分配</li>
<li>在特殊的上行微时隙中，各站点请求上行微时隙：竞争
<ul>
<li>各站点对于该时隙的使用是随机访问的</li>
<li>一旦碰撞（请求不成功，结果是：在下行的MAP中没有为他分配，则二进制退避）选择时隙上传输</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_33_12.png" alt=""></p>
<h3 id="轮流-mac-协议">轮流 MAC 协议</h3>
<p>信道划分MAC协议：</p>
<ul>
<li>共享信道在高负载时是有效和公平的</li>
<li>在低负载时效率低下
<ul>
<li>只能等到自己的时隙开始发送或者利用1/N的信道频率发送</li>
<li>当只有一个节点有帧传时，也只能够得到1/N个带宽分配</li>
</ul>
</li>
</ul>
<p>随机访问MAC协议</p>
<ul>
<li>在低负载时效率高：单个节点完全可以利用信道全部带宽</li>
<li>高负载时，冲突开销较大，效率极低，时间很多浪费在冲突中</li>
</ul>
<p><font color=red>轮流协议</font></p>
<ul>
<li>有二者的优点</li>
</ul>
<p><font color=red>轮询</font></p>
<ul>
<li>主节点邀请从节点依次传送</li>
<li>从节点一般比较“dumb”</li>
<li>缺点
<ul>
<li>轮询开销：轮训本身消耗信道带宽</li>
<li>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能够发送</li>
<li>单点故障：主节点失效时造成整个系统无法工作</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_33_13.png" alt=""></p>
<p><font color=red>令牌传递</font></p>
<ul>
<li>控制<font color=red>令牌(token)</font>循环从一个节点到下一个节点传递</li>
<li>令牌报文：特殊的帧</li>
<li>缺点
<ul>
<li>令牌开销：本身消耗带宽</li>
<li>延迟：只有等到抓住令牌，才可传输</li>
<li>单点故障
<ul>
<li>令牌丢失系统级故障，整个系统无法传输</li>
<li>复杂机制重新生成令牌</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_33_14.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——34LANs</title>
    <url>/2024/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9434LANs/</url>
    <content><![CDATA[<h1>LANs</h1>
<h2 id="mac地址和arp">MAC地址和ARP</h2>
<ul>
<li>32bit IP地址
<ul>
<li>网络层地址</li>
<li>用于使数据到达目标IP子网：前n - 1跳</li>
<li>从而到达子网中的目标节点：最后一跳</li>
</ul>
</li>
<li>LAN（MAC/物理/以太网）地址：
<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡（在同一个物理网络中）</li>
<li>48bit MAC地址固化在适配器的ROM，有时也可以通过软件设定</li>
<li>理论上全球任何2个网卡的MAC地址都不相同</li>
<li>e.g：1A-2F-BB-76-09-AD</li>
</ul>
</li>
</ul>
<h3 id="网络地址和mac地址分离">网络地址和mac地址分离</h3>
<p>IP地址和MAC地址的作用不同</p>
<ol>
<li>IP地址是分层的
<ol>
<li>一个子网所有站点网络号一致，路由聚集，减少路由表
<ol>
<li>需要一个网络中的站点网络号一致，如果捆绑需要定制网卡非常麻烦</li>
</ol>
</li>
<li>希望网络层地址是配置的：IP地址完成网络到网络的交付</li>
</ol>
</li>
<li>mac地址是一个<font color=red>平面</font>的
<ol>
<li>网卡在生产时不知道被用于哪个网络，因此给网卡一个唯一的标示，用于区分一个网络内部不同的网卡即可</li>
<li>可以完成一个物理网络内部的节点到节点的数据交付</li>
</ol>
</li>
</ol>
<p>分离好处</p>
<ul>
<li>网卡坏了，ip不变，可以捆绑到另外一个网卡的mac上</li>
<li>物理网络还可以除IP之外支持其他网络层协议，链路协议为上层网络协议，如IPX等</li>
</ul>
<p>捆绑的问题</p>
<ul>
<li>如果仅仅使用IP地址，不是mac地址，那么它仅支持IP协议</li>
<li>每次上电都要重新写入网卡IP地址</li>
<li>另外一个选择就是不使用任何地址：不用MAC地址，则每到来一个帧都要上传到IP层次，由它判断是不是需要接受，干扰一次</li>
</ul>
<h2 id="lan地址和arp">LAN地址和ARP</h2>
<ul>
<li>
<p>局域网上每个适配器都有一个唯一的<font color=red>LAN</font>地址<br>
<img src="/images/wl_34_1.png" alt=""></p>
</li>
<li>
<p>MAC地址由IEEE管理和分配</p>
</li>
<li>
<p>制造商购入MAC地址空间（保证唯一性）</p>
</li>
<li>
<p>类比：</p>
<ul>
<li>MAC地址：社会安全号</li>
<li>IP地址：通讯地址</li>
</ul>
</li>
<li>
<p>MAC平面地址 -&gt; 支持移动</p>
<ul>
<li>可以将网卡接到其他网络</li>
</ul>
</li>
<li>
<p>IP地址有层次 - 不能移动</p>
<ul>
<li>依赖于节点连接的IP子网，与子网的网络号相同（有与其相连的子网相同的网络前缀）</li>
</ul>
</li>
</ul>
<h3 id="arp">ARP</h3>
<p>问题：已知B的IP地址，如何确定B的MAC地址</p>
<ul>
<li>在LAN上的每个IP节点都有一个<font color=red>ARP</font>表</li>
<li>ARP表：包括一些LAN节点IP/MAC地址的映射<br>
<font color=red>&lt;TP address MAC address TTL&gt;</font>
<ul>
<li>TTL时间是指地址映射失效的时间</li>
<li>典型是20min</li>
</ul>
</li>
</ul>
<h3 id="路由到其他lan">路由到其他LAN</h3>
<p>Walkthrough：发送数据报：由A通过R到B，假设A知道B的IP地址</p>
<ul>
<li>在R上有两个ARP表，分别对应两个LAN</li>
<li>在源主机的路由表中，发现到目标主机的下一跳时111.111.111.110</li>
<li>在源主机的ARP表中，发现其MAC地址是E6-E9-00-17-BB-4B,etc</li>
</ul>
<p><img src="/images/wl_34_2.png" alt=""></p>
<h4 id="编址：路由到其他lan">编址：路由到其他LAN</h4>
<p><img src="/images/wl_34_3.png" alt=""></p>
<p><img src="/images/wl_34_4.png" alt=""></p>
<p><img src="/images/wl_34_5.png" alt=""></p>
<p><img src="/images/wl_34_6.png" alt=""></p>
<h2 id="以太网">以太网</h2>
<ul>
<li>目前最流行的LAN技术：98%占有率</li>
<li>廉价：30元RMB 100Mbps</li>
<li>最早广泛应用的LAN技术</li>
<li>比令牌网和ATM网络简单、廉价</li>
<li>带宽不断提升：10M、100M、1G、10G</li>
</ul>
<p><img src="/images/wl_34_7.png" alt=""></p>
<h3 id="以太网：物理拓扑">以太网：物理拓扑</h3>
<ul>
<li><font color=red>总线</font>：在上个世纪90年代中期很流行
<ul>
<li>所有节点在一个碰撞域内，依次只允许一个节点发送</li>
<li>可靠性差，如果介质破损，截面形成信号的反射，发送节点认为是冲突，总是冲突</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_34_8.png" alt=""></p>
<ul>
<li>
<ul>
<li><font color=red>星型</font>：目前最主流
<ul>
<li>连接选择：hub或者switch</li>
<li>现在一般是交换机在中心</li>
<li>每个节点以及相连的交换机端口使用（独立的）以太网协议（不会和其他节点的发送产生碰撞）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_34_9.png" alt=""></p>
<h3 id="以太帧结构">以太帧结构</h3>
<p>发送方适配器在<font color=red>以太网帧</font>中封装IP数据报，或其他网络层协议数据单元</p>
<p><img src="/images/wl_34_10.png" alt=""></p>
<p><font color=red>前导码</font></p>
<ul>
<li>7B 10101010 + 1B 10101011</li>
<li>用来同步接收方和发送方的时钟速率
<ul>
<li>使得接收方将自己的时钟调到发送端的时钟</li>
<li>从而可以按照发送端的时钟来接收所发送的帧</li>
</ul>
</li>
</ul>
<p><font color=red>地址</font>：6字节源MAC地址，目标MAC地址</p>
<ul>
<li>如：帧目标地址 = 本站MAC地址，或是广播地址，接收，递交帧中的数据到网络层</li>
<li>否则，适配器忽略该帧</li>
</ul>
<p><font color=red>类型</font>：指出高层协议（大多情况下是IP，但也支持其他网络层协议Novell IPX和Apple Talk）</p>
<p><font color=red>CRC</font>：在接收方校检</p>
<ul>
<li>如果没有通过校检，丢弃错误帧</li>
</ul>
<h3 id="以太网：无连接-不可靠的服务">以太网：无连接、不可靠的服务</h3>
<ul>
<li><font color=red>无连接</font>：帧传输前，发送方和接收方之间没有握手</li>
<li><font color=red>不可靠</font>：接收方适配器不发送ACKs或NAKs给发送方
<ul>
<li>递交给网络层的数据报流可能有gap</li>
<li>如上层使用像传输层TCP协议这样的rdt，gap会被补上（源主机，TCP实体）</li>
<li>否则，应用层会看到gap</li>
</ul>
</li>
<li>以太网的MAC协议：采用<font color=red>二进制退避的CSMA/CD</font>介质访问控制形式</li>
</ul>
<h3 id="以太网标准：链路层和物理层">以太网标准：链路层和物理层</h3>
<ul>
<li><font color=red>很多</font>不同的以太网标准
<ul>
<li>相同的MAC协议（介质访问控制）和帧结构</li>
<li>不同的速率：2 Mbps、10 Mbps、100 Mbps、1Gbps、10Gbps</li>
<li>不同的物理层标准</li>
<li>不同的物理层媒介：光纤，同轴电缆和双绞线</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_34_11.png" alt=""></p>
<h3 id="以太网使用csma-cd">以太网使用CSMA/CD</h3>
<ul>
<li>没有时隙</li>
<li>NIC如果侦听到其他NIC在发送就不发送：载波侦听(<font color=red>carrier sence</font>)</li>
<li>发送时，适配器当侦听到其他适配器在发送就放弃对当前帧的发送：冲突检测(<font color=red>collision detection</font>)</li>
<li>冲突后尝试重传，重传前适配器等待一个随机时间：随机访问(<font color=red>random access</font>)</li>
</ul>
<h3 id="10baset-and-100baset">10BaseT and 100BaseT</h3>
<ul>
<li>100Mbps速率也被称之为&quot;fast ethernet&quot;</li>
<li>T代表双绞线</li>
<li>节点连接到HUB上：&quot;star topology&quot;物理上是星型
<ul>
<li>逻辑上总线型，盒中总线</li>
</ul>
</li>
<li>节点和HUB间的最大距离是100m</li>
</ul>
<h3 id="hubs">Hubs</h3>
<p>Hubs本质上是物理层的中继器</p>
<ul>
<li>从一个端口收，转发到所有其他端口</li>
<li>速率一致</li>
<li>没有帧的缓存</li>
<li>在hub接口端没有CSMA/CD机制：适配器检测冲突</li>
<li>提供网络管理服务</li>
</ul>
<h3 id="manchester编码">Manchester编码</h3>
<p><img src="/images/wl_34_12.png" alt=""></p>
<ul>
<li>在10BaseT中使用</li>
<li>每一个bit的位时中间有一个信号跳变</li>
<li>允许在接收方和发送方节点之间进行时钟同步
<ul>
<li>节点间不需要集中的和全局的时钟</li>
</ul>
</li>
<li>10Mbps，使用20M带宽，效率50%</li>
</ul>
<h3 id="千兆以太网">千兆以太网</h3>
<ul>
<li>采用标准的以太帧格式</li>
<li>允许点对点链路和共享广播信道</li>
<li>物理编码：8b10b编码</li>
<li>在共享模式，继续使用CSMA/CA MAC技术，节点间需要较短距离以提高利用率</li>
<li>交换模式：全双工千兆可用与点对点链路
<ul>
<li>站点使用专用信道，基本不会冲突，效率高</li>
<li>除非发往同一个目标点</li>
</ul>
</li>
</ul>
<h2 id="hub：集线器">Hub：集线器</h2>
<ul>
<li>网段(LAN segments)：可以允许一个站点发送的网络范围
<ul>
<li>在一个碰撞域，同时只允许一个站点在发送</li>
<li>如果有2个节点同时发送，则会碰撞</li>
<li>通常有相同的词缀，比IP子网更详细的前缀</li>
</ul>
</li>
<li>所有以hub连到一起的站点处在一个网段，处在一个碰撞域
<ul>
<li>骨干hub将所有网段连接到了一起</li>
</ul>
</li>
<li>通过hub可拓展节点之间的最大距离</li>
<li>通过HUB，不能将10BaseT和100BaseT的网络连接到一起</li>
</ul>
<p><img src="/images/wl_34_13.png" alt=""></p>
<h2 id="交换机">交换机</h2>
<ul>
<li><font color=red>链路层设备：扮演主动角色（端口执行以太网协议）</font>
<ul>
<li>对帧进行存储和转发</li>
<li>对于到来的帧，检查帧头，根据目标MAC地址进行<fong color=red>选择性转发</font></li>
<li>当帧需要向某个（些）网段进行转发，需要使用CSMA/CD进行接入控制</li>
<li>通常一个交换机端口一个独立网段</li>
</ul>
</li>
<li><font color=red>透明</font>：主机对交换机的存在可以不关心
<ul>
<li>通过交换机相连的各节点好像这些站点是直接相连的一样</li>
<li>有MAC地址：无IP地址</li>
</ul>
</li>
<li><font color=red>即插即用、自学习</font>
<ul>
<li>交换机无需配置</li>
</ul>
</li>
</ul>
<h3 id="交换机：多路同时传输">交换机：多路同时传输</h3>
<ul>
<li>主机有一个<font color=red>专用</font>和<font color=red>直接</font>到交换机的连接</li>
<li>交换机缓存到来的帧</li>
<li>对每个帧进入链路使用以太网协议，没有碰撞：全双工
<ul>
<li>每条链路都是一个独立的碰撞域</li>
<li>MAC协议在其中的作用弱化了</li>
</ul>
</li>
<li><font color=red>交换</font>：A - to - A’ 和 B - to - B’可以同时传输，没有碰撞</li>
</ul>
<p><img src="/images/wl_34_14.png" alt=""></p>
<h3 id="交换机转发表">交换机转发表</h3>
<p>Q：交换机如何知道通过接口1到达A，通过接口5到达B’？</p>
<p>A：每个交换机都有一个交换表(<font color=red>switch table</font>)，每个表项：</p>
<ul>
<li>主机的MAC地址，到达该MAC经过的接口、时戳）</li>
<li>比较像路由表</li>
</ul>
<h3 id="交换机：自学习">交换机：自学习</h3>
<p>交换机通过<font color=red>学习</font>得到哪些主机（mac地址）可以通过哪些端口到达</p>
<ul>
<li>当接收到帧，交换机学习到发送站点所在的端口（网段）</li>
<li>记录发送方MAC地址/进入端口映射关系在交换表中</li>
</ul>
<p><img src="/images/wl_34_15.png" alt=""></p>
<h3 id="交换机：过滤-转发">交换机：过滤/转发</h3>
<p>当交换机接收到一个帧：</p>
<ul>
<li>记录进入链路，发送主机的MAC地址</li>
<li>使用目标MAC地址对交换表进行索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果在转发表中找到了目标项</span><br><span class="line">if entry found for destination</span><br><span class="line">then&#123;</span><br><span class="line">    //如果目标MAC就是对应着进来的端口</span><br><span class="line">    if dest on segment from which frame arrived //过滤</span><br><span class="line">        //抛弃掉该帧</span><br><span class="line">        then drop the frame</span><br><span class="line">    //转发</span><br><span class="line">    else forward the frame on interface indicated</span><br><span class="line">    &#125;</span><br><span class="line">//泛洪</span><br><span class="line">else found</span><br></pre></td></tr></table></figure>
<h3 id="交换机-vs-路由器">交换机 vs. 路由器</h3>
<p><img src="/images/wl_34_16.png" alt=""></p>
<ul>
<li>都是存储转发设备，但层次不同
<ul>
<li>交换机：链路层设备（检查链路层头部）</li>
<li>路由器：网络层设备（检查网络层的头部）</li>
</ul>
</li>
<li>都有转发表
<ul>
<li><font color=red>交换机</font>：维护交换表，按照MAC地址转发
<ul>
<li>执行过滤、自学习和生成树算法</li>
<li>即插即用：二层设备，速率高</li>
<li>执行生成树算法，限制广播帧的转发</li>
<li>ARP表项随着站点数量增多而增多</li>
</ul>
</li>
<li><font color=red>路由器</font>：维护路由表，执行路由算法
<ul>
<li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络</li>
<li>对广播分组做限制</li>
<li>不是即插即用的，配置网络地址（子网前缀）</li>
<li>三层设备，速率低</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_34_17.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——35什么是网络安全</title>
    <url>/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9435%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1>什么是网络安全</h1>
<ul>
<li><font color=red>机密性</font>：只有发送方和预订的接收方能否理解传输的报文内容
<ul>
<li>发送方加密报文</li>
<li>接收方解密报文</li>
</ul>
</li>
<li><font color=red>认证</font>：发送方和接收方需要确认对方的身份</li>
<li><font color=red>报文完整性</font>：发送方、接收方需要确认的报文在传输的过程中或者事后没有被改变</li>
<li><font color=red>访问控制和服务的可用性</font>：服务可以接入以及对用户而言是可用的</li>
</ul>
<h2 id="朋友和敌人：alice-bob-trudy">朋友和敌人：Alice,Bob,Trudy</h2>
<ul>
<li>网络安全世界比较著名的模型</li>
<li>Bob,Alice(loversl)需要安全的通信</li>
<li>Trudy(intruder)可以截获，删除和增加报文</li>
</ul>
<p><img src="/images/wl_35_1.png" alt=""></p>
<h3 id="谁有可能是alice-bob">谁有可能是Alice,Bob</h3>
<ul>
<li>电子交易中的Web browser/server(e.g. 在线购买)</li>
<li>在线银行的client/server</li>
<li>DNS servers</li>
<li>路由信息的交换</li>
</ul>
<h3 id="网络中的坏蛋">网络中的坏蛋</h3>
<p>Q：&quot;bad guy&quot;可以干什么？<br>
A：很多</p>
<ul>
<li><font color=red>窃听</font>：截获报文</li>
<li><font color=red>插入</font>：在连接中插入报文</li>
<li><font color=red>伪装</font>：可以在分组的源地址写上伪装的地址</li>
<li><font color=red>劫持</font>：将发送方或者接收方踢出，接管连接</li>
<li><font color=red>拒绝服务</font>：阻止服务被其他正常用户使用(e.g. 通过对资源的过载使用)</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——36加密原理</title>
    <url>/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9436%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1>加密原理</h1>
<h2 id="加密语言">加密语言</h2>
<p><img src="/images/wl_36_1.png" alt=""></p>
<p><font color=red>对称密钥密码学</font>：发送方和接收方的秘钥相同<br>
<font color=red>公开秘钥密码学</font>：发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密</p>
<h2 id="对称秘钥加密">对称秘钥加密</h2>
<p><font color=red>替换密码</font>：将一个事情换成另一个事情</p>
<ul>
<li>单码替换密码：将一个字母替换成另一个字母</li>
</ul>
<p><img src="/images/wl_36_2.png" alt=""></p>
<p><font color=red>对称密钥密码</font>：Bob和Alice共享一个对称式的秘钥：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mo>−</mo><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{A-B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>e.g. 秘钥在单码替换加密方法中是替换模式</li>
</ul>
<h3 id="对称密钥加密学：des">对称密钥加密学：DES</h3>
<p><font color=red>DES:Data Encryption Standard</font></p>
<ul>
<li>US加密标准[NIST 1993]</li>
<li>56-bit对称密码，64-bit明文输入</li>
<li>DES有多安全？
<ul>
<li>DES挑战：56-bit密钥加密的短语(“Strong cryptography makes the world a safe place”)被解密，用了4个月的时间</li>
<li>可能有后门</li>
</ul>
</li>
<li>使得DES更安全：
<ul>
<li>使用3个key，3条DES运算</li>
<li>密文分组成串技术</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_36_3.png" alt=""></p>
<p>初始替换<br>
16轮一样的函数应用，每一轮使用的不同的48bit秘钥<br>
最终替换</p>
<h3 id="aes-advanced-encryption-standard">AES:Advanced Encryption Standard</h3>
<ul>
<li>新的对称密钥NIST标准(Nov,2001)用于替换DES</li>
<li>数据128bit成组加密</li>
<li>128，192 or 256 bit keys</li>
<li>穷尽算法如果使用1秒钟破解DES，需要花费149万亿年破解AES</li>
</ul>
<h3 id="块密码">块密码</h3>
<ul>
<li>一个循环：一个输入bit影响8个输出bit</li>
<li>多重循环：每个输入比特影响所有的输出bit</li>
<li>块密码：DES，3DES，AES</li>
</ul>
<p><img src="/images/wl_36_4.png" alt=""></p>
<h3 id="密码块链">密码块链</h3>
<ul>
<li>密码块：如果输入块重复，将会得到相同的密文块</li>
<li><font color=red>密码块链</font>：异或第i轮输入m(i)，与前一轮的密文c(i-1)
<ul>
<li>c(0)明文传输到接收端</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_36_5.png" alt=""></p>
<h2 id="公开秘钥密码学">公开秘钥密码学</h2>
<p><font color=red>对称密钥密码学</font></p>
<ul>
<li>需要发送方和接收方对共享式对称密钥达成一致</li>
<li>Q：但是他们如何第一次达成一致（特别是他们永远不可能见面的情况下）</li>
</ul>
<p><font color=red>公开密钥密码学</font></p>
<ul>
<li>完全不同的方法[Differ - Hellman76,RSA78]</li>
<li>发送方和接收方无需共享密钥</li>
<li>一个实体的公钥公之于众</li>
<li>私钥只有他自己知道</li>
</ul>
<p><img src="/images/wl_36_6.png" alt=""></p>
<p>要求：</p>
<ul>
<li>需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">K^{+}_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span>(-)和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup></mrow><annotation encoding="application/x-tex">K^{-}_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span>(-)，满足<font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">K^{-}_B(K^{+}_B(m)) = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></font></li>
<li>给定一个公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">K^{+}_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span>推出私钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup></mrow><annotation encoding="application/x-tex">K^{-}_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span>计算上不可行</li>
</ul>
<p><font color=red>RSA</font>：Rivest,Shamir,Adelson algorithim</p>
<h2 id="rsa">RSA</h2>
<h3 id="rsa：选择秘钥">RSA：选择秘钥</h3>
<ul>
<li>选择两个很大的质数p,q(e.g. 1024 bit each)</li>
<li>计算 n = pq,z = (p - 1)(z - 1)</li>
<li>选择一个e(要求 e &lt; n)和z没有一个公共因子，互素</li>
<li>选择d使得ed - 1正好能够被z整除(也就是：ed mod z = 1)</li>
<li>公钥 <font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><munder><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><mo stretchy="true">⏟</mo></munder><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></munder></mrow><annotation encoding="application/x-tex">\underbrace{(n,e)}_{K^{+}_B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.660195em;vertical-align:-1.910195em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7499999999999998em;"><span style="top:-1.32731em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8209857142857142em;"><span style="top:-2.160707142857143em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.904321428571429em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3392928571428572em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-2.9999999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span class="svg-align" style="top:-2.102em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.898em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.910195em;"><span></span></span></span></span></span></span></span></span></font>，私钥<font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><munder><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><mo stretchy="true">⏟</mo></munder><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup></munder></mrow><annotation encoding="application/x-tex">\underbrace{(n,d)}_{K^{-}_B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.660195em;vertical-align:-1.910195em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7499999999999998em;"><span style="top:-1.32731em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8209857142857142em;"><span style="top:-2.160707142857143em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.904321428571429em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3392928571428572em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-2.9999999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span class="svg-align" style="top:-2.102em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.898em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.910195em;"><span></span></span></span></span></span></span></span></span></font></li>
</ul>
<h3 id="rsa：加密-解密">RSA：加密，解密</h3>
<ul>
<li>给定按照上述算法得到的(n,e)和(n,d)</li>
<li>加密一个bit模式，m，如此计算<br>
<font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><msup><mi>m</mi><mi>e</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">c = m^e mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">n</span></span></span></span></font> (i.e.,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">m^e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span></span></span></span>除以n的余数)</li>
<li>对接收到的密文c解密，如此计算<br>
<font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><msup><mi>c</mi><mi>d</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">m = c^d mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">n</span></span></span></span></font> (i.e.,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">c^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span>除以n的余数)</li>
</ul>
<p><font color=blue>Magic happens</font> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><munder><munder><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mi>e</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup></mrow><mo stretchy="true">⏟</mo></munder><mi>c</mi></munder><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">m = \underbrace{(m^e mod\ n)^d}_{c} mod\ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.2984999999999998em;vertical-align:-1.3993920000000002em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-1.6006079999999998em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span style="top:-2.9999999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span class="svg-align" style="top:-2.102em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.898em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3993920000000002em;"><span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span></p>
<p>一个简单的数学定理：如果p,q都是素数n = pq，那么</p>
<p><img src="/images/wl_36_7.png" alt=""></p>
<h3 id="rsa：另外一个重要的特性">RSA：另外一个重要的特性</h3>
<p><font color=red><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><munder><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mo stretchy="true">⏟</mo></munder><mtext>先用公钥，然后用私钥</mtext></munder><mo>=</mo><mi>m</mi><mo>=</mo><munder><munder><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mo stretchy="true">⏟</mo></munder><mtext>先用私钥，然后用公钥</mtext></munder></mrow><annotation encoding="application/x-tex">\underbrace{K^{-}_B(K^{+}_B(m))}_{先用公钥，然后用私钥}=m=\underbrace{K^{+}_B(K^{-}_B(m))}_{先用私钥，然后用公钥}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.431324em;vertical-align:-1.6099929999999998em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-1.3900070000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">先</span><span class="mord cjk_fallback mtight">用</span><span class="mord cjk_fallback mtight">公</span><span class="mord cjk_fallback mtight">钥</span><span class="mord cjk_fallback mtight">，</span><span class="mord cjk_fallback mtight">然</span><span class="mord cjk_fallback mtight">后</span><span class="mord cjk_fallback mtight">用</span><span class="mord cjk_fallback mtight">私</span><span class="mord cjk_fallback mtight">钥</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213309999999999em;"><span class="svg-align" style="top:-2.068338em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213309999999999em;"><span style="top:-2.416338em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.28366199999999997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213309999999999em;"><span style="top:-2.416338em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.28366199999999997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.931662em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.6099929999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.431324em;vertical-align:-1.6099929999999998em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-1.3900070000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">先</span><span class="mord cjk_fallback mtight">用</span><span class="mord cjk_fallback mtight">私</span><span class="mord cjk_fallback mtight">钥</span><span class="mord cjk_fallback mtight">，</span><span class="mord cjk_fallback mtight">然</span><span class="mord cjk_fallback mtight">后</span><span class="mord cjk_fallback mtight">用</span><span class="mord cjk_fallback mtight">公</span><span class="mord cjk_fallback mtight">钥</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213309999999999em;"><span class="svg-align" style="top:-2.068338em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213309999999999em;"><span style="top:-2.416338em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.28366199999999997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213309999999999em;"><span style="top:-2.416338em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.28366199999999997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.931662em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.6099929999999998em;"><span></span></span></span></span></span></span></span></span></font></p>
<p><font color=blue><strong>结果一致</strong></font></p>
<h2 id="解密的几种类型">解密的几种类型</h2>
<ul>
<li>加密的算法已知，求秘钥</li>
<li>加密算法和秘钥均不知道</li>
<li>唯密文攻击</li>
<li>已知明文攻击
<ul>
<li>已经知道部分密文和明文的对应关系</li>
</ul>
</li>
<li>选择明文攻击
<ul>
<li>攻击者能够选择一段明文，并得到密文</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——37认证</title>
    <url>/2024/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9437%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1>认证</h1>
<p><font color=red>目标</font>：Bob需要Alice证明他的身份</p>
<p><font color=red>Protocol ap1.0</font>：Alice说&quot;A am Alice&quot;</p>
<p><img src="/images/wl_37_1.png" alt=""></p>
<p>可能出现的问题：</p>
<ul>
<li>在网络上Bob看不到Alice，因此Trudy可以简单的声称他是Alice</li>
</ul>
<p><img src="/images/wl_37_2.png" alt=""></p>
<h2 id="认证：重新尝试">认证：重新尝试</h2>
<p><font color=red>Protocol ap2.0</font>：Alice说&quot;I am Alice&quot;，在她发送的IP数据包中包括了他的IP地址</p>
<p><img src="/images/wl_37_3.png" alt=""></p>
<p>可能出现的问题：</p>
<ul>
<li>Trudy可以生成一个分组，包括伪造的Alice地址</li>
</ul>
<p><img src="/images/wl_37_4.png" alt=""></p>
<p><font color=red>Protocol ap3.0</font>：Alice说&quot;I am Alice&quot;，而且传送他的密码来证明</p>
<p><img src="/images/wl_37_5.png" alt=""></p>
<p>可能出现的问题：</p>
<ul>
<li><strong>重放攻击</strong>
<ul>
<li>Trudy记录Alice的分组，事后向Bob重放</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_37_6.png" alt=""></p>
<p><font color=red>Protocol ap3.1</font>：Alice说&quot;I am Alice&quot;而且传输她的加密之后的密码来证明</p>
<p><img src="/images/wl_37_7.png" alt=""></p>
<p>可能出现的问题：</p>
<ul>
<li>记录，重放仍然有效</li>
</ul>
<p><img src="/images/wl_37_8.png" alt=""></p>
<h3 id="对称式秘钥">对称式秘钥</h3>
<p><font color=red>目标</font>：避免重放攻击</p>
<p><font color=red>Nonce</font>：一生只用一次的整数（R）</p>
<p><font color=red>ap4.0</font>：为了证明Alice的活跃性，Bob发送给Alice一个<font color=red>nonce</font>，R，Alice必须返回加密之后的R，使用双方约定好的key</p>
<p><img src="/images/wl_37_9.png" alt=""></p>
<p>因为Alice是活跃的，只有Alice知道这个加密的Nonce，因此一定是Alice</p>
<h3 id="公开式秘钥">公开式秘钥</h3>
<p><font color=red>ap5.0</font>：使用nonce，公开密钥加密技术</p>
<p><img src="/images/wl_37_10.png" alt=""></p>
<h4 id="安全漏洞">安全漏洞</h4>
<p><font color=red>中间攻击</font>：Trudy在Alice(to Bob)和Bob(to Alice)之间</p>
<p><img src="/images/wl_37_11.png" alt=""></p>
<p>难以检测：</p>
<ul>
<li>Bob接收到了Alice发送的所有报文，反之亦然</li>
<li>问题是Trudy也接收到了所有的报文</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——38报文完整性</title>
    <url>/2024/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9438%E6%8A%A5%E6%96%87%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    <content><![CDATA[<h1>报文完整性</h1>
<h2 id="数字签名">数字签名</h2>
<p><font color=red>数字签名类比于手写签名</font></p>
<ul>
<li>发送方数字签署了文件，前提是他是文件的拥有者/创建者</li>
<li>可验证性，不可伪造性，不可抵赖性
<ul>
<li>谁签署，接收方可以向他人证明是他，而不是其他人签署了这个文件</li>
<li>签署了什么：这份文件，而不是其他文件</li>
</ul>
</li>
</ul>
<p><font color=red>简单的对m的数字签名</font></p>
<ul>
<li>Bob使用他自己的私钥对m进行了签署，创建数字签名<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">K_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(m)</li>
</ul>
<p><img src="/images/wl_38_1.png" alt=""></p>
<ul>
<li>假设Alice收到报文m，以及数字签名<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K^{-}_B(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li>
<li>Alice使用Bob的公钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">K^+_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span>对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo>−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K^-_B(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>进行验证，判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo>+</mo></msubsup><mo stretchy="false">(</mo><msub><mi>K</mi><mi>B</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">K^+_B(K_B(m))=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>是否成立</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo>+</mo></msubsup><mo stretchy="false">(</mo><msub><mi>K</mi><mi>B</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">K^+_B(K_B(m))=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>成立，那么签署这个文件的人一定拥有Bob的私钥</li>
</ul>
<p><font color=red>Alice可以验证</font></p>
<ul>
<li>Bob签署了m</li>
<li>不是其他人签署了m</li>
<li>Bob签署了m而不是m’</li>
</ul>
<p><font color=red>不可抵赖性</font><br>
- Alice可以拿着m以及数字签名<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo>−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K^-_B(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>到法庭上，来证明是Bob签署了这个文件m</p>
<h2 id="报文摘要">报文摘要</h2>
<p>对长报文进行公开密钥加密算法的实验需要耗费大量的时间</p>
<p><font color=red>Goal</font>：固定长度，容易计算的&quot;fingerprint&quot;</p>
<ul>
<li>对m使用散列函数H，获得固定长度的报文摘要H(m)</li>
</ul>
<p><font color=red>散列函数的特性</font></p>
<ul>
<li>多对一</li>
<li>固定长度不变</li>
<li>给定一个报文摘要x，反向计算出报文在计算上是不可行的x=H(m)</li>
</ul>
<h2 id="数字签名-对报文摘要进行数字签署">数字签名 = 对报文摘要进行数字签署</h2>
<p>Bob发送数字签名的报文</p>
<p><img src="/images/wl_38_2.png" alt=""></p>
<p>Alice校检签名和报文完整性</p>
<p><img src="/images/wl_38_3.png" alt=""></p>
<h2 id="散列函数算法">散列函数算法</h2>
<ul>
<li><font color=red>MD5散列函数(RFC 1321)被广泛的应用</font>
<ul>
<li>4个步骤计算出128-bit的报文摘要</li>
<li>给定一个任意的126-bit串x，很难构造出一个报文m具有相同的摘要x</li>
</ul>
</li>
<li><font color=red>SHA-1也被使用</font>
<ul>
<li>US标准[NIST,FIPS PUB 180-1]</li>
<li>160-bit报文摘要</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——39密钥分发和证书</title>
    <url>/2024/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9439%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91%E5%92%8C%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1>密钥分发和证书</h1>
<h2 id="可信赖中介">可信赖中介</h2>
<p><font color=red>对称密钥问题</font></p>
<ul>
<li>相互通信的实体如何分享对称密式的密钥？</li>
</ul>
<p><font color=red>解决办法</font></p>
<ul>
<li>trusted key distribution center(KDC) 在实体之间扮演可信赖中介的角色</li>
</ul>
<p><font color=red>公共密钥问题</font></p>
<ul>
<li>当Alice获得Bob的公钥(from web site,e-mail,diskette)，她如何知道就是Bob的public key，而不是Trudy的？</li>
</ul>
<p><font color=red>解决方法</font></p>
<ul>
<li>可信赖的certification authority(CA)</li>
</ul>
<h2 id="kdc">KDC</h2>
<ul>
<li>Alice,Bob需要分享对称式密钥</li>
<li><font color=red>KDC</font>：服务器和每一个注册用户都分享一个对称式的密钥(many users)</li>
<li>Alice，Bob在和KDC通信的时候，知道他们自己的对称式秘钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mo>−</mo><mi>K</mi><mi>D</mi><mi>C</mi></mrow></msub><mtext> </mtext><msub><mi>K</mi><mrow><mi>B</mi><mo>−</mo><mi>K</mi><mi>D</mi><mi>C</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{A-KDC}\ K_{B-KDC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>Q：KDC如何使得Bob和Alice在和对方通信前，就对称式会话密钥达成一致？</p>
<p><img src="/images/wl_39_1.png" alt=""></p>
<p>Alice和Bob通信：使用R1作为对称式的<font color=red>会话</font>密钥</p>
<h2 id="ca">CA</h2>
<ul>
<li><font color=red>CA</font>：将每一个注册实体E和他的公钥捆绑</li>
<li>E（person,router）到CA那里注册他的公钥
<ul>
<li>E提供给CA，自己的身份证据&quot;proof of identity&quot;</li>
<li>CA创建一个证书，捆绑了实体信息和他的公钥</li>
<li>Certificate包括了E的公钥，而且是被CA签署的（被CA用自己的私钥加了密的）</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_39_2.png" alt=""></p>
<ul>
<li>当Alice需要拿到Bob公钥
<ul>
<li><font color=red>获得Bob的证书certificate(从Bob或者其他地方)</li>
<li>对Bob的证书，使用CA的公钥来验证</font></li>
</ul>
</li>
</ul>
<p><img src="/images/wl_39_3.png" alt=""></p>
<h3 id="证书">证书</h3>
<p>证书包括</p>
<ul>
<li>串号(证书发行者唯一)</li>
<li>证书拥有者信息，包括算法和密钥值本身(不显示出来)</li>
<li>证书发行者信息</li>
<li>有效日期</li>
<li>颁发者签名</li>
</ul>
<h3 id="信任树">信任树</h3>
<ul>
<li>根证书：根证书是未被签名的公钥证书或自签名的证书
<ul>
<li>拿到一些CA的公钥</li>
<li>渠道：安装OS自带的数字证书：从网上下载你信任的数字证书</li>
</ul>
</li>
<li>信任树
<ul>
<li>信任根证书CA颁发的证书，拿到了根CA的公钥
<ul>
<li>信任了根</li>
</ul>
</li>
<li>由根CA签署的给一些机构的数字证书，包含了这些机构的数字证书</li>
<li>由于你信任了根，从而能够可靠的拿到根CA签发的证书，可靠的拿到这些机构的公钥</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——40各个层次的安全性</title>
    <url>/2024/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9440%E5%90%84%E4%B8%AA%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h1>各个层次的安全性</h1>
<h2 id="安全电子邮件">安全电子邮件</h2>
<p>Alice需要发送机密的报文m给Bob</p>
<p><img src="/images/wl_40_1.png" alt=""></p>
<p><font color=red>Alice</font></p>
<ul>
<li>产生随机的对称秘钥，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对报文进行加密（为了效率）</li>
<li>对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>使用Bob的公钥进行加密</li>
<li>发送<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_s(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>B</mi></msub><mo stretchy="false">(</mo><msub><mi>K</mi><mi>S</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B(K_S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>给Bob</li>
</ul>
<p><font color=red>Bob</font></p>
<ul>
<li>使用自己的私钥解密<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>解密<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_S(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>得到报文</li>
</ul>
<p>Alice数字签署文件<br>
发送报文（明文）和数字签名</p>
<p>Alice 需要提供源端的报文完整性和可认证性</p>
<p><img src="/images/wl_40_2.png" alt=""></p>
<p>Alice加密：</p>
<ul>
<li>Alice 数字签署文件(采用自己的私钥签署报文的散列)</li>
<li>发送报文（明文）和数字签名<br>
Bob解密：</li>
<li>Bob使用散列函数计算报文的散列 H(m)</li>
<li>使用Alice的公钥解密报文的散列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>A</mi><mo>+</mo></msubsup><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>A</mi><mo>−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_A^+(K_A^-(m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>比较 H(m) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>A</mi></msub><mo>+</mo><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>A</mi><mo>−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_A+(K_A^-(m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>？</li>
<li>如果相等，说明m就是正确的</li>
<li>能采用Alice的公钥解密，说明是用Alice的私钥加密的，保证了源端可认证性</li>
<li>采用散列比较，保证了报文完整性（如果报文被修改，得到的散列也会被修改）</li>
</ul>
<p>Alice 需要提供机密性，源端可认证性和报文的完整性</p>
<p><img src="/images/wl_40_3.png" alt=""></p>
<p>Alice使用了3个keys：自己的私钥，Bob的公钥，新产生出的对称式密钥</p>
<h3 id="pretty-good-privacy-pgp">Pretty good privacy(PGP)</h3>
<ul>
<li>Internet e-mail加密方案，事实上的标准.</li>
<li>使用前面讲述的：对称密钥加密，公开密钥加密，散列函数和数字签名.</li>
<li>能够提供机密性，源端的可认证性和报文完整性.</li>
<li>发明者, Phil Zimmerman, 是３年的犯罪调查的目标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*A PGP signed message: */</span><br><span class="line">---BEGIN PGP SIGNED MESSAGE---</span><br><span class="line">Hash: SHA1</span><br><span class="line">Bob:My husband is out of town tonight.Passionately yours, Alice</span><br><span class="line">---BEGIN PGP SIGNATURE---</span><br><span class="line">Version: PGP 5.0</span><br><span class="line">Charset: noconv</span><br><span class="line">yhHJRHhGJGhgg/12EpJ+lo8gE4vB3</span><br><span class="line">mqJhFEvZP9t6n7G6m5Gw2</span><br><span class="line">---END PGP SIGNATURE---</span><br></pre></td></tr></table></figure>
<h2 id="secure-sockets-layer-ssl">Secure sockets layer(SSL)</h2>
<ul>
<li><font color=red>为使用SSL服务的、基于TCP的应用提供传输层次的安全性</font>
<ul>
<li>e.g.在Web的浏览器和服务器之间进行电子商务的交易(shttp)</li>
</ul>
</li>
<li>所提供的安全服务：
<ul>
<li>服务器的可认证性，数据加密，客户端的可认证性（可选）</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_40_4.png" alt=""></p>
<h3 id="ssl三个阶段">SSL三个阶段</h3>
<p><font color=red>握手</font></p>
<ul>
<li>Bob和Alice建立TCP连接</li>
<li>通过AC签署的证书认证Alice的身份</li>
<li>创建、加密（采用Alice的公钥），传输主密钥给Alice
<ul>
<li>不重数交换没有显示</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_40_5.png" alt=""></p>
<p><font color=red>密钥导出</font></p>
<ul>
<li>Alice,Bob采用共享的MS产生4个keys
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">E_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：Bob -&gt; Alice 数据加密key</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">E_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：Alice -&gt; Bob 数据加密key</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">M_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：Bob -&gt; Alice MAC(报文鉴别编码) key</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">M_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：Alice -&gt; Bob MAC key</li>
</ul>
</li>
<li>加密和MAC算法在Bob,Alice之间协商</li>
<li>为什么要4个keys？
<ul>
<li>更安全</li>
</ul>
</li>
</ul>
<p><font color=red>数据传输</font></p>
<p><img src="/images/wl_40_6.png" alt=""></p>
<h2 id="ipsec：网络层次的安全性">IPsec：网络层次的安全性</h2>
<ul>
<li><font color=red>网络层次的机密性</font>
<ul>
<li>发送端主机IP数据报中的数据进行加密</li>
<li>数据：TCP或者UDP的段；ICMP和SNMP报文</li>
</ul>
</li>
<li><font color=red>网络层次的可认可性</font>
<ul>
<li>目标主机可以认证源主机的IP地址</li>
</ul>
</li>
<li><font color=red>2个主要协议</font>
<ul>
<li>认证头部（AH）协议</li>
<li>封装安全载荷 encapsulation security payload(ESP) 协议</li>
</ul>
</li>
<li><font color=red>不管AH还是ESP，源和目标在通信之前要握手</font>
<ul>
<li>创建一个网络层次的逻辑通道：安全关联 security assocication(SA)</li>
</ul>
</li>
<li><font color=red>每一个SA都是单向</font></li>
<li><font color=red>由以下元组唯一确定</font>
<ul>
<li>安全协议（AH 或 ESP）</li>
<li>源IP地址</li>
<li>32bit连接ID</li>
</ul>
</li>
</ul>
<h2 id="authentication-header-ah-协议">Authentication Header(AH)协议</h2>
<ul>
<li>提供源端的可认证性，数据完整性，但是不提供机密性</li>
<li>在IP头部和数据字段之间插入AH的头部</li>
<li>协议字段：51</li>
<li>中间的路由器按照常规处理这个数据报</li>
</ul>
<p><font color=red>AH头部包括</font></p>
<ul>
<li>连接ID</li>
<li>认证数据：对原始数据计算报文摘要，使用源端的私钥进行数字签名</li>
<li>下一个字段定义了数据的类型（e.g. TCP,UDP,ICMP）</li>
</ul>
<p><img src="/images/wl_40_7.png" alt=""></p>
<h2 id="esp协议">ESP协议</h2>
<ul>
<li>提供机密性，主机的可认证性，数据的完整性</li>
<li>数据和ESP尾部部分被加密</li>
<li>next header字段在ESP尾部</li>
<li>ESP认证的头部与AH类似</li>
<li>协议号 = 50</li>
</ul>
<p><img src="/images/wl_40_8.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——41防火墙</title>
    <url>/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9441%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<h1>防火墙</h1>
<p>将组织内部网络和互联网络隔离开来，按照规则允许某些分组通过（进出），或者阻塞掉某些分组</p>
<p><img src="/images/wl_41_1.png" alt=""></p>
<h2 id="为什么需要防火墙">为什么需要防火墙</h2>
<p><font color=red>阻止拒绝服务攻击</font></p>
<ul>
<li>SYN flooding：攻击者建立很多伪造TCP连接，对于真正用户而言已经没有资源留下了</li>
</ul>
<p><font color=red>阻止非法的修改/对非授权内容的访问</font></p>
<ul>
<li>e.g.攻击者替换掉CIA的主页</li>
</ul>
<p><font color=red>只允许认证的用户能否访问内部网络资源</font>（经过认证的用户/主机集合）</p>
<p><font color=red>2种类型的防火墙</font></p>
<ul>
<li>网络级别：分组过滤器
<ul>
<li>有状态，无状态</li>
</ul>
</li>
<li>应用级别：应用程序网关</li>
</ul>
<h3 id="分组过滤">分组过滤</h3>
<p><img src="/images/wl_41_2.png" alt=""></p>
<ul>
<li>内部网络通过配置防火墙的路由器连接到互联网上</li>
<li>路由器对分组逐个过滤，根据以下规则来决定转发还是丢弃
<ul>
<li>源IP地址，目标IP地址</li>
<li>TCP/UDP源和目标端口</li>
<li>ICMP报文类别</li>
<li>TCP SYN 和 ATK bits</li>
</ul>
</li>
</ul>
<h4 id="分组过滤-无状态">分组过滤 - 无状态</h4>
<p><font color=red>例1：阻塞进出的数据报：只要拥有IP协议字段 = 17，而且 源/目标端口号 = 23</font></p>
<ul>
<li>所有的进出UDP流以及telnet连接的数据报都被阻塞掉</li>
</ul>
<p><font color=red>例2：阻塞进入内网的TCP段：他的ACK = 0</font></p>
<ul>
<li>阻止外部客户端和内部网络的主机建立TCP连接</li>
<li>但允许内部网络的客户端和外部服务器建立TCP连接</li>
</ul>
<h5 id="无状态分组过滤器：例子">无状态分组过滤器：例子</h5>
<table>
<thead>
<tr>
<th>策略</th>
<th><font color=red>防火墙设置</font></th>
</tr>
</thead>
<tbody>
<tr>
<td>不允许外部的web进行访问</td>
<td><font color=red>阻塞掉所有外出具有目标端口8O的IP分组</font></td>
</tr>
<tr>
<td>不允许来自外面的TCP连接，除非是机构公共Web服务器的连接</td>
<td><font color=red>阻塞掉所有进来的ICP SYN分组，除非130.207.244.203,port = 80</td>
</tr>
<tr>
<td>阻止Web无限电占用可用带宽</td>
<td><font color=red>阻塞所有进来的UDP分组，除非DNS和路由器广播</font></td>
</tr>
<tr>
<td>阻止你的网络被smurf Dos所占用</td>
<td><font color=red>阻塞掉所有具有广播地址的ICMP分组(e.g. 130.207.255.255)</td>
</tr>
<tr>
<td>阻止内部网络被tracerout，从而得到你的网络拓扑</td>
<td><font color=red>阻塞掉所有外出的ICMP TTL过期的流量</td>
</tr>
</tbody>
</table>
<h5 id="例子：access-control-lists">例子：Access Control Lists</h5>
<p>ACL：规则的表格，top - bottom应用到输入的分组：(action,condition)对</p>
<table>
<thead>
<tr>
<th>action</th>
<th>source address</th>
<th>dest address</th>
<th>protocol</th>
<th>source port</th>
<th>dest port</th>
<th>flag bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>allow</td>
<td>222.22/16</td>
<td>outside of 222.22/16</td>
<td>TCP</td>
<td>&gt;1023</td>
<td>80</td>
<td>any</td>
</tr>
<tr>
<td>allow</td>
<td>outside of 222.22/16</td>
<td>222.22/16</td>
<td>TCP</td>
<td>80</td>
<td>&gt;1023</td>
<td>ACK</td>
</tr>
<tr>
<td>allow</td>
<td>222.22/16</td>
<td>outside of 222.22/16</td>
<td>UDP</td>
<td>&gt;1023</td>
<td>53</td>
<td>—</td>
</tr>
<tr>
<td>allow</td>
<td>outside of 222.22/16</td>
<td>222.22/16</td>
<td>UDP</td>
<td>53</td>
<td>&gt;1023</td>
<td>—</td>
</tr>
<tr>
<td>deny</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td>all</td>
</tr>
</tbody>
</table>
<h4 id="有状态分组过滤">有状态分组过滤</h4>
<ul>
<li>无状态分组过滤根据每个分组独立地检查和行动</li>
<li>有状态的分组过滤联合分组状态表检查和行动</li>
<li>ACL增强：在允许分组之前需要检查连接状态表</li>
</ul>
<table>
<thead>
<tr>
<th>action</th>
<th>source address</th>
<th>dest address</th>
<th>protocol</th>
<th>source port</th>
<th>dest port</th>
<th>flag bit</th>
<th>check connection</th>
</tr>
</thead>
<tbody>
<tr>
<td>allow</td>
<td>222.22/16</td>
<td>outside of 222.22/16</td>
<td>TCP</td>
<td>&gt;1023</td>
<td>80</td>
<td>any</td>
<td></td>
</tr>
<tr>
<td>allow</td>
<td>outside of 222.22/16</td>
<td>222.22/16</td>
<td>TCP</td>
<td>80</td>
<td>&gt;1023</td>
<td>ACK</td>
<td>×</td>
</tr>
<tr>
<td>allow</td>
<td>222.22/16</td>
<td>outside of 222.22/16</td>
<td>UDP</td>
<td>&gt;1023</td>
<td>53</td>
<td>—</td>
<td></td>
</tr>
<tr>
<td>allow</td>
<td>outside of 222.22/16</td>
<td>222.22/16</td>
<td>UDP</td>
<td>53</td>
<td>&gt;1023</td>
<td>—</td>
<td>×</td>
</tr>
<tr>
<td>deny</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="应用程序网关">应用程序网关</h3>
<ul>
<li>根据应用数据的内容来过滤进行的数据报，就像数据IP/TCP/UDP字段来过滤一样
<ul>
<li>检查的增强：应用层过滤</li>
</ul>
</li>
<li><font color=red>Example</font>：允许内部用户登录到外部服务器，但不是直接登陆
<ul>
<li>需要所有的telnet用户通过网关来telnet</li>
<li>对于认证的用户而言，网关建立和目标主机的telnet connection，网关在2个连接上进行中继</li>
<li>路由器过滤器对所有不是来自网关的telnet的分组全部过滤掉</li>
</ul>
</li>
</ul>
<p><img src="/images/wl_41_3.png" alt=""></p>
<h2 id="局限性">局限性</h2>
<ul>
<li><font color=red>IP spoofing</font>：路由器不知道数据报是否真的来自于声称的原地址</li>
<li>如果有多个应用需要控制，就需要多个应用程序网关</li>
<li>客户端软件需要知道如何连接到这个应用程序
<ul>
<li>e.g. 必须在Web browser中配置网络代理的Ip地址</li>
</ul>
</li>
<li>过滤器对UDP所在的报文，或者全过或者全都不过</li>
<li><font color=red>折中：与外部通信的自由度，安全的级别</font></li>
<li>很多高度保护的站点仍然受到攻击的困扰</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——42攻击和对策</title>
    <url>/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%9442%E6%94%BB%E5%87%BB%E5%92%8C%E5%AF%B9%E7%AD%96/</url>
    <content><![CDATA[<h1>攻击和对策</h1>
<h2 id="ids：入侵检测系统">IDS：入侵检测系统</h2>
<ul>
<li>分组过滤
<ul>
<li>对TCP/IP头部进行检查</li>
<li>不检查会话间的相关性</li>
</ul>
</li>
<li><font color=red>IDS:intrusion detection system</font>
<ul>
<li>深入分组检查：检查分组的内容（e.g. 检查分组中的特征串，已知攻击数据库的病毒和攻击串）</li>
<li>检查分组间的相关性，判断是否是有害的分组
<ul>
<li>端口扫描</li>
<li>网络映射</li>
<li>Dos攻击</li>
</ul>
</li>
</ul>
</li>
<li>multiple IDSs：在不同的地点进行不同类型的检查</li>
</ul>
<p><img src="/images/wl_42_1.png" alt=""></p>
<h2 id="internet-安全威胁">Internet 安全威胁</h2>
<p><font color=red>映射</font></p>
<ul>
<li>在攻击之前：“踩点” - 发现在网络上实现了哪些服务</li>
<li>使用ping来判断哪些主机在网络上有地址</li>
<li>端口扫描：试图顺序地在每一个端口上建立TCP连接（看看发生了什么）</li>
<li>nmap(<a href="http://www.insecure.org/nmap/">http://www.insecure.org/nmap/</a>)mapper:“network exploration and security auditing”</li>
</ul>
<p><font color=red>对策</font></p>
<ul>
<li>记录进入到网络中的流量通信</li>
<li>发现可疑的行为(IP address，端口被依次扫描)</li>
</ul>
<p><font color=red>分组嗅探</font></p>
<ul>
<li>广播式介质</li>
<li>混杂模式的NIC获取所有的信道上的分组</li>
<li>可获取所有未加密的数据(e.g. password)</li>
<li>e.g. C嗅探B的分组</li>
</ul>
<p><img src="/images/wl_42_2.png" alt=""></p>
<p><font color=red>对策</font></p>
<ul>
<li>机构中的所有主机都运行能够监测软件，周期性的检查是否有网卡运行于混杂模式</li>
<li>每一个主机一个独立的网段(交换式以太网而不是使用集线器)</li>
</ul>
<p><font color=red>IP Spoofing欺骗</font></p>
<ul>
<li>可以由应用进程直接产生&quot;raw&quot;IP分组，而且可以在IP源地址部分直接放置任何地址</li>
<li>接收端无法判断源地址是不是具有欺骗性的</li>
<li>e.g. C伪装成B</li>
</ul>
<p><img src="/images/wl_42_3.png" alt=""></p>
<p><font color=red>对策：IP Spoofing 入口过滤</font></p>
<ul>
<li>路由器对那些具有非法源地址的分组不进行转发(e.g. 数据报的源地址不是路由器所在的网络地址)</li>
<li>很好，但是入口过滤不能够在全网范围内安装</li>
</ul>
<p><font color=red>Denial of server(DOS)对策</font></p>
<ul>
<li>在到达主机之前过滤掉这些泛洪的分组(e.g. SYN)：throw out good with bad</li>
<li>回溯到源主机(most likely an innocent, compromised machine)</li>
</ul>
<p><img src="/images/wl_42_4.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityShader——基础篇之渲染流水线</title>
    <url>/2024/04/12/UnityShader%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h1>渲染流水线</h1>
<h2 id="综述">综述</h2>
<h3 id="什么是渲染流水线">什么是渲染流水线</h3>
<p>  渲染流水线的工作任务在于由一个三维场景出发、生成（或者说渲染）一张二维图像，换句话说，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像，而这个工作原理通常是由CPU和GPU共同完成的</p>
<p>  《Real-Time Rendering, Third Edition》中讲一个渲染流程分成3个阶段：<font color=red>应用阶段、集合阶段、光栅化阶段</font></p>
<p><img src="/images/Shader/Shader_01/Shader_01_1.png" alt=""></p>
<ul>
<li>应用阶段
<ul>
<li>这个阶段是由应用主导的，因此通常由CPU负责实现，开发者具有这个阶段的绝对控制权</li>
<li>在这个阶段，开发者有三个主要任务：
<ul>
<li>首先，准备好场景数据，例如摄像机的位置、视椎体，场景中包含了哪些模型、使用了哪些光源等等</li>
<li>其次，为了提高渲染性能，往往需要做一个粗粒度剔除(culling)工作，以把那些不可见的物体剔除出去，这样就不需要再移交给几何阶段进行处理</li>
<li>最后，设置好每个模型的渲染状态，这些渲染状态包括但不限于它使用的材质（漫反射颜色、高光反射颜色）、使用的纹理、使用的Shader等</li>
</ul>
</li>
<li>这个阶段最重要的输出是渲染所需的几何信息，即<strong>渲染图元</strong>，通俗来讲，渲染图元可以是点、线、三角面等，这些渲染图元会被传递给下一个阶段——集合阶段</li>
<li>由于由开发者主导这个阶段，因此应用阶段的流水线化是由开发者决定的，可以参考以下阅读物：
<ul>
<li>Akenine-Möller T,Haines E,Hoffman N.Real-time rendering[M].CRC Press,2008</li>
<li>Wloka M.Batch,Batch,Batch:What does it really mean?[C]//Presentation at game developers conference 2003</li>
</ul>
</li>
</ul>
</li>
<li>几何阶段
<ul>
<li>用于处理所有要回值得几何相关的事情，例如，决定需要绘制的图元是什么，怎样绘制它们，这一阶段通常由GPU负责</li>
<li>几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作，这个阶段可以进一步分成更小的流水线阶段</li>
<li>几何阶段的一个重要任务是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行多步处理后，这一阶段将会输出屏幕空间的二位顶点坐标，每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段</li>
</ul>
</li>
<li>光栅化阶段
<ul>
<li>这一阶段将会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像</li>
<li>和上一个阶段类似，光栅化阶段也可以分成更小的流水线阶段</li>
</ul>
</li>
</ul>
<h2 id="cpu和gpu之间的通信">CPU和GPU之间的通信</h2>
<p>渲染流水线的起点是CPU，即应用阶段。应用阶段大致可分为下面3个阶段</p>
<ol>
<li>把数据加载到显存中</li>
<li>设置渲染状态</li>
<li>调用Draw Call</li>
</ol>
<h3 id="把数据加载到显存中">把数据加载到显存中</h3>
<p>  所有渲染所需的数据都需要从硬盘 (Hard Disk Drive,HDD) 中加载到系统内存 (Random Access Memory, RAM) 中，然后，网格和纹理等数据又被加载到显卡上的存储空间——显存 (Video Random Access Memory, VRAM) 中。这是因为，显卡对于先存档访问速度更快，而且大多数显卡对于RAM没有直接的访问权限</p>
<p><img src="/images/Shader/Shader_01/Shader_01_2.png" alt=""></p>
<p>  需要注意的是，真是渲染中需要加载到显存中的数据往往比上图所示复杂很多，例如：顶点的位置信息、法线方向、顶点颜色、纹理坐标等</p>
<p>  当把数据加载到显存中后，RAM中的数据就可以移除了，但对于一些数据来说，CPU仍然需要访问他们（例如，我们希望CPU可以访问网络数据来进行碰撞检测），那么可能就不希望这些数据被移除，因为从硬盘加载到RAM的过程是十分耗时的</p>
<p>  在这之后，开发者还需要通过CPU来设置渲染状态，从而“指导”GPU如何进行渲染工作</p>
<h3 id="设置渲染状态">设置渲染状态</h3>
<p>  通俗解释为：这些状态定义了场景中的网络是怎样被渲染的。例如：使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等<br>
  如果没有改变渲染状态，那么所有的网格都将使用同一种渲染状态</p>
<p><img src="/images/Shader/Shader_01/Shader_01_3.png" alt=""></p>
<p>  在准备好上述所有工作后，CPU就需要调用一个渲染命令来告诉GPU数据已经准备好，按照设置进行渲染，这个渲染命令就是Draw Call</p>
<h3 id="调用draw-call">调用Draw Call</h3>
<p>  Draw Call就是一个命令，他的发起方是CPU，接收方是GPU，这个命令仅仅会指向一个需要被渲染的图元（primitives）列表，而不会再包含任何材质信息——这是因为我们在上一个阶段中完成了</p>
<p><img src="/images/Shader/Shader_01/Shader_01_4.png" alt=""></p>
<p>  当给定了一个Draw Call时，GPU就会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些票联的像素，而这个计算过程，就是GPU流水线</p>
<h2 id="gpu流水线">GPU流水线</h2>
<h3 id="概述">概述</h3>
<p>  几何阶段和光栅化阶段可以分成若干更小的流水线阶段，这些流水线阶段由GPU来实现，每个阶段GPU提供了不同的可配置型或可编程性，如图：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_5.png" alt=""></p>
<p>  从图中可以看出，GPU的渲染流水线接受顶点数据作为输入，这些顶点数据是由应用阶段加载到显存中，再由Darw Call指定的，这些数据随后被传递给顶点着色器</p>
<p>  <strong>顶点着色器</strong>（<strong>Vertex Shader</strong>）是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能</p>
<p>  <strong>曲面细分着色器</strong>（<strong>Tessellation Shader</strong>）使一个可选的着色器，它用于细分图元</p>
<p>  <strong>几何着色器</strong>（<strong>Geometry Shader</strong>）同样是一个可选的着色器，它可以被用于执行逐图元（Per-Primitive）的着色操作，或者被用于产生更多的图元</p>
<p>  <strong>裁剪</strong>（<strong>Clipping</strong>），这一阶段的目的是讲那些不在摄像机视野的顶点裁剪掉，并剔除某些三角图源的面片，这个阶段是可配置的，例如，使用自定义的裁剪平面来配置裁剪区域。也可以通过指令控制裁剪三角图元的正面还是背面</p>
<p>  <strong>屏幕映射</strong>（<strong>Screen Mapping</strong>），这一阶段是不可配置和编程的，它负责把每个图元的坐标转换到屏幕坐标系中</p>
<p>  <strong>三角形设置</strong>（<strong>Triangle Setup</strong>）和<strong>三角形遍历</strong>（<strong>Triangle Traversal</strong>）阶段也都是固定函数（Fixed-Function）的阶段</p>
<p>  <strong>片元着色器</strong>（<strong>Fragment Shader</strong>）则是完全可编程的，它用于逐片源（Per-Fragment）的着色操作</p>
<p>  <strong>逐片源操作</strong>（<strong>Per-Fragment Operation</strong>）阶段负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等，他不是可编程的，但具有很高的可配置性</p>
<h3 id="顶点着色器">顶点着色器</h3>
<p>  <strong>顶点着色器</strong>（Vertex Shader）是流水线的第一个阶段，他的输入来自于CPU顶点着色器的处理单位是顶点，也就是说，输入进来的每个节点都会调用一次顶点着色器</p>
<p>  顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点和顶点之间的关系</p>
<p>  顶点着色器需要完成的工作主要有：坐标变换和逐顶点光照，除了这两个主要任务外，顶点着色器还可以输出后续阶段所需的数据，如下图，展示了在顶点着色器中对定点位置进行坐标变换并计算顶点颜色的过程</p>
<p><img src="/images/Shader/Shader_01/Shader_01_6.png" alt=""></p>
<p>  <strong>坐标变换</strong>，就是对顶点的坐标（即位置）进行某种变换。顶点着色器可以在这一步中改变顶点的位置，这在顶点动画中是非常有用的，比如可以通过改变顶点位置模拟水面，布料等</p>
<p>  <strong>注意</strong>：无论在顶点着色器中怎样改变顶点的位置，一个最基本的顶点着色器必须完成的一个工作——<strong>把顶点坐标从模型空间转换到齐次裁剪空间</strong></p>
<p>  像顶点着色器中的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o.pos = mul(UNITY_MVP,v.position);</span><br></pre></td></tr></table></figure>
<p>  这句代码的功能，就是把顶点坐标转换到齐次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（Normalized Device Coordinates，NDC），如下图示例，展示了这样的转换过程</p>
<p><img src="/images/Shader/Shader_01/Shader_01_7.png" alt=""></p>
<p>  <strong>注意</strong>：</p>
<ul>
<li>图中给出的坐标范围是OpenGL同时也是Unity使用的NDC，他的z分量范围在[-1,1]之间</li>
<li>在DirectX中，NDC的z分量范围是[0,1]。</li>
<li>顶点着色器可以有不同的输出方式。最常见的输出路径是光栅化之后交给片元着色器进行处理</li>
<li>在现代的Shader Model中，它还可以把数据发送给曲面细分着色器或几何着色器</li>
</ul>
<h3 id="裁剪">裁剪</h3>
<p>  因为摄像机的视野范围很有可能不会覆盖所有的场景物体，所以，那些不在摄像机视野范围的物体不需要被处理，所以<strong>裁剪</strong>被提出来了</p>
<p>  一个图元和摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外、</p>
<ul>
<li>完全在视野内的图元就继续传递给下一个流水线阶段</li>
<li>完全在视野外的图元不会继续向下传递，因为它们不会被渲染</li>
<li>部分在视野内的图元需要进行一个处理，这就是裁剪</li>
</ul>
<p>  由于已知在NDC下的定点位置，即定点位置在一个立方体内，因此裁剪就变得很简单：只需要将图元裁剪到单位立方体内，如图</p>
<p><img src="/images/Shader/Shader_01/Shader_01_8.png" alt=""></p>
<p>  和顶点着色器不同，这一步是不可编程的，即无法通过编程来控制裁剪的过程，而是硬件的固定操作，但可以自定义一个裁剪操作来对这一步进行配置</p>
<h3 id="屏幕映射">屏幕映射</h3>
<p>  这一步输入的坐标是三维坐标系下的坐标（范围在单位立方体内）</p>
<p>  <strong>屏幕映射</strong>（<strong>Screen Mapping</strong>）的任务是把每个图元的x和y坐标转换到<strong>屏幕坐标系</strong>（<strong>Screen Coordinates</strong>）下，屏幕坐标系使一个二维坐标系，它用于显示画面的分辨率有很大关系</p>
<p>  原理：</p>
<p>    假设，需要把场景渲染到一个窗口上，窗口的范围是从最小的窗口坐标(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1,y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)到最大的窗口坐标(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2,y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1&lt;x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_1&lt;y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。由于输入的坐标范围在 -1 到 1，因此，这个过程是一个缩放的过程，如图所示：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_9.png" alt=""></p>
<p>  输入的z坐标会怎么样？</p>
<p>    屏幕映射不会对输入的z坐标做任何处理。实际上，屏幕坐标系和z坐标一起构成了一个坐标系叫做<strong>窗口坐标系</strong>（<strong>Window Coordinates</strong>），这些值会一起被传递到光栅化阶段</p>
<p>  屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远</p>
<p>  注意：</p>
<p>    屏幕坐标系在OpenGL和DirectX之间的差异问题。OpenGL把屏幕的左下角当成最小的窗口坐标值，而DirectX则定义了屏幕的左上角为最小的窗口坐标值，如图：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_10.png" alt=""></p>
<p>    造成这种差异的原因：微软的窗口都使用了这样的坐标系统，因为这和我们的阅读方式是一致的：从左到右、从上到下，而且很多图像文件也是按照这样的格式进行存储的</p>
<h3 id="三角形设置">三角形设置</h3>
<p>  从这一步开始进入光栅化阶段，光栅化的阶段有两个最重要的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色</p>
<p>  光栅化阶段的第一个流水线阶段是<strong>三角形设置</strong>（<strong>Trangle Setup</strong>）。这个阶段会计算光栅化第一个三角网格所需的信息。具体来说，上一个阶段输出的都是三角网格的顶点，即得到的是三角网格每条边的两个端点。但如果要得到整个三角网格对像素的覆盖情况，就必须计算每条边上的像素坐标</p>
<p>  为了能够计算边界像素的坐标信息，就需要得到三角形便捷的表示方式，一个计算三角网格表示数据的过程就叫做三角形设置</p>
<p>  它的输出是为了给下一个阶段做准备</p>
<h3 id="三角形遍历">三角形遍历</h3>
<p>  <strong>三角形遍历</strong>（<strong>Triangle Traversal</strong>）阶段将会检查每个像素是否被一个三角网格所覆盖，如果覆盖的话，就会生成一个<strong>片元</strong>（<strong>fragment</strong>）</p>
<p>  这样找到哪些像素被三角网格覆盖的过程就是三角形遍历</p>
<p>  这个阶段也被称为<strong>扫描变换</strong>（<strong>Scan Conversion</strong>）</p>
<p>  三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角网络覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行差值，如图所示：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_11.png" alt=""></p>
<p>  这一步的输出就是得到一个片元序列</p>
<p>  注意：</p>
<ul>
<li>一个片元并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色</li>
<li>这些状态包括了（但不限于）它的屏幕坐标、深度信息，以及其他从几何阶段输出的顶点信息，例如法线、纹理坐标等</li>
</ul>
<h3 id="片元着色器">片元着色器</h3>
<p>  <strong>片元着色器</strong>（<strong>Fragment Shader</strong>）是另一个非常重要的可编程着色器阶段。在DirectX中，片元着色器被称为<strong>像素着色器</strong>（<strong>Pixel Shader</strong>），但片元着色器使一个更合适的名字，因为此时的片元并不是一个真正意义上的像素</p>
<p>  光栅化阶段市集上并不会影响屏幕上每个像素的颜色值，而是会产生一系列的数据信息，用来表达一个三角网络是怎样覆盖每个像素的。而每个片元就负责存储这样一系列数据。真正会对像素产生影响的阶段是<strong>逐片元操作</strong>（<strong>Per-Fragment Operations</strong>）</p>
<p>  片元着色器的输入是上一个阶段对顶点信息差值得到的结果，更具体来说，是根据那些从顶点着色器中输出的数据差值得到的。而他的输出是一个或者多个颜色值，如图所示：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_12.png" alt=""></p>
<p>  这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样</p>
<p>  为了在片元着色器中进行纹理采样，通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行差值之后，就可以得到其覆盖的片元的纹理坐标</p>
<p>  局限：</p>
<ul>
<li>它仅可以影响单个片元。也就是说，当执行片元着色器时，他不可以将自己的任何结果直接发送给它的邻居们</li>
<li>有一个情况例外，片元着色器可以访问到导数信息（gradient，或者说是derivative）</li>
</ul>
<h3 id="逐片元操作">逐片元操作</h3>
<p>  <strong>逐片元操作</strong>（<strong>Per-Fragment Operations</strong>）是OpenGL中的说法，在DirectX中，这一阶段被称为<strong>输出合并阶段</strong>（<strong>Output-Merger</strong>）</p>
<p>  目的：合并</p>
<p>  这一阶段有几个主要任务：</p>
<ul>
<li>决定每个片元的可见性。这涉及了很多测试工作，例如深度测试、模板测试等</li>
<li>如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说是混合</li>
</ul>
<p>  说明：</p>
<ul>
<li>逐片元操作阶段是高度可配置性的，即可以设置每一步的操作细节</li>
</ul>
<p>  这个阶段首先需要每个片元的可见性问题。这需要进行一系列测试。如图所示：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_13.png" alt=""></p>
<p>  测试的过程实际是个比较复杂的过程，而且不同的图形接口（例如OpenGL和DirectX）的实现细节也不尽相同</p>
<p>  两个最基本的测试——深度测试和模板测试的实现过程，如图所示：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_14.png" alt=""></p>
<p>  <strong>模板测试</strong>（<strong>Stencil Test</strong>），与之相关的是模板缓冲。实际上，模板缓冲和颜色缓冲、深度缓冲几乎是一类东西。如果开启了模板测试，GPU会首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取（使用读取掩码）到的参考值（reference value）进行比较，这个比较函数可以由开发者指定的</p>
<p>  例如小于时舍弃该片元，或者大于等于时舍弃该片元。如果这个片元没有通过测试，该片元就会被舍弃。</p>
<p>  不管一个片元有没有通过模板测试，都可以根据模板测试和下面的深度测试结果来修改模板缓冲区，这个修改操作也是由开发者指定的。开发者可以设置不同结果下的修改操作</p>
<p>  例如，在失败时模板缓冲区保持不变，通过时将模板缓冲区中对应位置的值加1等。</p>
<p>  模板测试通常用于限制渲染的区域。</p>
<p>  模板测试更高级的用法，如渲染阴影、轮廓渲染等</p>
<br/>
<p>  <strong>深度测试</strong>（<strong>Depth Test</strong>），如果一个片元通过了模板测试，那么就会进行深度测试。这个测试是可以高度配置的</p>
<p>  如果开启了深度测试，GPU会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。这个比较函数也是可由开发者设置的，例如小于时舍弃该片元，或者大于等于时舍弃该片元。通常这个比较函数是小于等于的关系，即如果这个片元的深度值大于等于当前深度缓冲区的值，那么就会舍弃它</p>
<p>  因为只显示出离摄像机最近的物体，而那些被其他物体遮挡的就不需要出现在屏幕上，如果这个片元没有通过这个测试，它就会被舍弃。</p>
<p>  和模板测试不同的是，如果一个片元没有通过深度测试，他就没有权利更改深度缓冲区的值，如果它通过了测试，开发者还可以指定是否要用这个片元的深度值覆盖掉元用的深度值，这是通过开启/关闭深度写入来做到的</p>
<p>  透明效果和深度测试以及深度写入的关系非常密切</p>
<br/>
<p>  <strong>合并</strong>功能，如果片元通过了上面所有测试，它就可以来到合并功能</p>
<p>  为什么需要合并？</p>
<ul>
<li>这里所讨论的渲染过程使一个物体接着一个物体划到屏幕上的。而每个像素的颜色信息被存储在一个名为颜色缓冲的地方</li>
<li>因此，当执行这次渲染时，颜色缓冲中往往已经有了上次渲染之后的颜色结果</li>
<li>是使用这次渲染的道德颜色完全覆盖掉之前的结果还是进行其他处理，这就是合并要处理的问题</li>
</ul>
<br/>
<p>  <strong>混合</strong>操作，对于不同命物体，开发可以关闭混合操作，这样片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。</p>
<p>  对于半透明物体，就需要混合操作来让这个物体看起来是透明的，流程如图所示：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_15.png" alt=""></p>
<p>  混合操作也可以高度配置：开发者可以选择开启/关闭混合功能</p>
<p>  如果没有开启混合功能，就会直接使用片元的颜色覆盖掉颜色缓冲区的颜色，而这也是无法得到透明效果的原因</p>
<p>  如果开启了混合，GPU会去除源颜色和目标颜色，将两种颜色进行混合。源颜色指的是片元着色器得到的颜色值，而目标颜色则是已经存在于颜色缓冲区中的颜色值，之后就会使用一个混合函数来进行混合操作，这个混合操作函数通常和透明通道息息相关，例如根据透明通道的值进行相加、相见、相乘等</p>
<br/>
<p>  以上的测试顺序并不是唯一的，虽然从逻辑上来说这些测试是在片元着色器之后进行的，但对于大多数GPU来说，它们会尽可能在执行片元着色器之前就进行这些测试</p>
<p>  当GPU在片元着色器终于计算出片元的颜色之后，结果发现这个片元根本没有通过检验，也就是说这个片元被舍弃了，就浪费了计算成本，如图所示</p>
<p><img src="/images/Shader/Shader_01/Shader_01_16.png" alt=""></p>
<p>  在Unity给出的渲染流水线中，他给出的深度测试是在片元着色器之前，这种将深度测试提前执行的技术通常也被称为Eraly - Z技术</p>
<p>  如果将这些测试提前，其姜堰结果可能会与片元着色器中的一些操作冲突</p>
<p>  比如：如果在片元着色器进行了透明度测试，而这个片元没有通过透明度测试，会在着色器中调用API来手动将其舍弃掉，这样就会导致GPU无法提前执行各种测试</p>
<p>  因此，现代的GPU会判断片元着色器中的操作是否和提前测试发生冲突，如果有冲突，就会禁用提前测试，这样的话，性能就会下降，因为有更多的片元需要处理了</p>
<br/>
<p>  当模型的图元经过了上面所有的计算和测试后，就会显示到屏幕上，屏幕显示的就是颜色缓冲区的颜色值</p>
<p>  但是，为了避免看到那些正在进行光栅化的图元，GPU会使用<strong>双重缓冲</strong>（<strong>Double Buffering</strong>）的策略，这意味着，对场景的渲染是在幕后发生的，即在<strong>后置缓冲</strong>（<strong>Back Buffer</strong>）中，一旦场景已经被渲染到了后置缓冲中，GPU就会交换后置缓冲区和<strong>前置缓冲</strong>（<strong>Front Buffer</strong>）中的内容，而前置缓冲区是之前显示在屏幕上的图像。</p>
<p>  因此保证了看到的图像是连续的</p>
<h2 id="容易困惑的地方">容易困惑的地方</h2>
<h3 id="什么是opengl-directx">什么是OpenGL / DirectX</h3>
<p>  如果要开发者直接访问GPU是一件非常麻烦的事情，可能需要和各种寄存器、显存打交道，而图像编程接口在这些硬件的基础上实现了这一层抽象</p>
<p>  OpenGL和DirectX就是这些图像应用编程接口，这些接口用于渲染二维或三维图形，架起了上层应用程序和底层GPU的沟通桥梁</p>
<p>  一个应用程序向这些接口发送渲染命令，而这些接口会依次向显卡驱动（Graphics Driver）发送渲染命令，这些显卡驱动是真正知道如何和GPU通信的角色，正是它们把OpenGL或者DirectX的函数调用翻译成了GPU能够听懂的语言，同时它们也负责把纹理等数据转换成GPU所支持的格式，如图所示：</p>
<p><img src="/images/Shader/Shader_01/Shader_01_17.png" alt=""></p>
<p>  由图可以看出，应用程序可以通过调用OpenGL或DirectX的图形接口将渲染所需的数据，如顶点数据、纹理数据、材质参数等数据存储在显存中的特定区域。随后，开发者可以通过图像编程接口发出渲染命令，这些渲染命令也被称为Draw Call，他们将会呗显卡驱动翻译成GPU能够理解的代码，进行真正的绘制</p>
<p>  一个显卡除了有图像处理单元GPU外，还拥有自己的内存，这个内存通常被称为<strong>显存</strong>（<strong>Video Random Access Memory,VRAM</strong>）。GPU可以在显存中存储任何数据，但对于渲染来说一些数据类型是必须的，例如用于屏幕显示的图像缓冲、深度缓冲等</p>
<p>  因为显卡驱动的存在，几乎所有的GPU都既可以和OpenGL合作，也可以和DirectX一起工作。从显卡的角度出发，市集上他只需要和显卡驱动打交道就可以了</p>
<p>  显卡驱动负责和图像编程接口以及GPU打交道。</p>
<h3 id="什么是hlsl-glsl-cg">什么是HLSL、GLSL、Cg</h3>
<p>  着色语言是专门用于编写着色器的，常见的着色语言有DirectX的HLSL（High Level Shading Language）、OpenGL的GLSL（OpenGL Shading Language）以及NVIDIA的Cg（C for Graphic）</p>
<p>  这些语言都是高级语言，但只是对于汇编语言来说的，而不像是C#对于C的高级。</p>
<p>  这些语言会被编译成与机器无关的汇编语言，也被称为中间语言（Intermediate Language,IL），这些中间语言再交给显卡驱动来翻译成真正的机器语言，即GPU可以理解的语言</p>
<br/>
<p>  GLSL的有点在于它的跨平台性，可以在Windows、Linux、Mac甚至移动平台等多种平台上工作，这种跨平台性是因为OpenGL没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作</p>
<p>  只要显卡驱动支持对GLSL的编译它就可以运行</p>
<p>  好处在于：GLSL完全依赖硬件，而非操作系统层级的。</p>
<p>  但这也意味着GLSL的编译结果将取决于硬件供应商，但是不同的硬件对GLSL的编译实现不尽相同，这可能会造成编译结果不一致的情况，因为这完全取决于供应商的做法</p>
<br/>
<p>  HLSL，是由微软控制的着色器的编译，就算使用了不同的硬件，同一个着色器的编译结果也是一样的（前提是版本相同）</p>
<p>  但是，支持HLSL的平台相对比较有限，几乎完全是微软自己的产品，如Windows、Xbox 360等</p>
<p>  原因就是在其他平台上没有可以编译HLSL的编译器</p>
<br/>
<p>  Cg是真正意义的跨平台，他会根据平台的不同，编译成相应的中间语言。</p>
<p>  Cg语言的跨平台性很大原因取决于与微软的合作，这也导致Cg语言的语法和HLSL非常相像，Cg语言可以无缝移植成HLSL代码</p>
<p>  缺点是可能无法发挥出OpenGL的最新特性</p>
<h3 id="什么是draw-call">什么是Draw Call</h3>
<p>  Draw Call本身的含义很简单，就是CPU调用图像编程接口，以命令GPU进行渲染的操作</p>
<p>  一个误区是：Draw Call中造成性能问题的是GPU，认为GPU上的状态切换是耗时的，其实不是，真正造成这个原因的是CPU</p>
<h4 id="cpu和gpu是如何实现并行工作的？">CPU和GPU是如何实现并行工作的？</h4>
<p>  如果没有流水线化，那么CPU需要等到GPU完成上一个渲染任务才能再次发送渲染命令，但这种方法会造成效率低下</p>
<p>  因此，需要让CPU和GPU可以并行工作，而解决方法就是使用一个<strong>命令缓冲区</strong>（<strong>Command Buffer</strong>）</p>
<p>  命令缓冲区包含了一个命令队列，向CPU向其中添加命令，而由GPU从中读取命令，添加和读取的过程是相互独立的。</p>
<p>  命令缓冲区使得CPU和GPU可以像话独立工作，当CPU需要渲染一些对象，她可以向命令缓冲区中添加命令，而当GPU完成了上一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行</p>
<p>  命令缓冲区中的命令有很多种，Draw Call只是其中一种，其他命令还有改变渲染状态等（例如改变使用的着色器，使用不同的纹理等）。如图</p>
<p><img src="/images/Shader/Shader_01/Shader_01_18.png" alt=""></p>
<h4 id="为什么draw-call多了会影响速率">为什么Draw Call多了会影响速率</h4>
<p>  在每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据、状态和命令等</p>
<p>  在这一阶段，CPU需要完成很多工作，例如检查渲染状态等，而一旦完成了这些工作，GPU就可以开始本次的渲染，而GPU的渲染能力是很强的，因此渲染速度往往快鱼CPU提交命令的速度</p>
<p>  如果Draw Call数量太多，CPU就会把大量的时间花费在提交DrawCall上，造成CPU的过载，如图</p>
<p><img src="/images/Shader/Shader_01/Shader_01_19.png" alt=""></p>
<h4 id="如何减少draw-call">如何减少Draw Call</h4>
<p>  <strong>批处理</strong>（<strong>Batching</strong>），把很多小的Draw Call合并成一个大的Draw Call，这就是批处理的思想，如图</p>
<p><img src="/images/Shader/Shader_01/Shader_01_20.png" alt=""></p>
<p>  需要注意的是，由于需要在CPU的内存中合并网格，合并的过程是需要消耗时间的</p>
<p>  批处理技术更加适合于那些静态的物体，例如大地、石头等，对于这些静态物体只需要合并后一次即可</p>
<p>  批处理也可以对动态物体进行处理，但是这些物体是不断运动的，每一帧都需要重新合并然后发送给GPU，这对空间和时间都会造成一定的影响</p>
<p>  游戏开发过程中，为了减少Draw Call的开销，有两点需要注意</p>
<ol>
<li>避免使用大量很小的网格，当不可避免的需要使用很小的网格结构时，考虑是否可以合并他们</li>
<li>避免使用过多的材质，尽量在不同的网格之间共用同一个材质</li>
</ol>
<h3 id="什么是固定管线渲染">什么是固定管线渲染</h3>
<p>  <strong>固定函数的流水线</strong>（<strong>Fixed-Function Pipeline</strong>），也简称为固定管线，通常是指在较旧的GPU上实现的渲染流水线</p>
<p>  这种流水线只给开发者提供一些配置操作，但开发者没有对流水线阶段的完全控制权</p>
<p>  固定管线通常提供了一系列接口，这些接口包含了一个函数入口点（Function Entry Points）集合，这些函数入口点会匹配GPU上的一个特定的逻辑功能。开发者通过这些接口来控制渲染流水线，也就是说，固定渲染管线是只可配置的管线</p>
<p>  3中最常见的图像接口从固定管线向可编程管线进化的版本</p>
<table>
<thead>
<tr>
<th>3D API</th>
<th>最后支持固定管线的版本</th>
<th>第一个支持可编程管线的版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>OpenGL</td>
<td>1.5</td>
<td>2.0</td>
</tr>
<tr>
<td>OpenGL ES</td>
<td>1.1</td>
<td>2.0</td>
</tr>
<tr>
<td>DirectX</td>
<td>7.0</td>
<td>8.0</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>UnityShader</category>
      </categories>
      <tags>
        <tag>UnityShader</tag>
      </tags>
  </entry>
  <entry>
    <title>C++进修——C++基础入门</title>
    <url>/2024/02/14/C-%E8%BF%9B%E4%BF%AE%E2%80%94%E2%80%94C-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>初识C++</h1>
<h2 id="书写helloworld">书写HelloWorld</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;HelloWorldd&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注释">注释</h2>
<p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员阅读代码<br>
<strong>两种格式</strong>：</p>
<ul>
<li><strong>单行注释</strong>：<code>//描述信息</code>
<ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，<code>对该行代码说明</code></li>
</ul>
</li>
<li><strong>多行注释</strong>：<code>/*描述信息*/</code>
<ul>
<li>通常放在一段代码的上方，<code>对该段代码做整体说明</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h2 id="变量">变量</h2>
<p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 数据名 = 初始值</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量">常量</h2>
<p><strong>作用</strong>：用于记录程序中不可更改的数据<br>
C++定义常量两种方式</p>
<ul>
<li>#define 宏常量：<code>#define 常量名 常量值</code>
<ul>
<li><code>通常在文件上定义</code>，表示一个常量</li>
</ul>
</li>
<li>const修饰的变量：<code>const 数据类型 常量名 = 常量值</code>
<ul>
<li><code>通常在变量定义前加关键字const</code>，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 365</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一年一共有&quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot;天&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> date = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一周一共有&quot;</span> &lt;&lt; date &lt;&lt; <span class="string">&quot;天&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关键字">关键字</h2>
<p><strong>作用</strong>：关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量的时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typeof</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsinged</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>提示：在给变量或者常量起名称的时候，不要用C++的关键字，否则会产生歧义</p>
</blockquote>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int int = 10;</span></span><br><span class="line">	<span class="comment">//第二个int是关键字，不可以做为变量的名称</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标识符命名规则">标识符命名规则</h2>
<p><strong>作用</strong>：C++规定给标识符（常量、变量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h1>数据类型</h1>
<h2 id="整型">整型</h2>
<p><strong>作用</strong>：整型变量表示的是<code>整数类型</code>的数据<br>
C++中能够表示整型的数据类型有以下几种方式，<strong>区别在于内存空间不同</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>short(短整型)</td>
<td>2字节</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>15</mn></msup></mrow><annotation encoding="application/x-tex">-2^{15}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>15</mn></msup></mrow><annotation encoding="application/x-tex">2^{15}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span> - 1</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> - 1</td>
</tr>
<tr>
<td>long(长整型)</td>
<td>Windows为4字节，Linux为4字节（32位），8字节（64位）</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td>long long(长长整型)</td>
<td>8字节</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>63</mn></msup><mtext> </mtext><msup><mn>2</mn><mn>63</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{63} ~ 2^{63} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
</tbody>
</table>
<h2 id="sizeof关键字">sizeof关键字</h2>
<p><strong>作用</strong>：利用sizeof关键字可以<code>统计数据类型所占内存大小</code><br>
<strong>语法</strong>：<code>sizeof(数据类型/变量)</code><br>
<strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short类型所占内存空间为：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int类型所占内存空间为：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long类型所占内存空间为：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long long类型所占内存空间为：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实型-浮点型">实型（浮点型）</h2>
<p><strong>作用</strong>：用于<code>表示小数</code><br>
浮点型变量分为两种：</p>
<ul>
<li>单精度float</li>
<li>双精度double</li>
</ul>
<p>两者的区别在于表示的有效数字范围不同</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>有效数字范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15~16位有效数字</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认情况下，输出一个小数，会显示出6位有效数字</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="comment">//3 * 10^2</span></span><br><span class="line">	<span class="type">float</span> f2 = <span class="number">3e2</span>;</span><br><span class="line">	cout &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符型">字符型</h2>
<p><strong>作用</strong>：字符型变量用于显示单个字符<br>
<strong>语法</strong>：<code>char ch = 'a'</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号<br>
注意2：单引号只能有一个字符，不能是字符串</p>
</blockquote>
<ul>
<li>C和C++种字符型变量只占用<code>1个字节</code></li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27; //错误，单引号只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;<span class="comment">//查看字符ch对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>;<span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASCII码大知由以下<strong>两部分</strong>组成：</p>
<ul>
<li>ASCII非打印字符：ASCII表上的数字<strong>0~31</strong>分配给了<code>控制字符</code>，用于控制像打印机等一些外围设备</li>
<li>ASCII打印字符：数字<strong>32~126</strong>分配给了能在键盘上找到的字符，当查看或打印文档时就会出现</li>
</ul>
<h2 id="转义字符">转义字符</h2>
<p><strong>作用</strong>：用于表示一些<code>不能显示出来的ASCII字符</code><br>
现阶段常用的字符有：<code>\n \\ \t</code></p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页，将当前位置移到下一页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表（跳到下一个tab位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符&quot;&quot;</td>
<td>092</td>
</tr>
<tr>
<td>’</td>
<td>代表一个单引号字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>0</mn><mrow><mn>9</mn><mo separator="true">,</mo><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">0_{9,a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9305479999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>f,A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串型">字符串型</h2>
<p><strong>作用</strong>：用于表示一串字符<br>
<strong>两种风格</strong>：</p>
<ol>
<li><strong>C风格字符串</strong>：<code>char 变量名[] = &quot;字符串值&quot;</code></li>
</ol>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol start="2">
<li><strong>C++风格字符串</strong>：<code>string 变量名 = &quot;字符串值&quot;</code></li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要引用命名空间string，即</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件<code>#include &lt;string&gt;</code></p>
</blockquote>
<h2 id="布尔类型-bool">布尔类型 bool</h2>
<p><strong>作用</strong>：布尔数据类型代表真或假的值<br>
bool类型只有两个值：</p>
<ul>
<li>ture - 真（本质为1）</li>
<li>false - 假（本质为0）</li>
</ul>
<p><strong>bool</strong>类型占一个字节大小</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：布尔类型非0的值都代表为true</p>
</blockquote>
<h2 id="数据的输入">数据的输入</h2>
<p><strong>作用</strong>：用于从键盘获取数据<br>
<strong>关键字</strong>：cin<br>
<strong>语法</strong>：<code>cin &gt;&gt; 变量</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> b = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>运算符</h1>
<h2 id="算术运算符">算术运算符</h2>
<p><strong>作用</strong>：用于处理四则运算</p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>术语</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a = 2,b = ++a;</td>
<td>a = 3,b = 3</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a = 2,b = a++;</td>
<td>a = 3,b = 2</td>
</tr>
<tr>
<td>–</td>
<td>前置递减</td>
<td>a = 2,b = --a;</td>
<td>a = 1,b = 1</td>
</tr>
<tr>
<td>–</td>
<td>后置递减</td>
<td>a = 2,b = a–;</td>
<td>a = 1,b = 2</td>
</tr>
</tbody>
</table>
<p>示例1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//结果向下取整</span></span><br><span class="line">	cout &lt;&lt; a / b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//会报错，除数为0</span></span><br><span class="line">	cout &lt;&lt; x / y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> c = <span class="number">0.5</span>;</span><br><span class="line">	<span class="type">double</span> d = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c / d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a % b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; x % y &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//因为基于除法运算，所以依旧会报错</span></span><br><span class="line">	cout &lt;&lt; m % n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> c = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">double</span> d = <span class="number">1.1</span>;</span><br><span class="line">	<span class="comment">//两个小数不可以进行取模运算</span></span><br><span class="line">	cout &lt;&lt; c % d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增递减</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> d = c++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> e = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> f = ++e * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符">赋值运算符</h2>
<p><strong>作用</strong>：用于将表达式的值赋值给变量</p>
<p>赋值运算符包括以下几个符号</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>术语</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
<td>a = 2,b = 3</td>
<td>a = 2,b = 3</td>
</tr>
<tr>
<td>+=</td>
<td>加等于</td>
<td>a = 0,a += 2</td>
<td>a = 2</td>
</tr>
<tr>
<td>-=</td>
<td>减等于</td>
<td>a = 5,a -= 3</td>
<td>a = 2</td>
</tr>
<tr>
<td>*=</td>
<td>乘等于</td>
<td>a = 2,a *= 2</td>
<td>a = 4</td>
</tr>
<tr>
<td>/=</td>
<td>除等于</td>
<td>a = 4,a /= 2</td>
<td>a = 2</td>
</tr>
<tr>
<td>%=</td>
<td>模等于</td>
<td>a = 3,a %= 2</td>
<td>a = 1</td>
</tr>
</tbody>
</table>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较运算符">比较运算符</h2>
<p><strong>作用</strong>：用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>术语</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>4 &gt;= 3</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p><strong>作用</strong>：用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>术语</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真，反之同理</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a,b都为真，则结果才为真</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a或b至少有一个为真，则结果为真</td>
</tr>
</tbody>
</table>
<p>示例1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>程序流程结构</h1>
<h2 id="选择结构">选择结构</h2>
<h3 id="if语句">if语句</h3>
<p><strong>作用</strong>：执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li>单行格式if语句</li>
<li>多行格式if语句</li>
<li>多条件的if语句</li>
</ul>
<ol>
<li>单行格式if语句：<code>if(条件)(条件满足执行的语句)</code></li>
</ol>
<p><img src="/images/c++/c++_1/c++_1_1.png" alt=""></p>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个分数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您输入的分数为：&quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(score &gt; <span class="number">600</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;恭喜你考上了一本&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>多行格式if语句：<code>if(条件)&#123;条件满足执行的语句&#125;else&#123;条件不满足执行的语句&#125;</code></li>
</ol>
<p><img src="/images/c++/c++_1/c++_1_2.png" alt=""></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(score &gt; <span class="number">600</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;恭喜考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>多条件的if语句：<code>if(条件1)&#123;条件1满足执行的语句&#125;else if(条件2)&#123;条件2满足执行的语句&#125;...else&#123;都不满足执行的语句&#125;</code></li>
</ol>
<p><img src="/images/c++/c++_1/c++_1_3.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(score &gt; <span class="number">600</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">500</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">400</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未考上大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更准确的条件判断</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(score &gt; <span class="number">600</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(score &gt;<span class="number">700</span>)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">650</span>)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">500</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">400</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未考上大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三目运算符">三目运算符</h3>
<p><strong>作用</strong>：通过三目运算符实现简单的判断</p>
<p><strong>语法</strong>：<code>表达式1 ? 表达式2 : 表达式3</code></p>
<p><strong>解释</strong>：如果表达式1为真，则执行表达式2，否则执行表达式3</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch语句">switch语句</h3>
<p><strong>作用</strong>：执行多条件分支语句<br>
<strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(score)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;经典电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;经典电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;非常好的电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;非常好的电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;一般电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;一般电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环结构">循环结构</h2>
<h3 id="while循环语句">while循环语句</h3>
<p><strong>作用</strong>：满足循环条件，执行循环语句</p>
<p><strong>语法</strong>：<code>while(循环条件)&#123;循环语句&#125;</code></p>
<p><strong>解释</strong>：只要循环条件的结果为真，就执行循环语句</p>
<p><img src="/images/c++/c++_1/c++_1_4.png" alt=""></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-while循环语句">do…while循环语句</h3>
<p><strong>作用</strong>：满足循环条件，执行循环语句</p>
<p><strong>语法</strong>：<code>do&#123;循环语句&#125;while(循环条件)</code></p>
<p><strong>注意</strong>：与while的区别在于do…while会先执行一次循环语句，再判断循环条件</p>
<p><img src="/images/c++/c++_1/c++_1_5.png" alt=""></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;<span class="keyword">while</span>(num &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for循环语句">for循环语句</h3>
<p><strong>作用</strong>：满足循环条件，执行循环语句</p>
<p><strong>语法</strong>：<code>for(起始表达式;条件表达式;末尾循环体)&#123;循环语句;&#125;</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套循环">嵌套循环</h3>
<p><strong>作用</strong>：在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">10</span>;j++)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;* &quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳转语句">跳转语句</h2>
<h3 id="break语句">break语句</h3>
<p><strong>作用</strong>：用于跳出<code>选择结构</code>或者<code>循环结构</code></p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的循环语句</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择你挑战的副本&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1. 普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2. 中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3. 困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &lt;&lt; num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(num)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;参数错误&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j == <span class="number">5</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="continue语句">continue语句</h3>
<p><strong>作用</strong>：在<code>循环语句</code>中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="goto语句">goto语句</h3>
<p><strong>作用</strong>：可以无条件语句</p>
<p><strong>语法</strong>：<code>goto 标记</code></p>
<p><strong>注意</strong>：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>数组</h1>
<h2 id="概述">概述</h2>
<p>数组就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1</strong>：数组中的每个<code>数据元素都是相同的数据类型</code></p>
<p><strong>特点2</strong>：数组是由<code>连续的内存</code>位置构成的</p>
<h2 id="一维数组">一维数组</h2>
<h3 id="一维数组定义方式">一维数组定义方式</h3>
<p>一维数组定义的三种方式：</p>
<ul>
<li><code>数据类型 数组名[数组长度];</code></li>
<li><code>数据类型 数组名[数组长度] = &#123;值1,值2,值3&#125;;</code></li>
<li><code>数据类型 数组名[] = &#123;值1,值2,值3&#125;;</code></li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score2[<span class="number">10</span>] = &#123;<span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score3[] = &#123;<span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维数组数组名">一维数组数组名</h3>
<p>一维数组名称的<strong>用途</strong>：</p>
<ul>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为：&quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序">冒泡排序</h3>
<p><strong>作用</strong>：最常用的排序算法，对数组内元素进行排序</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个</li>
<li>对每一组相邻元素做同样的工作，执行完毕后，找到第一个最大值</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span> - i;j++&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维数组">二维数组</h2>
<p>二维数组就是在一维数组上多加一个维度</p>
<h3 id="二维数组定义方式">二维数组定义方式</h3>
<p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型 数组名[行数][列数];</code></li>
<li><code>数据类型 数组名[行数][列数] = &#123;&#123;数据1,数据2&#125;,&#123;数据3,数据4&#125;&#125;;</code></li>
<li><code>数据类型 数组名[行数][列数] = &#123;数据1,数据2,数据3,数据4&#125;;</code></li>
<li><code>数据类型 数组名[][列数] = &#123;数据1,数据2,数据3,数据4&#125;;</code></li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr4[][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组数组名">二维数组数组名</h3>
<p><strong>用途</strong>：</p>
<ul>
<li>查看二维数组所占空间</li>
<li>获取二维数组首地址</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址&quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址&quot;</span> &lt;&lt; (<span class="type">int</span>)arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址&quot;</span> &lt;&lt; (<span class="type">int</span>)arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>函数</h1>
<h2 id="概述">概述</h2>
<p><strong>作用</strong>：将一段经常使用的代码封装起来，减少重复代码</p>
<h2 id="函数的定义">函数的定义</h2>
<p>函数的定义一般主要有5个步骤：</p>
<ol>
<li>返回值类型</li>
<li>函数名</li>
<li>参数表列</li>
<li>函数体语句</li>
<li>return 表达式</li>
</ol>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(参数列表)&#123;</span><br><span class="line">	函数体语句</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值类型：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式：和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的调用">函数的调用</h2>
<p><strong>功能</strong>：使用定义好的函数<br>
<strong>语法</strong>：<code>函数名(参数)</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sum = <span class="built_in">add</span>(a,b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	sum = <span class="built_in">add</span>(a,b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="值传递">值传递</h2>
<ul>
<li>值传递就是函数调用时实参数值传入给形参</li>
<li>值传递时，<code>如果形参发生，并不会影响实参</code></li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap</span>(a,b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的常见样式">函数的常见样式</h2>
<p>常见的函数样式有四种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;test02&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;test03&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;test04&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test02</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num1 = <span class="built_in">test03</span>();</span><br><span class="line">	cout &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num2 = <span class="built_in">test04</span>(<span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的声明">函数的声明</h2>
<p><strong>作用</strong>：告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义</p>
<p>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></p>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a,b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的分文件编写">函数的分文件编写</h2>
<p><strong>作用</strong>：让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件</li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(<span class="type">int</span> a,<span class="type">int</span> b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>指针</h1>
<h2 id="指针的基本概念">指针的基本概念</h2>
<p><strong>指针的作用</strong>：可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用16进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h2 id="指针变量的定义和使用">指针变量的定义和使用</h2>
<p>指针变量定义语法：<code>数据类型 * 变量名;</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line">	p = &amp;a;</span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; * p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针所占内存空间">指针所占内存空间</h2>
<p>在32位系统下，指针占4位字节空间大小，64位为8位字节空间大小</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空指针和野指针">空指针和野指针</h2>
<p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途</strong>：初始化指针变量</p>
<p><strong>注意</strong>：空指针指向的内存是不可以访问的，0~255号内存为系统占用内存</p>
<p>示例1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//会报错</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p>示例2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//指针变量指向内存编号为0x1100的空间</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//报错</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const修饰指针">const修饰指针</h2>
<p>const修饰指针有三种情况：</p>
<ol>
<li>const修饰指针——常量指针</li>
<li>const修饰常量——指针常量</li>
<li>const既修饰指针，又修饰常量</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针的指向可以改，指针指向的值不可以修改</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1 = &amp;a;</span><br><span class="line">	p1 = &amp;b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//报错</span></span><br><span class="line">	*p1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//报错</span></span><br><span class="line">	p2 = &amp;b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//都报错</span></span><br><span class="line">	p3 = &amp;b;</span><br><span class="line">	p3 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针和数组">指针和数组</h2>
<p><strong>作用</strong>：利用指针访问数组中元素</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针和函数">指针和函数</h2>
<p><strong>作用</strong>：利用指针作函数参数，可以修改实参的值</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1,<span class="type">int</span> * p2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//值传递不会改变实参</span></span><br><span class="line">	<span class="built_in">swap1</span>(a,b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递会改变实参</span></span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a,&amp;b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针-数组-函数">指针，数组，函数</h2>
<p><strong>案例描述</strong>：封装一个函数，利用冒泡排序，实现对整形数组的升序排列</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len - <span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; len - <span class="number">1</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> * arr,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr,len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printArray</span>(arr,len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>结构体</h1>
<h2 id="结构体基本概念">结构体基本概念</h2>
<p>结构体属于<mark>自定义的数据类型</mark>，允许用户存储不同的数据类型</p>
<h2 id="结构体定义和使用">结构体定义和使用</h2>
<p><strong>语法</strong>：<code>struct 结构体名 &#123;结构体成员列表&#125;;</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = {成员1值，成员2值}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student stu1;</span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; stu1.name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; stu1.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	student stu2 = &#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span>&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; stu2.name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; stu2.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体数组">结构体数组</h2>
<p><strong>作用</strong>：将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法</strong>：<code>struct 结构体名 数组名[元素个数] = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">88</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	arr[<span class="number">2</span>].name = <span class="string">&quot;赵六&quot;</span>;</span><br><span class="line">	arr[<span class="number">2</span>].age = <span class="number">17</span>;</span><br><span class="line">	arr[<span class="number">2</span>].score = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">		cout &lt;&lt; stu[i].name &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; stu[i].age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; stu[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体指针">结构体指针</h2>
<p><strong>作用</strong>：通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt;</code> 可以通过结构体指针访问结构体属性</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student stu = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">	student *p = &amp;stu;</span><br><span class="line"></span><br><span class="line">	p -&gt; score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p -&gt; name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体嵌套结构体">结构体嵌套结构体</h2>
<p><strong>作用</strong>：结构体中的成员可以是另一个结构体</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	teacher t1;</span><br><span class="line">	t1.id = <span class="number">10000</span>;</span><br><span class="line">	t1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t1.stu.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	t1.stu.age = <span class="number">15</span>;</span><br><span class="line">	t1.stu.score = <span class="number">59</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; t1.id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体做函数参数">结构体做函数参数</h2>
<p><strong>作用</strong>：将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu)</span></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; stu.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent1</span><span class="params">(student *stu)</span></span>&#123;</span><br><span class="line">	stu -&gt; age = <span class="number">29</span>;</span><br><span class="line">	cout &lt;&lt; stu -&gt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student stu = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">15</span>,<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; stu.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent1</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; stu.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体中const使用场景">结构体中const使用场景</h2>
<p><strong>作用</strong>：用const来防止误操作</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span></span>&#123;</span><br><span class="line">	<span class="comment">//无法操作，因为加了const修饰</span></span><br><span class="line">	stu -&gt; age = <span class="number">199</span>;</span><br><span class="line">	cout &lt;&lt; stu -&gt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student stu = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">15</span>,<span class="number">199</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++进修——通讯录管理系统</title>
    <url>/2024/04/19/C-%E8%BF%9B%E4%BF%AE%E2%80%94%E2%80%94%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1>通讯录管理系统</h1>
<h2 id="系统需求">系统需求</h2>
<p>系统中需要实现的功能如下：</p>
<ul>
<li>添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址），最多记录1000人</li>
<li>显示联系人：显示通讯录中所有联系人信息</li>
<li>删除联系人：按照姓名进行删除指定联系人</li>
<li>查找联系人：按照姓名查看指定联系人信息</li>
<li>修改联系人：按照姓名重新修改指定联系人</li>
<li>清空联系人：清空通讯录中所有信息</li>
<li>退出通讯录：退出当前使用的通讯录</li>
</ul>
<h2 id="菜单功能">菜单功能</h2>
<p><strong>功能描述</strong>：用户选择功能的界面</p>
<p><strong>步骤</strong>：</p>
<ul>
<li>封装函数显示该界面，如<code>void showMenu()</code></li>
<li>在main函数中调用封装好的函数</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMenu</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;**************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  1.添加联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  2.显示联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  3.删除联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  4.查找联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  5.修改联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  6.清空联系人  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****  0.退出通讯录  *****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;**************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">showMenu</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="退出功能">退出功能</h2>
<p><strong>功能描述</strong>：退出通讯录系统</p>
<p><strong>思路</strong>：根据用户不同的选择，进入不同的功能，可以选择switch分支结构，将整个架构进行搭建</p>
<p>当用户输入0的时候退出系统，其他输入先不考虑</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="built_in">showMenu</span>();</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(select)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;输入非法&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加联系人">添加联系人</h2>
<p><strong>功能描述</strong>：实现添加联系人功能，联系上限为1000人，联系人信息包括姓名、性别、年龄、联系电话、家庭住址</p>
<p>添加联系人实现步骤：</p>
<ul>
<li>设计联系人结构体</li>
<li>设计通讯录结构体</li>
<li>main函数中创建通讯录</li>
<li>封装添加联系人函数</li>
<li>测试添加联系人功能</li>
</ul>
<h3 id="设计联系人结构体">设计联系人结构体</h3>
<p>联系人信息已经给出</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Sex;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">	string m_Phone;</span><br><span class="line">	string m_Addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="设计通讯录结构体">设计通讯录结构体</h3>
<p>设计的时候可以维护一个容量为1000的存放联系人的数组，并记录当前通讯录中联系人数量</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Addressbooks</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Person</span> personArray[MAX];</span><br><span class="line">	<span class="type">int</span> m_Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="main函数中创建通讯录">main函数中创建通讯录</h3>
<p>添加联系人函数封装好，在main函数中创建一个通讯录变量，这个就是需要已知维护的通讯录</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">main函数起始位置添加：</span><br><span class="line"></span><br><span class="line">	Addressbooks abs;</span><br><span class="line">	abs.m_Size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="封装添加联系人函数">封装添加联系人函数</h3>
<p><strong>思路</strong>：添加联系人前先判断通讯录是否已满，如果满了就不再添加，未满情况将新联系人信息逐个加入到通讯录</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addPerson</span><span class="params">(Addressbooks *abs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(abs -&gt; m_Size == MAX)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;通讯录已满，无法添加&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		string name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入名字&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		abs -&gt; personArray[abs -&gt; m_Size].m_Name = name;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入性别&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 -- 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2 -- 女&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> sex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			cin &gt;&gt; sex;</span><br><span class="line">			<span class="keyword">if</span>(sex == <span class="number">1</span> || sex == <span class="number">2</span>)&#123;</span><br><span class="line">				abs -&gt; personArray[abs -&gt; m_Size].m_Sex = sex;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入错误，重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; age;</span><br><span class="line">		abs -&gt; personArray[abs -&gt; m_Size].m_Age = age;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入电话号码&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string phone = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		cin &gt;&gt; phone;</span><br><span class="line">		abs -&gt; personArray[abs -&gt; m_Size].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入家庭住址&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string address = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		cin &gt;&gt; address;</span><br><span class="line">		abs -&gt; personArray[abs -&gt; m_Size].m_Addr = address;</span><br><span class="line"></span><br><span class="line">		abs -&gt; m_Size++;</span><br><span class="line"></span><br><span class="line">		cout &gt;&gt; <span class="string">&quot;添加成功&quot;</span> &gt;&gt; endl;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试添加联系人功能">测试添加联系人功能</h3>
<p>在switch case中，case 1里添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="built_in">addPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="显示联系人">显示联系人</h2>
<p><strong>功能描述</strong>：显示通讯录中已有的联系人信息</p>
<p>显示联系人实现步骤：</p>
<ul>
<li>封装显示联系人函数</li>
<li>测试显示联系人功能</li>
</ul>
<h3 id="封装显示联系人函数">封装显示联系人函数</h3>
<p><strong>思路</strong>：判断如果当前通讯录中没有人员，就提示记录为空，人数大于0，显示通讯录中所有信息</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">(Addressbooks *abs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(abs -&gt; m_Size == <span class="number">0</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;当前记录为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; abs -&gt; m_Size;i++)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; abs -&gt; personArray[i].m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;性别：&quot;</span> &lt;&lt; abs -&gt; (personArray[i].m_Sex == <span class="number">1</span> ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; abs -&gt; personArray[i].m_Age &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;电话：&quot;</span> &lt;&lt; abs -&gt; personArray[i].m_Phone &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;住址：&quot;</span> &lt;&lt; abs -&gt; personArray[i].m_Addr &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试显示联系人功能">测试显示联系人功能</h3>
<p>在switch case语句中，case 2里添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	<span class="built_in">showPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="删除联系人">删除联系人</h2>
<p><strong>功能描述</strong>：按照姓名进行删除指定联系人</p>
<p>删除联系人实现步骤：</p>
<ul>
<li>封装检测联系人是否存在</li>
<li>封装删除联系人函数</li>
<li>测试删除联系人功能</li>
</ul>
<h3 id="封装检测联系人是否存在">封装检测联系人是否存在</h3>
<p><strong>设计思路</strong>：</p>
<p>  删除联系人前，需要先判断用户输入的联系人是否存在，如果存在则删除，不存在则提示用户没有要删除的联系人，</p>
<p>  所以把检测联系人是否存在封装成一个函数，如果存在，返回所在位置，不存在返回 -1</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isExist</span><span class="params">(Addressbooks *abs,string name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; abs -&gt; m_Size;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(abs -&gt; personArray[i].m_Name == name)&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="封装删除联系人函数">封装删除联系人函数</h3>
<p>根据用户输入的联系人判断该通讯录中是否有此人</p>
<p>查找到进行删除，并提示删除成功</p>
<p>查不到提示查无此人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletePerson</span><span class="params">(Address *abs)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入要删除的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">isExist</span>(abs,name);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = ret;i &lt; abs -&gt; m_Size;i++)&#123;</span><br><span class="line">			abs -&gt; personArray[i] = abs -&gt; personArray[i+<span class="number">1</span>];</span><br><span class="line">			abs -&gt; m_Size--;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;删除成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找联系人">查找联系人</h2>
<p><strong>功能描述</strong>：按照姓名查看指定联系人信息</p>
<p>查找联系人实现步骤：</p>
<ul>
<li>封装查找联系人函数</li>
<li>测试查找指定联系人</li>
</ul>
<h3 id="封装查找联系人函数">封装查找联系人函数</h3>
<p><strong>实现思路</strong>：判断用户指定的联系人是否存在，如果存在显示信息，不存在则提示查无此人</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findPerson</span><span class="params">(Addressbooks *abs)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入你要查找的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">isExist</span>(abs,name);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">-1</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; abs -&gt; personArray[i].m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;性别：&quot;</span> &lt;&lt; abs -&gt; (personArray[i].m_Sex == <span class="number">1</span> ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>) &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; abs -&gt; personArray[i].m_Age &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;电话：&quot;</span> &lt;&lt; abs -&gt; personArray[i].m_Phone &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;住址：&quot;</span> &lt;&lt; abs -&gt; personArray[i].m_Addr &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改联系人">修改联系人</h2>
<p><strong>功能描述</strong>：按照姓名重新修改指定联系人</p>
<p>修改联系人实现步骤：</p>
<ul>
<li>封装修改联系人函数</li>
<li>测试修改联系人功能</li>
</ul>
<h3 id="封装修改联系人函数">封装修改联系人函数</h3>
<p><strong>实现思路</strong>：查找用户输入的联系人，如果查找成功进行修改操作，查找失败提示查无此人</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyPerson</span><span class="params">(Addressbooks *abs)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入要修改的联系人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">isExist</span>(abs,name);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">-1</span>)&#123;</span><br><span class="line">		string name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入姓名&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		abs -&gt; personArray[ret].m_Name = name;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入性别&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 -- 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2 -- 女&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> sex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			cin &gt;&gt; sex;</span><br><span class="line">			<span class="keyword">if</span>(sex == <span class="number">1</span> || sex == <span class="number">2</span>)&#123;</span><br><span class="line">				abs -&gt; personArray[ret].m_Sex = sex;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入错误，重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入年龄&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; age;</span><br><span class="line">		abs -&gt; personArray[ret].m_Age = age;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入电话号码&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string phone = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		cin &gt;&gt; phone;</span><br><span class="line">		abs -&gt; personArray[ret].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入家庭住址&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string address = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		cin &gt;&gt; address;</span><br><span class="line">		abs -&gt; personArray[ret].m_Addr = address;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试修改联系人功能">测试修改联系人功能</h3>
<p>在switch case中，case 5里添加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">	<span class="built_in">modifyPerson</span>(&amp;abs);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="清空联系人">清空联系人</h2>
<p><strong>功能描述</strong>：清空通讯录中的所有信息</p>
<p>清空联系人实现步骤：</p>
<ul>
<li>封装清空联系人函数</li>
<li>测试清空联系人</li>
</ul>
<h3 id="封装清空联系人函数">封装清空联系人函数</h3>
<p><strong>实现思路</strong>：将通讯录所有联系人信息删除掉，只要将通讯录记录的联系人数量置为0，做逻辑清空即可</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearPerson</span><span class="params">(Addressbooks *abs)</span></span>&#123;</span><br><span class="line">	abs -&gt; m_Size = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通讯录已清空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏热更新进修——Lua编程</title>
    <url>/2024/04/20/%E6%B8%B8%E6%88%8F%E7%83%AD%E6%9B%B4%E6%96%B0%E8%BF%9B%E4%BF%AE%E2%80%94%E2%80%94Lua%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1>Lua编程</h1>
<h2 id="lua是什么">Lua是什么</h2>
<p>  Lua是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的拓展和定制功能</p>
<p>  Lua可以方便的和其他进程进行集成(C++,c#,java,)</p>
<h2 id="lua应用场景">Lua应用场景</h2>
<ul>
<li>游戏开发</li>
<li>独立应用脚本</li>
<li>Web应用程序</li>
<li>拓展和数据库插件如:MySQL,Proxy和MySQL WorkBench</li>
<li>安全系统，如入侵检测系统</li>
</ul>
<h2 id="lua和c-的区别">Lua和C#的区别</h2>
<p>  Lua可以在几乎所有的操作系统和平台进行编译运行</p>
<p>  可以很方便的更新代码</p>
<p>  更新了代码后，可以直接在手机上运行，不需要重新安装（后续的热更新方案）</p>
<br/>
<p>  C#只能在特定的操作系统中进行编译成dll文件，然后打包进安装包在其他平台（Android，IOS）运行</p>
<p>  在移动平台上不能更新替换已有的dll文件，除非重新下载安装包</p>
<h2 id="lua基本语法">Lua基本语法</h2>
<h3 id="print方法-单行和多行注释">print方法，单行和多行注释</h3>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Aubyn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这是一条注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">这是多行注释</span></span><br><span class="line"><span class="comment">这是多行注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>
<h3 id="lua中的标识符命名规则">Lua中的标识符命名规则</h3>
<p>  Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上 0 个或多个字母，下划线，数字（0 到 9）。</p>
<p>  最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。</p>
<p>  Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。</p>
<h3 id="关键词">关键词</h3>
<p>  以下列出了 Lua 的保留关键词。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<table>
<thead>
<tr>
<th>and</th>
<th>break</th>
<th>do</th>
<th>else</th>
</tr>
</thead>
<tbody>
<tr>
<td>elseif</td>
<td>end</td>
<td>false</td>
<td>for</td>
</tr>
<tr>
<td>function</td>
<td>if</td>
<td>in</td>
<td>local</td>
</tr>
<tr>
<td>nil</td>
<td>not</td>
<td>or</td>
<td>repeat</td>
</tr>
<tr>
<td>return</td>
<td>then</td>
<td>true</td>
<td>until</td>
</tr>
<tr>
<td>while</td>
<td>goto</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>  一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p>
<h3 id="全局变量">全局变量</h3>
<p>  在默认情况下，变量总是认为是全局的。</p>
<p>  全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  如果想删除一个全局变量，只需要将变量赋值为nil。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">b = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p>  当且仅当一个变量不等于nil时，这个变量即存在。</p>
<h2 id="lua数据类型">Lua数据类型</h2>
<h3 id="lua中的数据类型">Lua中的数据类型</h3>
<p>  Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nil</td>
<td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td>boolean</td>
<td>包含两个值：false和true。</td>
</tr>
<tr>
<td>number</td>
<td>表示双精度类型的实浮点数</td>
</tr>
<tr>
<td>string</td>
<td>字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td>function</td>
<td>由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td>userdata</td>
<td>表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td>thread</td>
<td>表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td>table</td>
<td>Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody>
</table>
<h3 id="关于nil的用法">关于nil的用法</h3>
<p>  nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Aubyn&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line">name = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>
<p>  对于全局变量和 table，nil 还有一个&quot;删除&quot;作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉，执行下面代码就知：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">tab1 = &#123;key1 = <span class="string">&quot;value&quot;</span>,key2 = <span class="string">&quot;value1&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tab1.key1)</span><br><span class="line"></span><br><span class="line">tab1.key1 = <span class="literal">nil</span></span><br><span class="line">tab1 = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(tab1)</span><br></pre></td></tr></table></figure>
<p>  nil 作比较时应该加上双引号 <code>&quot;</code>：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(X)==<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x) == <span class="string">&quot;nil&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>  <code>type(X)==nil</code> 结果为 <code>false</code> 的原因是 <code>type(X)</code> 实质是返回的 “nil” 字符串，是一个 <code>string</code> 类型：</p>
<h3 id="关于boolean类型的用法">关于boolean类型的用法</h3>
<p>  boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 false，其他的都为 true，数字 0 也是 true:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">false</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> <span class="keyword">or</span> <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;至少有一个是true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;flase和nil都为flase&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;数字0是true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;数字0是false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="关于number数字类型的用法">关于number数字类型的用法</h3>
<p>  Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2e+1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2e-1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">7.8263692594256e-06</span>))</span><br></pre></td></tr></table></figure>
<h3 id="关于string字符串类型的用法">关于string字符串类型的用法</h3>
<p>  字符串由一对双引号或单引号来表示。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">&quot;this is string1&quot;</span></span><br><span class="line">string2 = <span class="string">&quot;this is string2&quot;</span></span><br></pre></td></tr></table></figure>
<p>  也可以用 2 个方括号 “[[]]” 来表示&quot;一块&quot;字符串。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">html = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(html)</span><br></pre></td></tr></table></figure>
<p>  在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2&quot;</span> + <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2&quot;</span> + <span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2 + 6&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-2e2&quot;</span> * <span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--报错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;error&quot;</span> + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>  以上代码中&quot;error&quot; + 1执行报错了，字符串连接使用的是 … ，如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&quot;</span> .. <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">157</span> .. <span class="number">428</span>)</span><br></pre></td></tr></table></figure>
<p>  使用 # 来计算字符串的长度，放在字符串前面，如下实例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span> = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;www.runoob.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="关于table表的用法">关于table表的用法</h3>
<p>  在 Lua 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> tbl1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tbl2 = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>  Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span></span><br><span class="line">key = <span class="number">10</span></span><br><span class="line">a[key] = <span class="number">22</span></span><br><span class="line">a[key] = a[key] + <span class="number">11</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; : &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.key)</span><br><span class="line"><span class="built_in">print</span>(a[key])</span><br></pre></td></tr></table></figure>
<p>  不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> tbl = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(tbl) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key&quot;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tbl[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>  table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a3 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">    a3[i] = i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a3[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;val&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a3[<span class="string">&quot;key&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a3[<span class="string">&quot;none&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a3[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="关于function函数的用法">关于function函数的用法</h3>
<p>  在 Lua 中，函数是被看作是&quot;第一类值（First-Class Value）&quot;，函数可以存在变量里:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span><span class="params">(n)</span></span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> n * factorial1(n - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial1(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">factorial2 = factorial1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial2(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>  function 可以以匿名函数（anonymous function）的方式通过参数传递:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFun</span><span class="params">(tab,fun)</span></span></span><br><span class="line">	<span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">print</span>(fun(k,v))</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tab = &#123;key1 = <span class="string">&quot;val1&quot;</span>,key2 = <span class="string">&quot;val2&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">testFun(tab,</span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(key,val)</span></span></span><br><span class="line">	<span class="keyword">return</span> key .. <span class="string">&quot;=&quot;</span> .. val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="关于thread和userdata类型">关于thread和userdata类型</h3>
<h4 id="thread-线程">thread(线程)</h4>
<p>  在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p>
<p>  线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p>
<h4 id="userdata-自定义类型">userdata(自定义类型)</h4>
<p>  userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p>
<h2 id="lua变量">Lua变量</h2>
<h3 id="全局变量和局部变量的声明和使用">全局变量和局部变量的声明和使用</h3>
<p>  变量在使用前，需要在代码中进行声明，即创建该变量。</p>
<p>  编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。</p>
<p>  Lua 变量有三种类型：全局变量、局部变量、表中的域。</p>
<p>  Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p>
<p>  局部变量的作用域为从声明位置开始到所在语句块结束。</p>
<p>  变量的默认值均为 nil。</p>
<h3 id="lua中的多变量同时赋值">Lua中的多变量同时赋值</h3>
<p>  赋值是改变一个变量的值和改变表域的最基本的方法。</p>
<p>  Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p>
<p>  遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作</p>
<p>  当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：</p>
<blockquote>
<p>a. 变量个数 &gt; 值的个数             按变量个数补足nil<br>
b. 变量个数 &lt; 值的个数             多余的值会被忽略</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a,b,c = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b,c)</span><br><span class="line"></span><br><span class="line">a,b = a+<span class="number">1</span>,b+<span class="number">1</span>,b+<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"></span><br><span class="line">a,b,c = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c)</span><br></pre></td></tr></table></figure>
<p>  上面最后一个例子是一个常见的错误情况，注意：如果要对多个变量赋值必须依次对每个变量赋值。</p>
<p>  多值赋值经常用来交换变量，或将函数调用返回给变量：</p>
<blockquote>
<p> a, b = f()</p>
</blockquote>
<p>  f()返回两个值，第一个赋给a，第二个赋给b。</p>
<p>  应该尽可能的使用局部变量，有两个好处：</p>
<ol>
<li>避免命名冲突。</li>
<li>访问局部变量的速度比全局变量更快。</li>
</ol>
<h2 id="lua循环">Lua循环</h2>
<h3 id="while循环">while循环</h3>
<p>  Lua 编程语言中 while 循环语法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  statements(循环体语句) 可以是一条或多条语句，condition(条件) 可以是任意表达式，在 condition(条件) 为 true 时执行循环体语句。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(a&lt;<span class="number">20</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">	a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="for循环和repeat-until循环">for循环和repeat until循环</h3>
<h4 id="for循环">for循环</h4>
<p>  Lua 编程语言中 for语句有两大类：：</p>
<ul>
<li>
<p>数值for循环</p>
</li>
<li>
<p>泛型for循环</p>
</li>
</ul>
<h5 id="数值for循环">数值for循环</h5>
<p>Lua 编程语言中数值 for 循环语法格式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var=exp1,exp2,exp3 <span class="keyword">do</span>  </span><br><span class="line">    &lt;执行体&gt;  </span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure>
<p>  var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 “执行体”。exp3 是可选的，如果不指定，默认为1。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,f(x) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  for的三个表达式在循环开始前一次性求值，以后不再进行求值。比如上面的f(x)只会在循环开始前执行一次，其结果用在后面的循环中。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;function&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,f(<span class="number">5</span>) <span class="keyword">do</span> <span class="built_in">print</span>(i)  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="泛型for循环">泛型for循环</h5>
<p>  泛型 for 循环通过一个迭代器函数来遍历所有值，类似 java 中的 foreach 语句。</p>
<p>  Lua 编程语言中泛型 for 循环语法格式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>
<p>  i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">days = &#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(days) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="repeat-nutil循环">repeat…nutil循环</h4>
<p>  Lua 编程语言中 repeat…until 循环语句不同于 for 和 while循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat…until 循环的条件语句在当前循环结束后判断。</p>
<p>  Lua 编程语言中 repeat…until 循环语法格式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">until</span>( condition )</span><br></pre></td></tr></table></figure>
<p>  循环条件判断语句（condition）在循环体末尾部分，所以在条件进行判断前循环体都会执行一次。</p>
<p>  如果条件判断语句（condition）为 false，循环会重新开始执行，直到条件判断语句（condition）为 true 才会停止执行。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">	a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span>(a &gt; <span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<h3 id="关于循环嵌套">关于循环嵌套</h3>
<p>  Lua 编程语言中允许循环中嵌入循环。以下实例演示了 Lua 循环嵌套的应用。</p>
<p>  Lua 编程语言中 for 循环嵌套语法格式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> init,<span class="built_in">max</span>/<span class="built_in">min</span> value, increment</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="keyword">for</span> init,<span class="built_in">max</span>/<span class="built_in">min</span> value, increment</span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">      statements</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  Lua 编程语言中 while 循环嵌套语法格式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="keyword">while</span>(condition)</span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">      statements</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  Lua 编程语言中 repeat…until 循环嵌套语法格式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   statements</span><br><span class="line">   <span class="keyword">repeat</span></span><br><span class="line">      statements</span><br><span class="line">   <span class="keyword">until</span>( condition )</span><br><span class="line"><span class="keyword">until</span>( condition )</span><br></pre></td></tr></table></figure>
<p>  除了以上同类型循环嵌套外，我们还可以使用不同的循环类型来嵌套，如 for 循环体中嵌套 while 循环。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">j = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">2</span>,(i/j),<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">not</span>(i%j)) <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">if</span>(j &gt; (i / j)) <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">print</span>(i)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="lua流程控制">Lua流程控制</h2>
<h3 id="if语句">if语句</h3>
<p>  Lua if 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。</p>
<p>  if 语句语法格式如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式为 true 时执行的语句 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  在布尔表达式为 true 时会if中的代码块会被执行，在布尔表达式为 false 时，紧跟在 if 语句 end 之后的代码会被执行。</p>
<p>  Lua认为false和nil为假，true 和非nil为真。要注意的是Lua中 0 为 true。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&lt;&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<h3 id="if-else语句">if…else语句</h3>
<p>  if 语句可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码块。</p>
<p>  if…else 语句语法格式如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 false 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(a == <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<h3 id="if嵌套语句">if嵌套语句</h3>
<p>  if 嵌套语句语法格式如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( 布尔表达式 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式 1 为 true 时执行该语句块 --]</span></span><br><span class="line">   <span class="keyword">if</span>(布尔表达式 <span class="number">2</span>)</span><br><span class="line">   <span class="keyword">then</span></span><br><span class="line">      <span class="comment">--[ 布尔表达式 2 为 true 时执行该语句块 --]</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">100</span>) <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">200</span>)</span><br><span class="line">	<span class="keyword">then</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;200&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<h2 id="lua函数">Lua函数</h2>
<h3 id="function用法特性总结">function用法特性总结</h3>
<p>  函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。</p>
<p>  函数主要有两种用途：</p>
<ol>
<li>完成指定的任务，这种情况下函数作为调用语句使用；</li>
<li>计算并返回值，这种情况下函数作为赋值语句的表达式使用。</li>
</ol>
<p>  Lua 编程语言函数定义格式如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3..., argumentn)</span></span></span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> result_params_comma_separated</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  optional_function_scope: 该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。</p>
<p>  function_name: 指定函数名称。</p>
<p>  argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。</p>
<p>  function_body: 函数体，函数中需要执行的代码语句块。</p>
<p>  result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span><span class="params">(num1,num2)</span></span></span><br><span class="line">	<span class="keyword">if</span>(num1 &gt; num2) <span class="keyword">then</span></span><br><span class="line">		result = num1;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		result = num2;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p>  Lua 中可以将函数作为参数传递给函数</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">myprint = <span class="function"><span class="keyword">function</span><span class="params">(param)</span></span></span><br><span class="line">	<span class="built_in">print</span>(param)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2,functionPrint)</span></span></span><br><span class="line">	result = num1 + num2</span><br><span class="line">	functionPrint(result)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myprint(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,myprint)</span><br></pre></td></tr></table></figure>
<h3 id="多返回值">多返回值</h3>
<p>  Lua函数可以返回多个结果值</p>
<p>  Lua函数中，在return后列出要返回的值的列表即可返回多值</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">local</span> mi = <span class="number">1</span></span><br><span class="line">	<span class="keyword">local</span> m = a[mi]</span><br><span class="line">	<span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">			mi = i</span><br><span class="line">			m = val</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> m,mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))</span><br></pre></td></tr></table></figure>
<h3 id="lua函数中的可变参数">Lua函数中的可变参数</h3>
<p>  Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 <code>...</code> 表示函数有可变的参数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line"><span class="keyword">local</span> s = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span></span><br><span class="line">		s = s + v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<p>  可以将可变参数赋值给一个变量。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">	result = <span class="number">0</span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">arg</span> = &#123;...&#125;</span><br><span class="line">	<span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">		result = result + v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(#<span class="built_in">arg</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result/#<span class="built_in">arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p>  也可以通过 select(&quot;#&quot;,…) 来获取可变参数的数量:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">	result = <span class="number">0</span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">arg</span> = &#123;...&#125;</span><br><span class="line">	<span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">		result = result + v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>,...))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result/<span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>,...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p>  有时候可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwrite</span><span class="params">(fmt,...)</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt,...))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fwrite(<span class="string">&quot;runoob\n&quot;</span>)</span><br><span class="line">fwrite(<span class="string">&quot;%d%d\n&quot;</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>  通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select(’#’, …) 或者 select(n, …)</p>
<ul>
<li>select(’#’, …) 返回可变参数的长度。</li>
<li>select(n, …) 用于返回从起点 n 开始到结束位置的所有参数列表。</li>
</ul>
<p>  调用 select 时，必须传入一个固定实参 selector(选择开关) 和一系列变长参数。如果 selector 为数字 n，那么 select 返回参数列表中从索引 n 开始到结束位置的所有参数列表，否则只能为字符串 #，这样 select 返回变长参数的总数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(...)</span></span></span><br><span class="line">	a = <span class="built_in">select</span>(<span class="number">3</span>,...)</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">select</span>(<span class="number">3</span>,...))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(...)</span></span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span>,<span class="built_in">select</span>(<span class="string">&#x27;#&#x27;</span>,...) <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">local</span> <span class="built_in">arg</span> = <span class="built_in">select</span>(i,...)</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;arg&quot;</span>,<span class="built_in">arg</span>)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="lua运算符">Lua运算符</h2>
<p>  运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。Lua提供了以下几种运算符类型：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>其他运算符</li>
</ul>
<h3 id="算术运算符">算术运算符</h3>
<p>  下表列出了 Lua 语言中的常用算术运算符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td>A + B 输出结果 30</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>A - B 输出结果 -10</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>A * B 输出结果 200</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>B / A 输出结果 2</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>B % A 输出结果 0</td>
</tr>
<tr>
<td>^</td>
<td>乘幂</td>
<td>A^2 输出结果 100</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-A 输出结果 -10</td>
</tr>
<tr>
<td>//</td>
<td>整除运算符(&gt;=lua5.3)</td>
<td>5//2 输出结果 2</td>
</tr>
</tbody>
</table>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">c = a - b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">c = a * b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">c = a / b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">c = a % b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">c = a ^ <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">c = -a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符">关系运算符</h3>
<p>  下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>等于，检测两个值是否相等，相等返回 true，否则返回 false</td>
<td>(A == B) 为 false。</td>
</tr>
<tr>
<td>~=</td>
<td>不等于，检测两个值是否相等，不相等返回 true，否则返回 false</td>
<td>(A ~= B) 为 true。</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于，如果左边的值大于右边的值，返回 true，否则返回 false</td>
<td>(A &gt; B) 为 false。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于，如果左边的值大于右边的值，返回 false，否则返回 true</td>
<td>(A &lt; B) 为 true。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false</td>
<td>(A &gt;= B) 返回 false。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false</td>
<td>(A &lt;= B) 返回 true。</td>
</tr>
</tbody>
</table>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;!=&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a ~= b) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;!=&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt; b) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&lt;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&gt;=&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &gt; b) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&lt;=&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt;= b) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&lt;=&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(b &gt;= a) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&gt;=&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p>  下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。</td>
<td>(A and B) 为 false。</td>
</tr>
<tr>
<td>or</td>
<td>逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。</td>
<td>(A or B) 为 true。</td>
</tr>
<tr>
<td>not</td>
<td>逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。</td>
<td>not(A and B) 为 true。</td>
</tr>
</tbody>
</table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">true</span></span><br><span class="line">b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">and</span> b) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">or</span> b) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">false</span></span><br><span class="line">b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">and</span> b) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;flase&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span>(a <span class="keyword">and</span> b)) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="其他运算符">其他运算符</h3>
<p>  下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>…</td>
<td>连接两个字符串</td>
<td>a…b ，其中 a 为 &quot;Hello &quot; ， b 为 “World”, 输出结果为 “Hello World”。</td>
</tr>
<tr>
<td>#</td>
<td>一元运算符，返回字符串或表的长度。</td>
<td>#“Hello” 返回 5</td>
</tr>
</tbody>
</table>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;hello&quot;</span></span><br><span class="line">b = <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a..b)</span><br><span class="line"><span class="built_in">print</span>(#b)</span><br><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;www.Aubyn11.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="运算符优先级">运算符优先级</h3>
<p>  从高到低的顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^</span><br><span class="line">not    - (unary)</span><br><span class="line">*      /       %</span><br><span class="line">+      -</span><br><span class="line">..</span><br><span class="line">&lt;      &gt;      &lt;=     &gt;=     ~=     ==</span><br><span class="line">and</span><br><span class="line">or</span><br></pre></td></tr></table></figure>
<p>  除了 <code>^</code> 和 <code>..</code> 外所有的二元运算符都是左连接的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a+i &lt; b/2+1          &lt;--&gt;       (a+i) &lt; ((b/2)+1)</span><br><span class="line">5+x^2*8              &lt;--&gt;       5+((x^2)*8)</span><br><span class="line">a &lt; y and y &lt;= z     &lt;--&gt;       (a &lt; y) and (y &lt;= z)</span><br><span class="line">-x^2                 &lt;--&gt;       -(x^2)</span><br><span class="line">x^y^z                &lt;--&gt;       x^(y^z)</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">15</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">e = (a + b) * c / d</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">e = ((a + b) * c) / d</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">e = (a + b) * (c / d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">e = a + (b * c) / d</span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<h2 id="lua字符串">Lua字符串</h2>
<p>  字符串或串(String)是由数字、字母、下划线组成的一串字符。</p>
<p>  在 Lua 中，字符串是一种基本的数据类型，用于存储文本数据。</p>
<p>  Lua 中的字符串可以包含任意字符，包括字母、数字、符号、空格以及其他特殊字符。</p>
<p>  Lua 语言中字符串可以使用以下三种方式来表示：</p>
<ul>
<li>单引号间的一串字符。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> str1 = <span class="string">&#x27;This is a string.&#x27;</span></span><br><span class="line"><span class="keyword">local</span> str2 = <span class="string">&quot;This is also a string.&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>双引号间的一串字符。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> str = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str = str .. <span class="string">&quot;World!&quot;</span> </span><br><span class="line"><span class="built_in">print</span>(str)</span><br></pre></td></tr></table></figure>
<ul>
<li>[[ 与 ]] 间的一串字符。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> multilineString = <span class="string">[[</span></span><br><span class="line"><span class="string">This is a multiline string.</span></span><br><span class="line"><span class="string">It can contain multiple lines of text.</span></span><br><span class="line"><span class="string">No need for escape characters.</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(multilineString)</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">&quot;Lua&quot;</span></span><br><span class="line"><span class="built_in">print</span>(string1)</span><br><span class="line"></span><br><span class="line">string2 = <span class="string">&#x27;runoob.com&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(string2)</span><br><span class="line"></span><br><span class="line">string3 = <span class="string">[[Lua]]</span></span><br><span class="line"><span class="built_in">print</span>(string3)</span><br></pre></td></tr></table></figure>
<p><strong>字符串长度计算</strong><br>
  在 Lua 中，要计算字符串的长度（即字符串中字符的个数），可以使用 <code>string.len</code> 函数，<code>string.len</code> 函数用于计算只包含 ASCII 字符串的长度。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> myString = <span class="string">&quot;Hello, runoob!&quot;</span></span><br><span class="line"><span class="keyword">local</span> length = <span class="built_in">string</span>.<span class="built_in">len</span>(myString)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(length)</span><br></pre></td></tr></table></figure>
<p>  转义字符用于表示不能直接显示的字符，比如后退键，回车键等，如在字符串转换双引号可以使用 <code>\</code>。</p>
<p>  所有的转义字符和所对应的意义：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’’’</td>
<td>092</td>
</tr>
<tr>
<td>’</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody>
</table>
<h3 id="字符串操作">字符串操作</h3>
<p>  Lua 提供了很多的方法来支持字符串的操作：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>string.upper(argument):<br/>字符串全部转为大写字母。</td>
</tr>
<tr>
<td>2</td>
<td>string.lower(argument):<br/>字符串全部转为小写字母。</td>
</tr>
<tr>
<td>3</td>
<td>string.gsub(mainString,findString,replaceString,num)<br/>在字符串中替换。<br/>mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）</td>
</tr>
<tr>
<td>4</td>
<td>string.find (str, substr, [init, [plain]])<br/>在一个指定的目标字符串 str 中搜索指定的内容 substr，如果找到了一个匹配的子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。<br/><code>init</code> 指定了搜索的起始位置，默认为 1，可以一个负数，表示从后往前数的字符个数。<br/><code>plain</code> 表示是否使用简单模式，默认为 false，true 只做简单的查找子串的操作，false 表示使用使用正则模式匹配。</td>
</tr>
<tr>
<td>5</td>
<td>string.reverse(arg)<br/>字符串反转</td>
</tr>
<tr>
<td>6</td>
<td>string.format(…)<br/>返回一个类似printf的格式化字符串</td>
</tr>
<tr>
<td>7</td>
<td>string.char(arg) 和 string.byte(arg[,int])<br/>char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。</td>
</tr>
<tr>
<td>8</td>
<td>string.len(arg)<br/>计算字符串长度。</td>
</tr>
<tr>
<td>9</td>
<td>string.rep(string, n)<br/>返回字符串string的n个拷贝</td>
</tr>
<tr>
<td>10</td>
<td>…<br/>链接两个字符串</td>
</tr>
<tr>
<td>11</td>
<td>string.gmatch(str, pattern)<br/>返回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。</td>
</tr>
<tr>
<td>12</td>
<td>string.match(str, pattern, init)<br/>string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。<br/>在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。</td>
</tr>
</tbody>
</table>
<h4 id="字符串截取">字符串截取</h4>
<p>  字符串截取使用 sub() 方法。</p>
<p>  string.sub() 用于截取字符串，原型为：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">sub</span>(s, i [, j])</span><br></pre></td></tr></table></figure>
<p>  参数说明：</p>
<ul>
<li>s：要截取的字符串。</li>
<li>i：截取开始位置。</li>
<li>j：截取结束位置，默认为 -1，最后一个字符。</li>
</ul>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> sourcestr = <span class="string">&quot;prefix--runoobgoogletaobao--suffix&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,sourcestr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> f_sub = <span class="built_in">string</span>.<span class="built_in">sub</span>(sourcestr,<span class="number">4</span>,<span class="number">15</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,f_sub))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> s_sub = <span class="built_in">string</span>.<span class="built_in">sub</span>(sourcestr,<span class="number">1</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,s_sub))</span><br><span class="line"></span><br><span class="line">//获取最后<span class="number">10</span>个字符</span><br><span class="line"><span class="keyword">local</span> t_sub = <span class="built_in">string</span>.<span class="built_in">sub</span>(sourcestr,<span class="number">-10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,t_sub))</span><br><span class="line"></span><br><span class="line">//索引越界，输出原字符串</span><br><span class="line"><span class="keyword">local</span> fo_sub = <span class="built_in">string</span>.<span class="built_in">sub</span>(sourcestr,<span class="number">-100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>,fo_sub))</span><br></pre></td></tr></table></figure>
<h4 id="字符串大小写转换">字符串大小写转换</h4>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">&quot;Lua&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(string1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">lower</span>(string1))</span><br></pre></td></tr></table></figure>
<h4 id="字符串查找与反转">字符串查找与反转</h4>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> = <span class="string">&quot;Lua Tutorial&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(<span class="built_in">string</span>,<span class="string">&quot;Tutorial&quot;</span>))</span><br><span class="line">reversedString = <span class="built_in">string</span>.<span class="built_in">reverse</span>(<span class="built_in">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(reversedString)</span><br></pre></td></tr></table></figure>
<h3 id="字符串格式化">字符串格式化</h3>
<p>  Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。</p>
<p>  由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf()。</p>
<p>  以下实例演示了如何对字符串进行格式化操作：</p>
<p>  格式字符串可能包含以下的转义码:</p>
<ul>
<li>%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符</li>
<li>%d, %i - 接受一个数字并将其转化为有符号的整数格式</li>
<li>%o - 接受一个数字并将其转化为八进制数格式</li>
<li>%u - 接受一个数字并将其转化为无符号整数格式</li>
<li>%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母</li>
<li>%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母</li>
<li>%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e</li>
<li>%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E</li>
<li>%f - 接受一个数字并将其转化为浮点数格式</li>
<li>%g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式</li>
<li>%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式</li>
<li>%s - 接受一个字符串并按照给定的参数格式化该字符串</li>
</ul>
<p>  为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:</p>
<ul>
<li>符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.</li>
<li>占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.</li>
<li>对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.</li>
<li>宽度数值</li>
<li>小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.</li>
</ul>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">&quot;Lua&quot;</span></span><br><span class="line">string2 = <span class="string">&quot;Tutorial&quot;</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;基本格式化 %s %s&quot;</span>,string1,string2))</span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> = <span class="number">2</span></span><br><span class="line">month = <span class="number">1</span></span><br><span class="line">year = <span class="number">2014</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;日期格式化 %02d/%02d/%04d&quot;</span>,<span class="built_in">date</span>,month,year))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%.4f&quot;</span>,<span class="number">1</span>/<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>其他案例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%c&quot;</span>, <span class="number">83</span>)                 <span class="comment">-- 输出S</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%+d&quot;</span>, <span class="number">17.0</span>)              <span class="comment">-- 输出+17</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%05d&quot;</span>, <span class="number">17</span>)               <span class="comment">-- 输出00017</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%o&quot;</span>, <span class="number">17</span>)                 <span class="comment">-- 输出21</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%u&quot;</span>, <span class="number">3.14</span>)               <span class="comment">-- 输出3</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%x&quot;</span>, <span class="number">13</span>)                 <span class="comment">-- 输出d</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">13</span>)                 <span class="comment">-- 输出D</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%e&quot;</span>, <span class="number">1000</span>)               <span class="comment">-- 输出1.000000e+03</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%E&quot;</span>, <span class="number">1000</span>)               <span class="comment">-- 输出1.000000E+03</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%6.3f&quot;</span>, <span class="number">13</span>)              <span class="comment">-- 输出13.000</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%q&quot;</span>, <span class="string">&quot;One\nTwo&quot;</span>)         <span class="comment">-- 输出&quot;One\</span></span><br><span class="line">                                        <span class="comment">-- 　　Two&quot;</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;monkey&quot;</span>)           <span class="comment">-- 输出monkey</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%10s&quot;</span>, <span class="string">&quot;monkey&quot;</span>)         <span class="comment">-- 输出    monkey</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%5.3s&quot;</span>, <span class="string">&quot;monkey&quot;</span>)        <span class="comment">-- 输出  mon</span></span><br></pre></td></tr></table></figure>
<h3 id="字符与整数相互转换">字符与整数相互转换</h3>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">-1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">-2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">97</span>))</span><br></pre></td></tr></table></figure>
<h3 id="其他常用函数">其他常用函数</h3>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">&quot;www.&quot;</span></span><br><span class="line">string2 = <span class="string">&quot;Aubyn&quot;</span></span><br><span class="line">string3 = <span class="string">&quot;.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(string1..string2..string3)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">len</span>(string2))</span><br><span class="line"></span><br><span class="line">repeatedString = <span class="built_in">string</span>.<span class="built_in">rep</span>(string2,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(repeatedString)</span><br></pre></td></tr></table></figure>
<h3 id="匹配模式">匹配模式</h3>
<p>  Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。</p>
<p>  你还可以在模式串中使用字符类。</p>
<p>  字符类指可以匹配一个特定字符集合内任何字符的模式项。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;Deadline is 30/05/1999,firm&quot;</span></span><br><span class="line"><span class="built_in">date</span> = <span class="string">&quot;%d%d/%d%d/%d%d%d%d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(s,<span class="built_in">string</span>.<span class="built_in">find</span>(s,<span class="built_in">date</span>)))</span><br></pre></td></tr></table></figure>
<p>  下面的表列出了Lua支持的所有字符类：</p>
<p>  单个字符(除 ^$()%.[]*±? 外): 与该字符自身配对</p>
<ul>
<li>.(点): 与任何字符配对</li>
<li>%a: 与任何字母配对</li>
<li>%c: 与任何控制符配对(例如\n)</li>
<li>%d: 与任何数字配对</li>
<li>%l: 与任何小写字母配对</li>
<li>%p: 与任何标点(punctuation)配对</li>
<li>%s: 与空白字符配对</li>
<li>%u: 与任何大写字母配对</li>
<li>%w: 与任何字母/数字配对</li>
<li>%x: 与任何十六进制数配对</li>
<li>%z: 与任何代表0的字符配对</li>
<li>%x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*±?)的配对问题, 例如%%与%配对</li>
<li>[数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对</li>
<li>[^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对</li>
</ul>
<p>  当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，’%A’非字母的字符:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;hello,up-down!&quot;</span>,<span class="string">&quot;%A&quot;</span>,<span class="string">&quot;.&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>  数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。</p>
<p>  在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">( ) . % + - * ? [ ^ $</span><br></pre></td></tr></table></figure>
<p>  ‘%’ 用作特殊字符的转义字符，因此 ‘%.’ 匹配点；’%%’ 匹配字符 ‘%’。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。</p>
<p>  模式条目可以是:</p>
<ul>
<li>单个字符类匹配该类别中任意单个字符；</li>
<li>单个字符类跟一个 ‘*’， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；</li>
<li>单个字符类跟一个 ‘+’， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；</li>
<li>单个字符类跟一个 ‘-’， 将匹配零或更多个该类的字符。 和 ‘*’ 不同， 这个条目总是匹配尽可能短的串；</li>
<li>单个字符类跟一个 ‘?’， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；</li>
<li>%n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。</li>
<li>%bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。</li>
<li>%f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 ‘\0’ 一样。</li>
</ul>
<p>  模式：</p>
<p>  模式 指一个模式条目的序列。 在模式最前面加上符号 ‘^’ 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 ‘<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;^&#039; at position 24: …锚定到字符串的结尾。 如果 &#039;^̲&#039; 和 &#039;'>&#039; 将使匹配过程锚定到字符串的结尾。 如果 &#039;^&#039; 和 &#039;</span>’ 出现在其它位置，它们均没有特殊含义，只表示自身。</p>
<p>  捕获：</p>
<p>  模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 “(a*(.)%w(%s*))” ， 字符串中匹配到 “a*(.)%w(%s*)” 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 “.” 匹配到的字符是 2 号捕获物， 匹配到 “%s*” 的那部分是 3 号。</p>
<p>  作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 “()aa()” 作用到字符串 “flaaap” 上，将产生两个捕获物： 3 和 5 。</p>
<h2 id="lua数组">Lua数组</h2>
<p>  数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。</p>
<p>  在 Lua 中，数组不是一种特定的数据类型，而是一种用来存储一组值的数据结构。</p>
<p>  实际上，Lua 中并没有专门的数组类型，而是使用一种被称为 “table” 的数据结构来实现数组的功能。</p>
<p>  Lua 数组的索引键值可以使用整数表示，数组的大小不是固定的。</p>
<p>  在 Lua 索引值是以 1 为起始，但也可以指定 0 开始。</p>
<h3 id="一维数组">一维数组</h3>
<p>  一维数组是最简单的数组，其逻辑结构是线性表。</p>
<p>  使用索引访问数组元素：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> myArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myArray[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(myArray[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>  要计算数组的长度（即数组中元素的个数），可以使用 <code>#</code> 操作符：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> myArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="keyword">local</span> length = #myArray</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(length)</span><br></pre></td></tr></table></figure>
<p>  一维数组可以用 for 循环出数组中的元素，如下实例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> myArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,#myArray <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  lua 索引默认从 <code>1</code> 开始：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Lua&quot;</span>,<span class="string">&quot;Tutorial&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  可以使用整数索引来访问数组元素，如果指定的索引没有值则返回 nil。</p>
<p>  还可以以负数为数组索引值：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">-2</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">	array[i] = i * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">-2</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  也可以修改数组中元素：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> myArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,#myArray <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  也可以向数组中添加元素：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> myArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">myArray[#myArray + <span class="number">1</span>] = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,#myArray <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  也可以删除数组中元素：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> myArray = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(myArray,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,#myArray <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="多维数组">多维数组</h3>
<p>  多维数组即数组中包含数组或一维数组的索引键对应一个数组。</p>
<p>  以下是一个三行三列的阵列多维数组：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">	array[i] = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">		array[i][j] = i*j</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">print</span>(array[i][j])</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  不同索引键的三行三列阵列多维数组：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line">maxRows = <span class="number">3</span></span><br><span class="line">maxColumns = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row = <span class="number">1</span>,maxRows <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> col = <span class="number">1</span>,maxColumns <span class="keyword">do</span></span><br><span class="line">		array[row * maxColumns + col] = row * col</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row = <span class="number">1</span>,maxRows <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> col = <span class="number">1</span>,maxColumns <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">print</span>(array[row * maxColumns + col])</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  数组设定了指定的索引值，这样可以避免出现 nil 值，有利于节省内存空间。</p>
<h2 id="lua迭代器">Lua迭代器</h2>
<p>  迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。</p>
<p>  在 Lua 中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。</p>
<h3 id="泛型for迭代器">泛型for迭代器</h3>
<p>  泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。</p>
<p>  泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  上面代码中，k, v为变量列表；pairs(t)为表达式列表。</p>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Google&quot;</span>,<span class="string">&quot;Runoob&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(array) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(key,value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  ipairs与pairs的区别，ipairs的时候遍历到第一个nil就会终止，pairs会直接遍历到最后</p>
<p>  泛型 for 的执行过程：</p>
<ul>
<li>首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。</li>
<li>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</li>
<li>第三，将迭代函数返回的值赋给变量列表。</li>
<li>第四，如果返回的第一个值为nil循环结束，否则执行循环体。</li>
<li>第五，回到第二步再次调用迭代函数</li>
</ul>
<p>  在Lua中常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型：</p>
<ul>
<li>无状态的迭代器</li>
<li>多状态的迭代器</li>
</ul>
<h4 id="无状态的迭代器">无状态的迭代器</h4>
<p>  无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p>
<p>  每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。</p>
<p>  这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素，元素的索引需要是数值。</p>
<p>  数字 n 的平方：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(iteratorMaxCount,currentNumber)</span></span></span><br><span class="line">   <span class="keyword">if</span> currentNumber &lt; iteratorMaxCount <span class="keyword">then</span></span><br><span class="line">      currentNumber = currentNumber+<span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> currentNumber, currentNumber*currentNumber</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,n <span class="keyword">in</span> square,<span class="number">3</span>,<span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(i,n)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs 和迭代函数都很简单，在 Lua 中可以这样实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iter</span> <span class="params">(a, i)</span></span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">local</span> v = a[i]</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line">       <span class="keyword">return</span> i, v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> iter, a, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；然后 Lua 调用 iter(a,0) 返回 1, a[1]（除非 a[1]=nil）；第二次迭代调用 iter(a,1) 返回 2, a[2]……直到第一个 nil 元素。</p>
<h4 id="多状态的迭代器">多状态的迭代器</h4>
<p>  很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elementIterator</span> <span class="params">(collection)</span></span></span><br><span class="line">   <span class="keyword">local</span> index = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> count = #collection</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">      index = index + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> index &lt;= count</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">         <span class="keyword">return</span> collection[index]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elementIterator(array)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="表">表</h2>
<p>  table 是 Lua 的一种数据结构用来帮助创建不同的数据类型，如：数组、字典等。</p>
<p>  Lua table 使用关联型数组，可以用任意类型的值来作数组的索引，但这个值不能是 nil。</p>
<p>  Lua table 是不固定大小的，可以根据自己需要进行扩容。</p>
<p>  Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用&quot;format&quot;来索引table string。</p>
<h3 id="table-表-的构造">table（表）的构造</h3>
<p>  构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = &#123;&#125;</span><br><span class="line">mytable[<span class="number">1</span>] = <span class="string">&quot;Lua&quot;</span></span><br><span class="line">mytable = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>  当为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。</p>
<p>  以下实例演示了以上的描述情况：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mytable 的类型是 &quot;</span>,<span class="built_in">type</span>(mytable))</span><br><span class="line"></span><br><span class="line">mytable[<span class="number">1</span>]= <span class="string">&quot;Lua&quot;</span></span><br><span class="line">mytable[<span class="string">&quot;wow&quot;</span>] = <span class="string">&quot;修改前&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mytable 索引为 1 的元素是 &quot;</span>, mytable[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mytable 索引为 wow 的元素是 &quot;</span>, mytable[<span class="string">&quot;wow&quot;</span>])</span><br><span class="line"></span><br><span class="line">alternatetable = mytable</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;alternatetable 索引为 1 的元素是 &quot;</span>, alternatetable[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;alternatetable 索引为 wow 的元素是 &quot;</span>, alternatetable[<span class="string">&quot;wow&quot;</span>])</span><br><span class="line"></span><br><span class="line">alternatetable[<span class="string">&quot;wow&quot;</span>] = <span class="string">&quot;修改后&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mytable 索引为 wow 的元素是 &quot;</span>, mytable[<span class="string">&quot;wow&quot;</span>])</span><br><span class="line"></span><br><span class="line">alternatetable = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;alternatetable 是 &quot;</span>, alternatetable)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mytable 索引为 wow 的元素是 &quot;</span>, mytable[<span class="string">&quot;wow&quot;</span>])</span><br><span class="line"></span><br><span class="line">mytable = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mytable 是 &quot;</span>, mytable)</span><br></pre></td></tr></table></figure>
<h3 id="table操作">Table操作</h3>
<p>  以下列出了 Table 操作常用的方法：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>table.concat (table [, sep [, start [, end]]]):<br/>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td>
</tr>
<tr>
<td>2</td>
<td>table.insert (table, [pos,] value):<br/>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td>
</tr>
<tr>
<td>3</td>
<td>table.maxn (table)<br/>指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现)</td>
</tr>
<tr>
<td>4</td>
<td>table.remove (table [, pos])<br/>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td>
</tr>
<tr>
<td>5</td>
<td>table.sort (table [, comp])<br/>对给定的table进行升序排序。</td>
</tr>
</tbody>
</table>
<h4 id="table连接">Table连接</h4>
<p>  可以使用 concat() 输出一个列表中元素连接成的字符串:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fruits = &#123;<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;apple&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;连接后的字符串 &quot;</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;连接后的字符串 &quot;</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits,<span class="string">&quot;, &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;连接后的字符串 &quot;</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits,<span class="string">&quot;, &quot;</span>, <span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h4 id="插入和移除">插入和移除</h4>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fruits = &#123;<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;apple&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(fruits,<span class="string">&quot;mango&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;索引为 4 的元素为 &quot;</span>,fruits[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(fruits,<span class="number">2</span>,<span class="string">&quot;grapes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;索引为 2 的元素为 &quot;</span>,fruits[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最后一个元素为 &quot;</span>,fruits[<span class="number">5</span>])</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(fruits)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除后最后一个元素为 &quot;</span>,fruits[<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<h4 id="table排序">Table排序</h4>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fruits = &#123;<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;grapes&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(fruits) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(fruits)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(fruits) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="table最大值">Table最大值</h4>
<p>  table.maxn 在 Lua5.2 之后该方法已经不存在了，定义 table_maxn 方法来实现。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_maxn</span><span class="params">(t)</span></span></span><br><span class="line">  <span class="keyword">local</span> mn=<span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span>(mn==<span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">      mn=v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> mn &lt; v <span class="keyword">then</span></span><br><span class="line">      mn = v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> mn</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">tbl = &#123;[<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">6</span>, [<span class="number">3</span>] = <span class="number">34</span>, [<span class="number">26</span>] =<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tbl 最大值：&quot;</span>, table_maxn(tbl))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tbl 长度 &quot;</span>, #tbl)</span><br></pre></td></tr></table></figure>
<p>  注意：</p>
<p>  当获取 table 的长度的时候无论是使用 # 还是 table.getn 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。</p>
<p>  可以使用以下方法来代替：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_leng</span><span class="params">(t)</span></span></span><br><span class="line">  <span class="keyword">local</span> leng=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    leng=leng+<span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> leng;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="lua模块与包">Lua模块与包</h2>
<p>  模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p>
<p>  Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。以下为创建自定义模块 module.lua，文件代码格式如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.constant = <span class="string">&quot;这是一个常量&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;这是一个共有函数\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;这是一个私有函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">	func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>
<p>  由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。</p>
<p>  上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.</p>
<h3 id="require函数">require函数</h3>
<p>  Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;&lt;模块名&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">&quot;&lt;模块名&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>  执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> (<span class="string">&quot;12_1-module&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">module</span>.constant)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.func3()</span><br></pre></td></tr></table></figure>
<p>  或者给加载的模块定义一个别名变量，方便调用：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">&quot;12_1-module&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m.constant)</span><br><span class="line"></span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure>
<h4 id="加载机制">加载机制</h4>
<p>  对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。</p>
<p>  require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。</p>
<p>  当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 “~/lua/” 路径加入 LUA_PATH 环境变量里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#LUA_PATH</span><br><span class="line">export LUA_PATH=&quot;~/lua/?.lua;;&quot;</span><br></pre></td></tr></table></figure>
<p>  文件路径以 “;” 号分隔，最后的 2 个 “;;” 表示新加的路径后面加上原来的默认路径。</p>
<p>  接着，更新环境变量参数，使之立即生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure>
<p>  这时假设 package.path 的值是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Users/dengjoe/lua/?.lua;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua</span><br></pre></td></tr></table></figure>
<p>  那么调用 require(“module”) 时就会尝试打开以下文件目录去搜索目标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Users/dengjoe/lua/module.lua;</span><br><span class="line">./module.lua</span><br><span class="line">/usr/local/share/lua/5.1/module.lua</span><br><span class="line">/usr/local/share/lua/5.1/module/init.lua</span><br><span class="line">/usr/local/lib/lua/5.1/module.lua</span><br><span class="line">/usr/local/lib/lua/5.1/module/init.lua</span><br></pre></td></tr></table></figure>
<p>  如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。</p>
<p>  搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。</p>
<p>  搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。</p>
<h3 id="c包">C包</h3>
<p>  Lua和C是很容易结合的，使用 C 为 Lua 写包。</p>
<p>  与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。</p>
<p>  Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>  loadlib 函数加载指定的库并且连接到 Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为 Lua 的一个函数，这样就可以直接在Lua中调用他。</p>
<p>  如果加载动态库或者查找初始化函数时出错，loadlib 将返回 nil 和错误信息。我们可以修改前面一段代码，使其检测错误然后调用初始化函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span></span><br><span class="line"><span class="comment">-- 或者 path = &quot;C:\\windows\\luasocket.dll&quot;，这是 Window 平台下</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>))</span><br><span class="line">f()  <span class="comment">-- 真正打开库</span></span><br></pre></td></tr></table></figure>
<p>  一般情况下期望二进制的发布库包含一个与前面代码段相似的 stub 文件，安装二进制库的时候可以随便放在某个目录，只需要修改 stub 文件对应二进制库的实际路径即可。</p>
<p>  将 stub 文件所在的目录加入到 LUA_PATH，这样设定后就可以使用 require 函数加载 C 库了。</p>
<h2 id="lua元表-metatable">Lua元表(Metatable)</h2>
<p>  在 Lua table 中可以访问对应的 key 来得到 value 值，但是却无法对两个 table 进行操作(比如相加)。</p>
<p>  因此 Lua 提供了元表(Metatable)，允许改变 table 的行为，每个行为关联了对应的元方法。</p>
<p>  例如，使用元表可以定义 Lua 如何计算两个 table 的相加操作 a+b。</p>
<p>  当 Lua 试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫 __add 的字段，若找到，则调用对应的值。 __add 等即时字段，其对应的值（往往是一个函数或是 table）就是&quot;元方法&quot;。</p>
<p>  有两个很重要的函数来处理元表：</p>
<ul>
<li>setmetatable(table,metatable): 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。</li>
<li>getmetatable(table): 返回对象的元表(metatable)。</li>
</ul>
<p>  以下实例演示了如何对指定的表设置元表：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = &#123;&#125;</span><br><span class="line">mymetatable = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(mytable,mymetatable)</span><br></pre></td></tr></table></figure>
<p>  以上代码也可以直接写成一行：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;&#125;,&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>  以下为返回对象元表：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getmetatable</span>(mytable) </span><br></pre></td></tr></table></figure>
<h3 id="index元方法">__index元方法</h3>
<p>  这是 metatable 最常用的键。</p>
<p>  当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键。</p>
<p>  可以在使用 lua 命令进入交互模式查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua</span><br><span class="line">Lua 5.3.0  Copyright (C) 1994-2015 Lua.org, PUC-Rio</span><br><span class="line">&gt; other = &#123; foo = 3 &#125;</span><br><span class="line">&gt; t = setmetatable(&#123;&#125;, &#123; __index = other &#125;)</span><br><span class="line">&gt; t.foo</span><br><span class="line">3</span><br><span class="line">&gt; t.bar</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>  如果__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。</p>
<p>  __index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">&quot;value1&quot;</span>&#125;, &#123;</span><br><span class="line">  <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable, key)</span></span></span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">&quot;key2&quot;</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;metatablevalue&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>
<p>  实例解析：</p>
<ul>
<li>mytable 表赋值为 {key1 = “value1”}。</li>
<li>mytable 设置了元表，元方法为 __index。</li>
<li>在mytable表中查找 key1，如果找到，返回该元素，找不到则继续。</li>
<li>在mytable表中查找 key2，如果找到，返回 metatablevalue，找不到则继续。</li>
<li>判断元表有没有__index方法，如果__index方法是一个函数，则调用该函数。</li>
<li>元方法中查看是否传入 “key2” 键的参数（mytable.key2已设置），如果传入 “key2” 参数返回 “metatablevalue”，否则返回 mytable 对应的键值。</li>
</ul>
<p>  我们可以将以上代码简单写成：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">&quot;value1&quot;</span>&#125;, &#123; <span class="built_in">__index</span> = &#123; key2 = <span class="string">&quot;metatablevalue&quot;</span> &#125; &#125;)</span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>
<p>  总结<br>
  Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:</p>
<ol>
<li>在表中查找，如果找到，返回该元素，找不到则继续</li>
<li>判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。</li>
<li>判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。</li>
</ol>
<h3 id="newindex元方法">__newindex元方法</h3>
<p>  __newindex 元方法用来对表更新，__index则用来对表访问 。</p>
<p>  当给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。</p>
<p>  以下实例演示了 __newindex 元方法的应用：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mymetatable = &#123;&#125;</span><br><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">&quot;value1&quot;</span>&#125;, &#123; <span class="built_in">__newindex</span> = mymetatable &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable.key1)</span><br><span class="line"></span><br><span class="line">mytable.newkey = <span class="string">&quot;新值2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mytable.newkey,mymetatable.newkey)</span><br><span class="line"></span><br><span class="line">mytable.key1 = <span class="string">&quot;新值1&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mymetatable.key1)</span><br></pre></td></tr></table></figure>
<p>  以上实例中表设置了元方法 __newindex，在对新索引键（newkey）赋值时（mytable.newkey = “新值2”），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。</p>
<p>  以下实例使用了 rawset 函数来更新表：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">&quot;value1&quot;</span>&#125;, &#123;</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable, key, value)</span></span></span><br><span class="line">        <span class="built_in">rawset</span>(mytable, key, <span class="string">&quot;\&quot;&quot;</span>..value..<span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mytable.key1 = <span class="string">&quot;new value&quot;</span></span><br><span class="line">mytable.key2 = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>
<p>  rawset 是 Lua 中的一个函数，用于直接设置表中的键值，而不触发元表中的任何元方法。</p>
<p>  这个函数接受三个参数：表、键和值。它的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rawset(table, key, value)</span><br></pre></td></tr></table></figure>
<p>  其中：</p>
<ul>
<li>table 是要设置键值的表。</li>
<li>key 是要设置的键。</li>
<li>value 是要设置的值。</li>
</ul>
<p>  rawset 不会触发任何元表中的 __newindex 元方法。这意味着，即使表设置了元表，也不会执行元表中的任何对应方法。通常情况下，rawset 用于直接对表进行赋值，而不考虑元表中的影响。</p>
<h3 id="为表添加操作符">为表添加操作符</h3>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_maxn</span><span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> mn = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> mn &lt; k <span class="keyword">then</span></span><br><span class="line">            mn = k</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> mn</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123;</span><br><span class="line">  <span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable, newtable)</span></span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, table_maxn(newtable) <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">table</span>.<span class="built_in">insert</span>(mytable, table_maxn(mytable)+<span class="number">1</span>,newtable[i])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> mytable</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">secondtable = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">mytable = mytable + secondtable</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(mytable) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  __add 键包含在元表中，并进行相加操作。 表中对应的操作列表如下：(注意：__是两个下划线)</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__add</td>
<td>对应的运算符 ‘+’.</td>
</tr>
<tr>
<td>__sub</td>
<td>对应的运算符 ‘-’.</td>
</tr>
<tr>
<td>__mul</td>
<td>对应的运算符 ‘*’.</td>
</tr>
<tr>
<td>__div</td>
<td>对应的运算符 ‘/’.</td>
</tr>
<tr>
<td>__mod</td>
<td>对应的运算符 ‘%’.</td>
</tr>
<tr>
<td>__unm</td>
<td>对应的运算符 ‘-’.</td>
</tr>
<tr>
<td>__concat</td>
<td>对应的运算符 ‘…’.</td>
</tr>
<tr>
<td>__eq</td>
<td>对应的运算符 ‘==’.</td>
</tr>
<tr>
<td>__lt</td>
<td>对应的运算符 ‘&lt;’.</td>
</tr>
<tr>
<td>__le</td>
<td>对应的运算符 ‘&lt;=’.</td>
</tr>
</tbody>
</table>
<h3 id="call元方法">__Call元方法</h3>
<p>  __call 元方法在 Lua 调用一个值时调用。以下实例演示了计算表中元素的和：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_maxn</span><span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> mn = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> mn &lt; k <span class="keyword">then</span></span><br><span class="line">            mn = k</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> mn</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;<span class="number">10</span>&#125;, &#123;</span><br><span class="line">  <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable, newtable)</span></span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, table_maxn(mytable) <span class="keyword">do</span></span><br><span class="line">			sum = sum + mytable[i]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span>, table_maxn(newtable) <span class="keyword">do</span></span><br><span class="line">			sum = sum + newtable[i]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line">newtable = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(mytable(newtable))</span><br></pre></td></tr></table></figure>
<h3 id="tostring元方法">__tostring元方法</h3>
<p>  __tostring 元方法用于修改表的输出行为。以下实例自定义了表的输出内容：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> &#125;, &#123;</span><br><span class="line">  <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable)</span></span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(mytable) <span class="keyword">do</span></span><br><span class="line">                sum = sum + v</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;表所有元素的和为 &quot;</span> .. sum</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(mytable)</span><br></pre></td></tr></table></figure>
<h2 id="协同程序">协同程序</h2>
<h3 id="什么是协同">什么是协同</h3>
<p>  Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。</p>
<p>  协同程序可以理解为一种特殊的线程，可以暂停和恢复其执行，从而允许非抢占式的多任务处理。</p>
<p>  协同是非常强大的功能，但是用起来也很复杂。</p>
<h3 id="基本语法">基本语法</h3>
<p>  同程序由 coroutine 模块提供支持。</p>
<p>  使用协同程序，可以在函数中使用 coroutine.create 创建一个新的协同程序对象，并使用 coroutine.resume 启动它的执行。协同程序可以通过调用 coroutine.yield 来主动暂停自己的执行，并将控制权交还给调用者。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>coroutine.create()</td>
<td>创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用</td>
</tr>
<tr>
<td>coroutine.resume()</td>
<td>重启 coroutine，和 create 配合使用</td>
</tr>
<tr>
<td>coroutine.yield()</td>
<td>挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果</td>
</tr>
<tr>
<td>coroutine.status()</td>
<td>查看 coroutine 的状态<br/>注：coroutine 的状态有三种：dead，suspended，running，具体什么时候有这样的状态请参考下面的程序</td>
</tr>
<tr>
<td>coroutine.wrap()</td>
<td>创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复</td>
</tr>
<tr>
<td>coroutine.running()</td>
<td>返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 coroutine 的线程号</td>
</tr>
</tbody>
</table>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;协同程序foo开始执行&quot;</span>)</span><br><span class="line">	<span class="keyword">local</span> value = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="string">&quot;暂停foo的执行&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;协同程序foo恢复执行，传入的值为：&quot;</span> .. <span class="built_in">tostring</span>(value))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;协同程序foo结束执行&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(foo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">status</span>,result = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="built_in">status</span>,result = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="number">42</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>  以上实例中，定义了一个名为 foo 的函数作为协同程序。在函数中，我们使用 coroutine.yield 暂停了协同程序的执行，并返回了一个值</p>
<p>  在主程序中，使用 coroutine.create 创建了一个协同程序对象，并使用 coroutine.resume 启动了它的执行。</p>
<p>  在第一次调用 coroutine.resume 后，协同程序执行到 coroutine.yield 处暂停，并将值返回给主程序。然后，我们再次调用 coroutine.resume，并传入一个值作为协同程序恢复执行时的参数。</p>
<p>  需要注意的是，协同程序的状态可以通过 coroutine.status 函数获取，通过检查状态可以确定协同程序的执行情况（如运行中、已挂起、已结束等）。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建了一个新的协同程序对象 co，其中协同程序函数打印传入的参数 i</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 使用 coroutine.resume 启动协同程序 co 的执行，并传入参数 1。协同程序开始执行，打印输出为 1</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>)   <span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 coroutine.status 检查协同程序 co 的状态，输出为 dead，表示协同程序已经执行完毕</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))  <span class="comment">-- dead</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 coroutine.wrap 创建了一个协同程序包装器，将协同程序函数转换为一个可直接调用的函数对象</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">co(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line"><span class="comment">-- 创建了另一个协同程序对象 co2，其中的协同程序函数通过循环打印数字 1 到 10，在循环到 3 的时候输出当前协同程序的状态和正在运行的线程</span></span><br><span class="line">co2 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co2))  <span class="comment">--running</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">running</span>()) <span class="comment">--thread:XXXXXX</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连续调用 coroutine.resume 启动协同程序 co2 的执行</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co2) <span class="comment">--1</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co2) <span class="comment">--2</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co2) <span class="comment">--3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 coroutine.status 检查协同程序 co2 的状态，输出为 suspended，表示协同程序暂停执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co2))   <span class="comment">-- suspended</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">running</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>  coroutine.running就可以看出来,coroutine在底层实现就是一个线程。</p>
<p>  当create一个coroutine的时候就是在新线程中注册了一个事件。</p>
<p>  当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。</p>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a)</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;foo 函数输出&quot;</span>,a)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="number">2</span> * a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;第一次协同程序输出&quot;</span>,a,b)</span><br><span class="line">	<span class="keyword">local</span> r = foo(a + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;第二次协同程序输出&quot;</span>,r)</span><br><span class="line">	<span class="keyword">local</span> r,s = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a + b,a - b)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;第三次协同程序输出&quot;</span>,r,s)</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">10</span>)) <span class="comment">-- true, 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--分割线----&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;r&quot;</span>)) <span class="comment">-- true 11 -9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)) <span class="comment">-- true 10 end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)) <span class="comment">-- cannot resume dead coroutine</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>  以上实例接下如下：</p>
<ul>
<li>调用resume，将协同程序唤醒,resume操作成功返回true，否则返回false；</li>
<li>协同程序运行；</li>
<li>运行到yield语句；</li>
<li>yield挂起协同程序，第一次resume返回；（注意：此处yield返回，参数是resume的参数）</li>
<li>第二次resume，再次唤醒协同程序；（注意：此处resume的参数中，除了第一个参数，剩下的参数将作为yield的参数）</li>
<li>yield返回；</li>
<li>协同程序继续运行；</li>
<li>如果使用的协同程序继续运行完成后继续调用 resume方法则输出：cannot resume dead coroutine</li>
</ul>
<p>  resume和yield的配合强大之处在于，resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。</p>
<h3 id="生产者-消费者问题">生产者-消费者问题</h3>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> newProductor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">productor</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">		send(i)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">local</span> i = receive()</span><br><span class="line">		<span class="built_in">print</span>(i)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> <span class="built_in">status</span>,value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(newProductor)</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></span><br><span class="line">	<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">newProductor = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(productor)</span><br><span class="line">consumer()</span><br></pre></td></tr></table></figure>
<h3 id="线程和协同程序区别">线程和协同程序区别</h3>
<p>  线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。</p>
<p>  在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
<p>  协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p>
<p>  主要区别归纳如下：</p>
<ul>
<li>调度方式：线程通常由操作系统的调度器进行抢占式调度，操作系统会在不同线程之间切换执行权。而协同程序是非抢占式调度的，它们由程序员显式地控制执行权的转移。</li>
<li>并发性：线程是并发执行的，多个线程可以同时运行在多个处理器核心上，或者通过时间片轮转在单个核心上切换执行。协同程序则是协作式的，只有一个协同程序处于运行状态，其他协同程序必须等待当前协同程序主动放弃执行权。</li>
<li>内存占用：线程通常需要独立的堆栈和上下文环境，因此线程的创建和销毁会带来额外的开销。而协同程序可以共享相同的堆栈和上下文，因此创建和销毁协同程序的开销较小。</li>
<li>数据共享：线程之间可以共享内存空间，但需要注意线程安全性和同步问题。协同程序通常通过参数传递和返回值来进行数据共享，不同协同程序之间的数据隔离性较好。</li>
<li>调试和错误处理：线程通常在调试和错误处理方面更复杂，因为多个线程之间的交互和并发执行可能导致难以调试的问题。协同程序则在调试和错误处理方面相对简单，因为它们是由程序员显式地控制执行流程的。</li>
</ul>
<p>  总体而言，线程适用于需要并发执行的场景，例如在多核处理器上利用并行性加快任务的执行速度。而协同程序适用于需要协作和协调的场景，例如状态机、事件驱动编程或协作式任务处理。选择使用线程还是协同程序取决于具体的应用需求和编程模型。</p>
<h2 id="lua文件i-o">Lua文件I/O</h2>
<p>  Lua I/O 库用于读取和处理文件。分为简单模式（和C一样）、完全模式。</p>
<ul>
<li>简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。</li>
<li>完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法</li>
</ul>
<p>  简单模式在做一些简单的文件操作时较为合适。但是在进行一些高级的文件操作的时候，简单模式就显得力不从心。例如同时读取多个文件这样的操作，使用完全模式则较为合适。</p>
<p>  打开文件操作语句如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(filename,[,mode])</span><br></pre></td></tr></table></figure>
<p>  mode 的值有：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</td>
</tr>
<tr>
<td>r+</td>
<td>以可读写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td>a+</td>
<td>与a类似，但此文件可读可写</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式，如果文件是二进制文件，可以加上b</td>
</tr>
<tr>
<td>+</td>
<td>号表示对文件既可以读也可以写</td>
</tr>
</tbody>
</table>
<h3 id="简单模式">简单模式</h3>
<p>  简单模式使用标准的 I/O 或使用一个当前输入文件和一个当前输出文件。</p>
<p>  以下为 file.lua 文件代码，操作的文件为test.lua(如果没有你需要创建该文件)，代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;15_2-test.lua&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>(file)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">read</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">close</span>(file)</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;15_2-test.lua&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">output</span>(file)</span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;-- test.lua 文件末尾注释&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">close</span>(file)</span><br></pre></td></tr></table></figure>
<p>  在以上实例中使用了 io.“x” 方法，其中 io.read() 中没有带参数，参数可以是下表中的一个：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>“*n”</td>
<td>读取一个数字并返回它。例：file.read(&quot;*n&quot;)</td>
</tr>
<tr>
<td>“*a”</td>
<td>从当前位置读取整个文件。例：file.read(&quot;*a&quot;)</td>
</tr>
<tr>
<td>“*l”（默认）</td>
<td>读取下一行，在文件尾 (EOF) 处返回 nil。例：file.read(&quot;*l&quot;)</td>
</tr>
<tr>
<td>number</td>
<td>返回一个指定字符个数的字符串，或在 EOF 时返回 nil。例：file.read(5)</td>
</tr>
</tbody>
</table>
<p>  其他的 io 方法有：</p>
<ul>
<li>io.tmpfile():返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除</li>
<li>io.type(file): 检测obj是否一个可用的文件句柄</li>
<li>io.flush(): 向文件写入缓冲中的所有数据</li>
<li>io.lines(optional file name): 返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返回 nil，但不关闭文件。</li>
</ul>
<h3 id="完全模式">完全模式</h3>
<p>  通常需要在同一时间处理多个文件。我们需要使用 file:function_name 来代替 io.function_name 方法。以下实例演示了如何同时处理同一个文件:</p>
<p>  read 的参数与简单模式一致。</p>
<p>  其他方法:</p>
<ul>
<li>file:seek(optional whence, optional offset): 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。参数 whence 值可以是:
<ul>
<li>“set”: 从文件头开始</li>
<li>“cur”: 从当前位置开始[默认]</li>
<li>“end”: 从文件尾开始</li>
<li>offset:默认为0<br/>不带参数file:seek()则返回当前位置,file:seek(“set”)则定位到文件头,file:seek(“end”)则定位到文件尾并返回文件大小</li>
</ul>
</li>
<li>file:flush(): 向文件写入缓冲中的所有数据</li>
<li>io.lines(optional file name): 打开指定的文件 filename 为读模式并返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返回 nil，并自动关闭文件。<br/>若不带参数时io.lines() &lt;=&gt; io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件，如：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>(<span class="string">&quot;main.lua&quot;</span>) <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  以下实例使用了 seek 方法，定位到文件倒数第 25 个位置并使用 read 方法的 *a 参数，即从当前位置(倒数第 25 个位置)读取整个文件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;15_2-test.lua&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">file:seek(<span class="string">&quot;end&quot;</span>,<span class="number">-25</span>)</span><br><span class="line"><span class="built_in">print</span>(file:<span class="built_in">read</span>(<span class="string">&quot;*a&quot;</span>))</span><br><span class="line"></span><br><span class="line">file:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<h2 id="lua错误处理">Lua错误处理</h2>
<p>  程序运行中错误处理是必要的，在进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。</p>
<p>  任何程序语言中，都需要错误处理。错误类型有：</p>
<ul>
<li>语法错误</li>
<li>运行错误</li>
</ul>
<h3 id="语法错误">语法错误</h3>
<p>  语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的。一个简单的实例如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件</span></span><br><span class="line">a == <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>  以上代码执行结果为：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">lua: test.lua:<span class="number">2</span>: syntax <span class="built_in">error</span> near <span class="string">&#x27;==&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  另外一个实例:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a= <span class="number">1</span>,<span class="number">10</span></span><br><span class="line">   <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  执行以上程序会出现如下错误：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">lua: test2.lua:<span class="number">2</span>: <span class="string">&#x27;do&#x27;</span> expected near <span class="string">&#x27;print&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="运行错误">运行错误</h3>
<p>  运行错误是程序可以正常执行，但是会输出报错信息。如下实例由于参数输入错误，程序执行时报错：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a,b)</span></span></span><br><span class="line">   <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>  当编译运行以下代码时，编译是可以成功的，但在运行的时候会产生如下错误：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">lua: test2.lua:<span class="number">2</span>: attempt to perform arithmetic on <span class="keyword">local</span> <span class="string">&#x27;b&#x27;</span> (a <span class="literal">nil</span> value)</span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">    test2.lua:<span class="number">2</span>: <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> &#x27;<span class="title">add</span>&#x27;</span></span><br><span class="line"><span class="function">    <span class="title">test2.lua</span>:5: <span class="title">in</span> <span class="title">main</span> <span class="title">chunk</span></span></span><br><span class="line"><span class="function">    [<span class="title">C</span>]: ?</span></span><br></pre></td></tr></table></figure>
<p>  lua 里调用函数时，即使实参列表和形参列表不一致也能成功调用，多余的参数会被舍弃，缺少的参数会被补为 nil。</p>
<p>  以上报错信息是由于参数 b 被补为 nil 后，nil 参与了 + 运算。</p>
<p>  假如 add 函数内不是 “return a+b” 而是 “print(a,b)” 的话，结果会变成 “10 nil” 不会报错。</p>
<h3 id="错误处理">错误处理</h3>
<p>  可以使用两个函数：assert 和 error 来处理错误。实例如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a,b)</span></span></span><br><span class="line">   <span class="built_in">assert</span>(<span class="built_in">type</span>(a) == <span class="string">&quot;number&quot;</span>, <span class="string">&quot;a 不是一个数字&quot;</span>)</span><br><span class="line">   <span class="built_in">assert</span>(<span class="built_in">type</span>(b) == <span class="string">&quot;number&quot;</span>, <span class="string">&quot;b 不是一个数字&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">add(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>  实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。</p>
<h4 id="error函数">error函数</h4>
<p>  语法格式：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">error</span> (message [, level])</span><br></pre></td></tr></table></figure>
<p>  功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)</p>
<p>  通常情况下，error会附加一些错误位置的信息到message头部。</p>
<p>  Level参数指示获得错误的位置:</p>
<ul>
<li>Level=1[默认]：为调用error位置(文件+行号)</li>
<li>Level=2：指出哪个调用error的函数的函数</li>
<li>Level=0:不添加错误位置信息</li>
</ul>
<h3 id="pcall-和-xpcall-debug">pcall 和 xpcall、debug</h3>
<p>  Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。</p>
<p>  pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo。</p>
<p>  语法格式如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">pcall</span>(function_name, ….) <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- 没有错误</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">-- 一些错误</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; =<span class="built_in">pcall</span>(<span class="function"><span class="keyword">function</span><span class="params">(i)</span></span> <span class="built_in">print</span>(i) <span class="keyword">end</span>, <span class="number">33</span>)</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">   </span><br><span class="line">&gt; =<span class="built_in">pcall</span>(<span class="function"><span class="keyword">function</span><span class="params">(i)</span></span> <span class="built_in">print</span>(i) <span class="built_in">error</span>(<span class="string">&#x27;error..&#x27;</span>) <span class="keyword">end</span>, <span class="number">33</span>)</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="literal">false</span>        <span class="built_in">stdin</span>:<span class="number">1</span>: <span class="built_in">error</span>..</span><br></pre></td></tr></table></figure>
<p>  pcall以一种&quot;保护模式&quot;来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。</p>
<p>  通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。</p>
<p>  Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p>
<p>  debug库提供了两个通用的错误处理函数:</p>
<ul>
<li>debug.debug：提供一个Lua提示符，让用户来检查错误的原因</li>
<li>debug.traceback：根据调用桟来构建一个扩展的错误消息</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;=<span class="built_in">xpcall</span>(<span class="function"><span class="keyword">function</span><span class="params">(i)</span></span> <span class="built_in">print</span>(i) <span class="built_in">error</span>(<span class="string">&#x27;error..&#x27;</span>) <span class="keyword">end</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>()) <span class="keyword">end</span>, <span class="number">33</span>)</span><br><span class="line"><span class="number">33</span></span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>: <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> &lt;<span class="title">stdin</span>:1&gt;</span></span><br><span class="line"><span class="function">[<span class="title">C</span>]: <span class="title">in</span> <span class="title">function</span> &#x27;<span class="title">error</span>&#x27;</span></span><br><span class="line"><span class="function"><span class="title">stdin</span>:1: <span class="title">in</span> <span class="title">function</span> &lt;<span class="title">stdin</span>:1&gt;</span></span><br><span class="line"><span class="function">[<span class="title">C</span>]: <span class="title">in</span> <span class="title">function</span> &#x27;<span class="title">xpcall</span>&#x27;</span></span><br><span class="line"><span class="function"><span class="title">stdin</span>:1: <span class="title">in</span> <span class="title">main</span> <span class="title">chunk</span></span></span><br><span class="line"><span class="function">[<span class="title">C</span>]: <span class="title">in</span> ?</span></span><br><span class="line"><span class="function"><span class="title">false</span>        <span class="title">nil</span></span></span><br></pre></td></tr></table></figure>
<p>xpcall 使用实例 2:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunction</span> <span class="params">()</span></span></span><br><span class="line">   n = n/<span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myerrorhandler</span><span class="params">( err )</span></span></span><br><span class="line">   <span class="built_in">print</span>( <span class="string">&quot;ERROR:&quot;</span>, err )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">status</span> = <span class="built_in">xpcall</span>( myfunction, myerrorhandler )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">status</span>)</span><br></pre></td></tr></table></figure>
<h2 id="lua调试-debug">Lua调试(Debug)</h2>
<p>  Lua 提供了 debug 库用于提供创建自定义调试器的功能。Lua 本身并未有内置的调试器，但很多开发者共享了他们的 Lua 调试器代码。</p>
<p>  Lua 中 debug 库包含以下函数：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.</td>
<td>debug():<br/>进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。<br/>输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。</td>
</tr>
<tr>
<td>2.</td>
<td>getfenv(object):<br/>返回对象的环境变量。</td>
</tr>
<tr>
<td>3.</td>
<td>gethook(optional thread):<br/>返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数</td>
</tr>
<tr>
<td>4.</td>
<td>getinfo ([thread,] f [, what]):<br/>返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。</td>
</tr>
<tr>
<td>5.</td>
<td>debug.getlocal ([thread,] f, local):<br/>此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。</td>
</tr>
<tr>
<td>6.</td>
<td>getmetatable(value):<br/>把给定索引指向的值的元表压入堆栈。如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西。</td>
</tr>
<tr>
<td>7.</td>
<td>getregistry():<br/>返回注册表表，这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。</td>
</tr>
<tr>
<td>8.</td>
<td>getupvalue (f, up)<br/>此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。<br/>以 ‘(’ （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）。</td>
</tr>
<tr>
<td>9.</td>
<td>sethook ([thread,] hook, mask [, count]):<br/>将一个函数作为钩子函数设入。 字符串 mask 以及数字 count 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义：<br/> ‘c’: 每当 Lua 调用一个函数时，调用钩子；<br/>‘r’: 每当 Lua 从一个函数内返回时，调用钩子；<br/>‘l’: 每当 Lua 进入新的一行时，调用钩子。</td>
</tr>
<tr>
<td>10.</td>
<td>setlocal ([thread,] level, local, value):<br/>这个函数将 value 赋给 栈上第 level 层函数的第 local 个局部变量。 如果没有那个变量，函数返回 nil 。 如果 level 越界，抛出一个错误。</td>
</tr>
<tr>
<td>11.</td>
<td>setmetatable (value, table):<br/>将 value 的元表设为 table （可以是 nil）。 返回 value。</td>
</tr>
<tr>
<td>12.</td>
<td>setupvalue (f, up, value):<br/>这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。</td>
</tr>
<tr>
<td>13.</td>
<td>traceback ([thread,] [message [, level]]):<br/>如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。 否则，它返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunction</span> <span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>(<span class="string">&quot;Stack trace&quot;</span>))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">1</span>))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Stack trace end&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">myfunction ()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>  在实例中，使用到了 debug 库的 traceback 和 getinfo 函数， getinfo 函数用于返回函数信息的表。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span> <span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">local</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    k = n</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">counter = newCounter ()</span><br><span class="line"><span class="built_in">print</span>(counter())</span><br><span class="line"><span class="built_in">print</span>(counter())</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">  name, val = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(counter, i)</span><br><span class="line">  <span class="keyword">if</span> name <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;index&quot;</span>, i, name, <span class="string">&quot;=&quot;</span>, val)</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">&quot;n&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">debug</span>.<span class="built_in">setupvalue</span> (counter,<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span> <span class="comment">-- if</span></span><br><span class="line"><span class="keyword">until</span> <span class="keyword">not</span> name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(counter())</span><br></pre></td></tr></table></figure>
<p>  在以上实例中，计数器在每次调用时都会自增1。实例中我们使用了 getupvalue 函数查看局部变量的当前状态。我们可以设置局部变量为新值。实例中，在设置前 n 的值为 2,使用 setupvalue 函数将其设置为 10。现在我们调用函数，执行后输出为 11 而不是 3。</p>
<h2 id="lua垃圾回收">Lua垃圾回收</h2>
<p>  Lua 采用了自动内存管理。 这意味着不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。</p>
<p>  Lua 运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。</p>
<p>  Lua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： 垃圾收集器间歇率和垃圾收集器步进倍率。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。</p>
<p>  垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。</p>
<p>  垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的&quot;两倍&quot;速工作。</p>
<p>  如果把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。</p>
<h3 id="垃圾回收函数">垃圾回收函数</h3>
<p>  Lua 提供了以下函数collectgarbage ([opt [, arg]])用来控制自动内存管理:</p>
<ul>
<li>collectgarbage(“collect”): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</li>
<li>collectgarbage(“count”): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</li>
<li>collectgarbage(“restart”): 重启垃圾收集器的自动运行。</li>
<li>collectgarbage(“setpause”): 将 arg 设为收集器的 间歇率。 返回 间歇率 的前一个值。</li>
<li>collectgarbage(“setstepmul”): 返回 步进倍率 的前一个值。</li>
<li>collectgarbage(“step”): 单步运行垃圾收集器。 步长&quot;大小&quot;由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</li>
<li>collectgarbage(“stop”): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。</li>
</ul>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = &#123;<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">&quot;count&quot;</span>) * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">mytable = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">&quot;count&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">&quot;collect&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">collectgarbage</span>(<span class="string">&quot;count&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="lua面向对象">Lua面向对象</h2>
<p>  面向对象编程（Object Oriented Programming，OOP）是一种非常流行的计算机编程架构。</p>
<p>  以下几种编程语言都支持面向对象编程：</p>
<ul>
<li>C++</li>
<li>Java</li>
<li>Objective-C</li>
<li>Smalltalk</li>
<li>C#</li>
<li>Ruby</li>
</ul>
<h3 id="面向对象特征">面向对象特征</h3>
<ol>
<li>封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。</li>
<li>继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。</li>
<li>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</li>
<li>抽象：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。</li>
</ol>
<h3 id="lua中面向对象">Lua中面向对象</h3>
<ul>
<li>对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。</li>
<li>lua 中的 function 可以用来表示方法。那么LUA中的类可以通过 table + function 模拟出来。</li>
<li>至于继承，可以通过 metetable 模拟出来（不推荐用，只模拟最基本的对象大部分实现够用了）。</li>
<li>Lua 中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Account = &#123;balance = <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account.withdraw</span> <span class="params">(v)</span></span></span><br><span class="line">    Account.balance = Account.balance - v</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>  这个定义创建了一个新的函数，并且保存在Account对象的withdraw域内，下面我们可以这样调用：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Account.withdraw(<span class="number">100.00</span>)</span><br></pre></td></tr></table></figure>
<h4 id="示例">示例</h4>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Rectangle = &#123;area = <span class="number">0</span>,length = <span class="number">0</span>,breadth = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span> : <span class="title">new</span><span class="params">(o,length,breadth)</span></span></span><br><span class="line">	o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">	<span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">	<span class="built_in">self</span>.length = length <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">	<span class="built_in">self</span>.breadth = breadth <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">	<span class="built_in">self</span>.area = length * breadth</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span> : <span class="title">printArra</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;矩形面积为&quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="创建对象">创建对象</h4>
<p>  创建对象是为类的实例分配内存的过程。每个类都有属于自己的内存并共享公共数据。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 继上面示例</span></span><br><span class="line">r = Rectangle : new(<span class="literal">nil</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h4 id="访问属性">访问属性</h4>
<p>  可以使用点号(.)来访问类的属性：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(r.length)</span><br></pre></td></tr></table></figure>
<h4 id="访问成员函数">访问成员函数</h4>
<p>  可以使用冒号 <code>:</code> 来访问类的成员函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">r:printArra()</span><br></pre></td></tr></table></figure>
<p>内存在对象初始化时分配。</p>
<h4 id="完整案例">完整案例</h4>
<p>代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Shape = &#123;area = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:new</span><span class="params">(o,side)</span></span></span><br><span class="line">	o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">	<span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">	side = side <span class="keyword">or</span> o</span><br><span class="line">	<span class="built_in">self</span>.area = side * side</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:printArea</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;面积为&quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myshape = Shape:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">myshape:printArea()</span><br></pre></td></tr></table></figure>
<h3 id="lua继承">Lua继承</h3>
<p>  继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。</p>
<p>  以下演示了一个简单的继承实例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span> : <span class="title">new</span><span class="params">(o,side)</span></span></span><br><span class="line">	o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">	<span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">	side = side <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">	<span class="built_in">self</span>.area = side * side</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape:printArea</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;面积为&quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>接下来的实例，Square 对象继承了 Shape 类:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Squre = Shape:new()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Squre</span> : <span class="title">new</span><span class="params">(o,side)</span></span></span><br><span class="line">	o = o <span class="keyword">or</span> Shape:new(o,side)</span><br><span class="line">	<span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">	<span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="完整案例">完整案例</h4>
<p>  以下实例继承了一个简单的类，来扩展派生类的方法，派生类中保留了继承类的成员变量和方法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Shape = &#123;area = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span> : <span class="title">new</span><span class="params">(o,side)</span></span></span><br><span class="line">	o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">	<span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">	<span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">	side = side <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">	<span class="built_in">self</span>.area = side * side</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span> : <span class="title">printArea</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;面积为&quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myshape = Shape:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br><span class="line">myshape:printArea()</span><br><span class="line"></span><br><span class="line">Squre = Shape:new()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Squre:new</span><span class="params">(o,side)</span></span></span><br><span class="line">	o = o <span class="keyword">or</span> Shape:new(o,side)</span><br><span class="line">	<span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">	<span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Squre:printArea</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;正方形面积为&quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mysqure = Squre:new(<span class="literal">nil</span>,<span class="number">10</span>)</span><br><span class="line">mysqure:printArea()</span><br><span class="line"></span><br><span class="line">Rectangle = Shape:new()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle:new</span><span class="params">(o,length,breadth)</span></span></span><br><span class="line">	o = o <span class="keyword">or</span> Shape:new(o)</span><br><span class="line">	<span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">	<span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">	<span class="built_in">self</span>.area = length * breadth</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle:printArea</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;矩形面积为&quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myrectangle = Rectangle:new(<span class="literal">nil</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">myrectangle:printArea()</span><br></pre></td></tr></table></figure>
<h3 id="函数重写">函数重写</h3>
<p>  Lua 中可以重写基础类的函数，在派生类中定义自己的实现方式：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Squre:printArea</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;正方形面积&quot;</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="lua数据库访问">Lua数据库访问</h2>
<p>  Lua 连接MySql 数据库：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">&quot;luasql.mysql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--创建环境对象</span></span><br><span class="line">env = luasql.mysql()</span><br><span class="line"></span><br><span class="line"><span class="comment">--连接数据库</span></span><br><span class="line">conn = env:connect(<span class="string">&quot;数据库名&quot;</span>,<span class="string">&quot;用户名&quot;</span>,<span class="string">&quot;密码&quot;</span>,<span class="string">&quot;IP地址&quot;</span>,端口)</span><br><span class="line"></span><br><span class="line"><span class="comment">--设置数据库的编码格式</span></span><br><span class="line">conn:<span class="built_in">execute</span><span class="string">&quot;SET NAMES UTF8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--执行数据库操作</span></span><br><span class="line">cur = conn:<span class="built_in">execute</span>(<span class="string">&quot;select * from role&quot;</span>)</span><br><span class="line"></span><br><span class="line">row = cur:fetch(&#123;&#125;,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--文件对象的创建</span></span><br><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;role.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> row <span class="keyword">do</span></span><br><span class="line">    var = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%d %s\n&quot;</span>, row.id, row.name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(var)</span><br><span class="line"></span><br><span class="line">    file:<span class="built_in">write</span>(var)</span><br><span class="line"></span><br><span class="line">    row = cur:fetch(row,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file:<span class="built_in">close</span>()  <span class="comment">--关闭文件对象</span></span><br><span class="line">conn:<span class="built_in">close</span>()  <span class="comment">--关闭数据库连接</span></span><br><span class="line">env:<span class="built_in">close</span>()   <span class="comment">--关闭数据库环境</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>游戏热更新</category>
      </categories>
      <tags>
        <tag>游戏热更新</tag>
      </tags>
  </entry>
  <entry>
    <title>C++进修——C++核心编程</title>
    <url>/2024/04/25/C-%E8%BF%9B%E4%BF%AE%E2%80%94%E2%80%94C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1>内存分区模型</h1>
<p>  C++程序在执行时，将内存大方向划分为4个区域</p>
<ul>
<li>代码区：存放函数体的二进制编码，由操作系统进行管理</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>
</ul>
<p>  <strong>内存4区意义</strong>：</p>
<ul>
<li>不同的区域存放不同的数据，赋予不同的生命周期，给我们更大的灵活编程</li>
</ul>
<h2 id="程序运行前">程序运行前</h2>
<p>  在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>  <strong>代码区</strong></p>
<p>    存放CPU执行的机器指令</p>
<p>    代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>    代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外的修改了它的指令</p>
<p>  <strong>全局区</strong></p>
<p>    全局变量和静态变量存放在此</p>
<p>    全局区还包括了常量区，字符串常量和其他常量也存放在此</p>
<p>    <mark>该区域的数据在程序结束之后由操作系统释放</mark></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//局部变量不在全局区</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部常量不在全局区中</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程序运行后">程序运行后</h2>
<p>  <strong>栈区</strong></p>
<p>    由编译器自动释放，存放函数的参数值，局部变量等</p>
<p>    注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  注意：</p>
<p>    x64函数的调用通常使用寄存器来传递参数和返回值，如果想要达到x86的效果，可以在两次输出之前输入<code>system(&quot;pause&quot;)</code></p>
<p>  <strong>堆区</strong></p>
<p>    由程序员分配释放，若程序员不能释放，程序结束时由操作系统回收</p>
<p>    在C++中主要利用new在堆区开辟内存</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="new操作符">new操作符</h2>
<p>  C++中利用<mark>new</mark>操作符在堆区开辟数据</p>
<p>  堆区开辟的数，由程序员手动开辟，手动释放，释放利用操作符<mark>delete</mark></p>
<p>  语法：<code>new 数据类型</code></p>
<p>  利用new创建的数据，会返回该数据对应的类型的指针</p>
<p>基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>引用</h1>
<h2 id="引用的基本使用">引用的基本使用</h2>
<p>  <strong>作用</strong>：给变量起别名</p>
<p>  <strong>语法</strong>：<code>数据类型 &amp;别名 = 原名</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用注意事项">引用注意事项</h2>
<ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//错误，引用必须初始化</span></span><br><span class="line">	<span class="comment">//int &amp;c;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一旦初始化后，就不可以改变</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这是赋值操作，不是更改引用	</span></span><br><span class="line">	c = b;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用做函数参数">引用做函数参数</h2>
<p>  <strong>作用</strong>：函数传参时，可以利用引用的技术让形参修饰实参<br>
  <strong>优点</strong>：可以简化指针修改实参</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用做函数返回值">引用做函数返回值</h2>
<p>  <strong>作用</strong>：引用是可以作为函数的返回值存在的</p>
<p>  <strong>注意</strong>：不要返回局部变量引用</p>
<p>  <strong>用法</strong>：函数调用作为左值</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用的本质">引用的本质</h2>
<p>  <strong>本质</strong>：引用的本质在c++内部实现是一个指针常量</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>&amp; ref = a;</span><br><span class="line">	ref = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量引用">常量引用</h2>
<p>  <strong>作用</strong>：常量引用主要用来修饰形参，防止误操作</p>
<p>  在函数形参列表中，可以加<mark>const修饰形参</mark>，防止形参改变实参</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span></span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//引用本身需要一个合法的内存空间，因此运行错误</span></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//加入const就不会报错</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>函数提高</h1>
<h2 id="函数默认参数">函数默认参数</h2>
<p>  在C++中，函数的形参列表中的形参是可以由默认值的</p>
<p>  语法：<code>返回值类型 函数名(参数 = 默认值)&#123;&#125;</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">10</span>,<span class="type">int</span> c = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>,<span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数占位参数">函数占位参数</h2>
<p>  C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p>  <strong>语法</strong>：<code>返回值类型 函数名(数据类型)&#123;&#125;</code></p>
<p>  在现阶段函数的占位参数存在意义不大，但是后面会用到该技术</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//占位符必须填补</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数重载">函数重载</h2>
<h3 id="函数重载概述">函数重载概述</h3>
<p>  <strong>作用</strong>：函数名可以使用，提高复用性</p>
<p>  <strong>函数重载满足条件</strong>：</p>
<ul>
<li>同一个作用于下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p>  <strong>注意</strong>：函数的返回值不可以作为函数重载的条件</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int a&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double a&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double b&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int b&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">/*int func(double a,int b)&#123;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;double a&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载注意事项">函数重载注意事项</h3>
<ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;a&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;const&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a,b = 10&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用有const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//碰到默认参数产生歧义，需要避免</span></span><br><span class="line">	<span class="comment">//func2(10);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>类和对象</h1>
<p>  C++面向对象的三大特性为：<mark>封装、继承、多态</mark></p>
<p>  C++认为<mark>万事万物皆为对象</mark>，对象上有其属性和行为</p>
<p>  <strong>例如</strong>：</p>
<p>    人可以作为对象，属性有姓名、年龄等，行为有走、跑等</p>
<p>    车作为对象，属性有轮胎、方向盘等，行为有载人、放音乐等</p>
<p>    具有相同性质的<mark>对象</mark>，可以抽象称为<mark>类</mark></p>
<h2 id="封装">封装</h2>
<h3 id="封装的意义">封装的意义</h3>
<p>  封装是C++面向对象三大特性之一</p>
<p>  封装的意义：</p>
<p>    将属性和行为作为一个整体，表现生活中的事物</p>
<p>    将属性和行为加以权限控制</p>
<p>  <strong>封装的意义一</strong>：</p>
<p>    在设计类的时候，属性和行为写在一起，表现事物</p>
<p>  <strong>语法</strong>：<code>class 类名&#123;访问权限:属性/行为&#125;;</code></p>
<p>示例：设计一个圆类，求圆的周长</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_r;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * pi * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c1.<span class="built_in">calculate</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>封装意义二</strong>：</p>
<p>    类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>  访问权限有三种：</p>
<p>    1. public 公共权限</p>
<p>    2. protected  保护权限</p>
<p>    3. private 私有权限</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;汽车&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line"></span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Car = &quot;aodi&quot;;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在类外访问不到</span></span><br><span class="line">	<span class="comment">//p1.m_Password = 123;</span></span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="struct-和-class-区别">struct 和 class 区别</h3>
<p>  在 C++ 中 struct 和 class 唯一的<strong>区别</strong>就在于<strong>默认的访问权限不同</strong></p>
<p>  区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class 默认权限为私有</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>&#123;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span>&#123;</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员属性设置为私有">成员属性设置为私有</h3>
<p>  <strong>优点1</strong>：将所有成员属性设置为私有，可以自己控制读写权限</p>
<p>  <strong>优点2</strong>：对于写权限，可以检测数据的有效性</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">string <span class="title">GetName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetAge</span><span class="params">(<span class="type">int</span> age)</span></span>&#123;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetIdol</span><span class="params">(string idol)</span></span>&#123;</span><br><span class="line">		m_Idol = idol;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age = <span class="number">18</span>;</span><br><span class="line">	string m_Idol;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">SetName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; p.<span class="built_in">GetName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p.<span class="built_in">GetAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">SetIdol</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象的初始化和清理">对象的初始化和清理</h2>
<p>  C++中的每个对象都会有初始设置以及对象销毁前的清理数据的设置</p>
<h3 id="构造函数和析构函数">构造函数和析构函数</h3>
<p>  对象的<strong>初始化</strong>和<strong>清理</strong>也是两个非常重要的安全问题</p>
<p>    一个对象或变量没有初始状态，对其使用后果是未知</p>
<p>    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>  C++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被连一起自动调用，完成对象初始化和清理工作</p>
<p>  对象的初始化和清理工作是编译器强制要求做的事情，因此如果<strong>不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现</strong></p>
<p>    构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用</p>
<p>    析构函数：主要作用在于<strong>对象销毁前</strong>系统自动调用，执行一些工作</p>
<p>  <strong>构造函数语法</strong>：<code>类名()&#123;&#125;</code></p>
<p>    构造函数没有返回值也不写void</p>
<p>    函数名称和类名相同</p>
<p>    构造函数可以有参数，因此可以发生重载</p>
<p>    程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次</p>
<p>  <strong>析构函数语法</strong>：<code>~类名()&#123;&#125;</code></p>
<p>    析构函数，没有返回值也不写void</p>
<p>    函数名称与类名相同，在名称前加上符号~</p>
<p>    析构函数不可以有参数，因此不可以发生重载</p>
<p>    程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数的分类和调用">构造函数的分类和调用</h3>
<p>  两种分类方式：</p>
<p>    按参数分为：有参构造和无参构造</p>
<p>    按类型分为：普通构造和拷贝构造</p>
<p>  三种调用方式：</p>
<p>    括号法</p>
<p>    显示法</p>
<p>    隐式转换发</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)&#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//括号法（常用）</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意：调用无参构造函数不能加括号，如果加了编译器认为是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//单独写就是匿名对象，当前行结束，马上析构</span></span><br><span class="line">	<span class="comment">//Person(10);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>;</span><br><span class="line">	Person p5 = p4;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意：不能利用拷贝构造函数，初始化匿名对象，编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝构造函数调用时机">拷贝构造函数调用时机</h3>
<p>  C++中拷贝构造函数调用时机通常有三种情况</p>
<p>    使用一个已经创建完毕的对象来初始化一个新对象</p>
<p>    值传递的方式给函数参数传递</p>
<p>    以值方式返回局部对象</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p2.mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数调用规则">构造函数调用规则</h3>
<p>  默认情况下，C++编译器至少给一个类添加3个函数</p>
<p>    默认构造函数（无参，函数体为空）</p>
<p>    默认析构函数（无参，函数体为空）</p>
<p>    默认拷贝构造函数，对属性值进行拷贝</p>
<p>  构造函数调用规则如下：</p>
<p>    如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝函数</p>
<p>    如果用户定义拷贝构造函数，C++不会再提供其他构造函数</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(Person&amp; p)&#123;</span><br><span class="line">		m_Age = p.m_Age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h3>
<p>  浅拷贝：简单的赋值拷贝操作</p>
<p>  深拷贝：在堆区重新申请空间、进行拷贝工作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age,<span class="type">int</span> height)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_hight = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_Age = p.m_Age;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//深拷贝操作</span></span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span>(m_height != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1.m_Age &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.m_Age &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果属性在堆区开辟，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题（堆区重复释放）</p>
<h3 id="初始化列表">初始化列表</h3>
<p>  <strong>作用</strong>：</p>
<p>    C++提供了初始化列表语法，用来初始化属性</p>
<p>  <strong>语法</strong>：<code>构造函数():属性1(值1),属性2(值2)...&#123;&#125;</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 传统方式初始化</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Person(int a,int b,int c)&#123;</span></span><br><span class="line"><span class="comment">		m_A = a;</span></span><br><span class="line"><span class="comment">		m_B = b;</span></span><br><span class="line"><span class="comment">		m_C = c;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表初始化属性</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">m_A</span>(a),<span class="built_in">m_B</span>(b),<span class="built_in">m_C</span>(c)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//Person p(10,20,30);</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类对象作为类成员">类对象作为类成员</h3>
<p>  C++中的类可以是另一个类的对象，将该对象称为对象成员</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  B类中有对象A作为成员，A为对象成员</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string pName) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_PName = pName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;phone ~&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">phone</span>(pName)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person ~&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;Apple&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p.m_Name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.phone.m_PName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  总结：</p>
<p>    当其他类对象作为本类成员，构造时候先构造类对象，再构造自身</p>
<p>    析构的顺序与构造的相反</p>
<h3 id="静态成员">静态成员</h3>
<p>  静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>  静态成员分为：</p>
<p>    静态成员变量</p>
<p>      所有对象共享的一份数据</p>
<p>      在编译阶段分配内存</p>
<p>      类内生命，类外初始化</p>
<p>    静态成员函数</p>
<p>      所有对象共享同一个函数</p>
<p>      静态成员函数只能访问静态成员变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p.m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出的值为200，所以说明所有对象共享同一个数据</span></span><br><span class="line">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">/*Person p;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问不到</span></span><br><span class="line">	<span class="comment">//Person::func2();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-对象模型和this指针">C++对象模型和this指针</h2>
<h3 id="成员变量和成员函数分开存储">成员变量和成员函数分开存储</h3>
<p>  在C++中，类内的成员变量和成员函数分开存储</p>
<p>  只有非静态成员变量才属于类的对象上</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>总结</strong>：</p>
<p>    空对象占用内存空间为1</p>
<p>    C++编译器会给每个空对象也分配一个空间，时为了区分空对象占内存的情况</p>
<p>    每个空对象也应该有一个独一无二的内存地址</p>
<h3 id="this指针概念">this指针概念</h3>
<p>  C++通过提供特殊的对象指针，this指针，解决区分某个对象调用自己，<strong>this指向被调用的成员函数所属的对象</strong></p>
<p>  this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>  this指针不需要定义，直接使用即可</p>
<p>  this指针的用途：</p>
<p>    当形参和成员变量同名时，可用 this 指针来区分</p>
<p>    在类的非静态成员函数中返回对象本身，可使用 return *this</p>
<p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(Person &amp;p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; age +=p.age;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p2.<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line">	cout &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空指针访问成员函数">空指针访问成员函数</h3>
<p>  C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p>
<p>  如果用到 this 指针，需要加以判断保证代码的健壮性</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//报错，因为传入的指针为空</span></span><br><span class="line">	<span class="comment">//p -&gt; showPersonAge();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const修饰成员函数">const修饰成员函数</h3>
<p>  <strong>常函数</strong>：</p>
<p>    成员函数后加const后称这个数为<strong>常函数</strong></p>
<p>    常函数内不可以修改成员属性</p>
<p>    成员属性声明时加关键字 muteble 后，在常函数中依旧可以修改</p>
<p>  <strong>常对象</strong>：</p>
<p>    声明对象前加const称该对象为常对象</p>
<p>    常对象只能调用常函数</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="comment">//this -&gt; m_A = 100;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> -&gt; m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">const</span> Person p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//p.m_A = 100;</span></span><br><span class="line">	p.m_B = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//p.func();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  总结：</p>
<p>    this指针的本质是指针常量，指针的指向是不可以修改的</p>
<p>    this指针不可以修改指针的指向的</p>
<p>    在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改</p>
<p>    加关键字mutable的特殊变量，即使在常函数中，也可以修改这个值</p>
<p>    加了muteble的特殊变量，在常对象下也可以修改</p>
<p>    常对象只能调用常函数，不可以调用普通成员函数，因为普通成员函数可以修改属性</p>
<h2 id="友元">友元</h2>
<p>  在程序里，有些私有属性想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>  友元的目的就是让一个函数或者类访问另一个类中私有成员</p>
<p>  友元的关键字为 <mark>friend</mark></p>
<p>  友元的三种实现</p>
<p>    全局函数做友元</p>
<p>    类做友元</p>
<p>    成员函数做友元</p>
<h3 id="全局函数做友元">全局函数做友元</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">	<span class="comment">//goodGay可以访问Building中的私有成员</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>() &#123;</span><br><span class="line">		m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building&amp; building)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; building.m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Building building;</span><br><span class="line">	<span class="built_in">goodGay</span>(building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类做友元">类做友元</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">	<span class="comment">//GoodGay可以访问本类中的私有成员</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line">	string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">	m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	GoodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数做友元">成员函数做友元</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//让visit函数可以访问私有成员</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">	<span class="comment">//告诉编译器，GoodGay下的visit成员函数作为本类的友元，可以访问私有的成员</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line">	string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">	m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; building -&gt; m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; building -&gt; m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	GoodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载">运算符重载</h2>
<p>  运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h3 id="加号运算符重载">加号运算符重载</h3>
<p>  作用：实现两个自定义数据类型相加的运算</p>
<p>  注意：</p>
<p>    对于内置的数据类型的表达式的运算符是不可以改变的</p>
<p>    不能滥用运算符重载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数重载+</span></span><br><span class="line">	<span class="comment">/*Person operator+(Person&amp; p) &#123;</span></span><br><span class="line"><span class="comment">		Person temp;</span></span><br><span class="line"><span class="comment">		temp.m_A = this-&gt;m_A + p.m_A;</span></span><br><span class="line"><span class="comment">		temp.m_B = this-&gt;m_B + p.m_B;</span></span><br><span class="line"><span class="comment">		return temp;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2) &#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p1.m_A + p2.m_B;</span><br><span class="line">	temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, <span class="type">int</span> a) &#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p1.m_A + a;</span><br><span class="line">	temp.m_B = p1.m_B + a;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">10</span>;</span><br><span class="line">	p1.m_B = <span class="number">10</span>;</span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">10</span>;</span><br><span class="line">	p2.m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	Person p3 = p1 + p2;</span><br><span class="line">	Person p4 = p1 + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p4.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="左移运算符重载">左移运算符重载</h3>
<p>  作用：可以输出自定义数据类型</p>
<p>  重载左移运算符配合友元可以实现输出自定义数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">		m_A = a;</span><br><span class="line">		m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; cout, Person p) &#123;</span><br><span class="line">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递增运算符重载">递增运算符重载</h3>
<p>  通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; cout, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载前置++运算符</span></span><br><span class="line">	<span class="comment">//返回引用是为了一直对一个数据进行递增操作</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载后置++运算符</span></span><br><span class="line">	<span class="comment">//参数中的占位参数int可以作为区分前置和后置递增</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream &amp; cout, MyInteger myint) &#123;</span><br><span class="line">	cout &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myint;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ++myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myint;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; myint++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赋值运算符重载">赋值运算符重载</h3>
<p>  C++编译器至少给一个类添加4个函数</p>
<p>    1.默认构造函数（无参，函数体为空）</p>
<p>    2.默认析构函数（无参，函数体为空）</p>
<p>    3.默认拷贝构造函数，对属性进行值拷贝</p>
<p>    4.赋值运算符 operator=，对属性进行值拷贝</p>
<p>  如果类中有属性指向堆区，做复制操作时也会出现深浅拷贝问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* m_Age;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person&amp; p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">16</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符重载">关系运算符重载</h3>
<p><strong>作用</strong>：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;age == p.age &amp;&amp; <span class="keyword">this</span>-&gt;name == p.name) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (p1 == p2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用运算符重载">函数调用运算符重载</h3>
<ul>
<li>函数调用运算符()也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此成为仿函数</li>
<li>仿函数没有固定方法，非常灵活</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyPrint myprint;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//由于使用起来类似于函数调用，因此成为仿函数</span></span><br><span class="line">	<span class="built_in">myprint</span>(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 + num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">myAdd</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2>
<p><strong>继承是面向对象三大特征之一</strong></p>
<h3 id="继承的基本语法">继承的基本语法</h3>
<p>继承的优点：减少重复代码</p>
<p><strong>语法</strong>：<code>class 子类 : public 父类</code><br>
子类也被称为派生类<br>
父类也被称为基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<ul>
<li>一类是从基类继承过来的，一类是自己增加的成员</li>
<li>从基类继承过来的表现其共性，而新增的成员体现了其个性</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是网页头部&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是网页底部&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是网页左侧边框展示&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cpp</span> : <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Cpp cpp;</span><br><span class="line">	cpp.<span class="built_in">content</span>();</span><br><span class="line">	cpp.<span class="built_in">footer</span>();</span><br><span class="line">	cpp.<span class="built_in">header</span>();</span><br><span class="line">	cpp.<span class="built_in">left</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承方式">继承方式</h3>
<p>继承的语法：<code>class 子类 : 继承方式 父类</code></p>
<p><strong>继承方式一共有三种</strong>：</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="/images/c++/c++_2/c++_2_1.png" alt=""></p>
<p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//父类中的公共权限成员 到子类中依然是公共权限</span></span><br><span class="line">		m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//父类中的保护权限成员 到子类中依然是保护权限</span></span><br><span class="line">		m_B = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//父类中的四有权限成员 子类访问不到</span></span><br><span class="line">		<span class="comment">//m_C = 30;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//由于是保护权限，所以类外访问不到这个成员</span></span><br><span class="line">	<span class="comment">//s1.m_B = 100;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">protected</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		m_B = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//私有权限依旧访问不到</span></span><br><span class="line">		<span class="comment">//m_C = 100;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son2 son2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//protected继承方式将父类中的public权限的变量转换成了protected权限，无法类外访问</span></span><br><span class="line">	<span class="comment">//son2.m_A;</span></span><br><span class="line">	<span class="comment">//son2.m_B;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> : <span class="keyword">private</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		m_A = <span class="number">10</span>;</span><br><span class="line">		m_B = <span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//依旧无法访问到私有权限成员变量</span></span><br><span class="line">		<span class="comment">//m_C = 10;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//private继承方式将父类中的成员都变成了private权限，无法在外部访问</span></span><br><span class="line">	<span class="comment">//m_A = 1;</span></span><br><span class="line">	<span class="comment">//m_B = 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承中的对象模型">继承中的对象模型</h3>
<p><strong>问题</strong>：从父类继承过来的成员，哪些属于子类对象？</p>
<p>父类中私有成员也被子类继承了，只是由编译器给隐藏后访问不到</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用开发人员命令提示工具查看对象模型</span></span><br><span class="line"><span class="comment">//跳转盘符  F:</span></span><br><span class="line"><span class="comment">//跳转文件路径 cd 具体路径</span></span><br><span class="line"><span class="comment">//查看命名</span></span><br><span class="line"><span class="comment">//cl /d1 reportSingleClassLayout类名 文件名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承中构造和析构顺序">继承中构造和析构顺序</h3>
<p>子类继承父类后，当创建子类对象，也会调用父类对象中的构造函数</p>
<p><strong>问题</strong>：父类和子类的构造函数谁先调用？</p>
<p>顺序如下：</p>
<ul>
<li>先构造父类，再构造子类</li>
<li>析构的顺序与构造的顺序相反</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Base</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Son</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承同名成员处理方式">继承同名成员处理方式</h3>
<p>问题：当子类成员与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据？</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类和父类拥有同名的成员函数，子类会隐藏掉父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>() &#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>() &#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果通过子类对象访问到父类中的同名成员，需要加作用域</span></span><br><span class="line">	cout &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承同名静态成员处理方式">继承同名静态成员处理方式</h3>
<p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致：</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p>同名静态成员处理方式和非静态处理方式一样，只不过有两种访问方式（通过对象和通过类名）</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base静态&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son静态&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多继承语法">多继承语法</h3>
<p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code>class 子类 : 继承方式 父类1,继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>() &#123;</span><br><span class="line">		m_A = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>() &#123;</span><br><span class="line">		m_B = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>() &#123;</span><br><span class="line">		m_C = <span class="number">3</span>;</span><br><span class="line">		m_D = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="菱形继承">菱形继承</h3>
<p><strong>菱形继承概念</strong></p>
<ul>
<li>两个派生类继承同一个基类</li>
<li>又有某个类同时继承两个派生类</li>
<li>这种继承被称为菱形继承，或者钻石继承</li>
</ul>
<p><strong>案例</strong>：</p>
<p><img src="/images/c++/c++_2/c++_2_2.png" alt=""></p>
<p><strong>分析案例中出现的问题</strong></p>
<ol>
<li>羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，会产生二义性</li>
<li>羊驼继承自动物的数据变成了两份，其实一份即可</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为菱形继承导致数据有两份，资源浪费</span></span><br><span class="line"><span class="comment">//利用虚继承 加上关键字 virtual 变为虚继承</span></span><br><span class="line"><span class="comment">//Animal类称为 虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep,<span class="keyword">public</span> Tuo&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当菱形继承，两个父类拥有相同数据，需要加以作用域区分</span></span><br><span class="line">	cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态">多态</h2>
<h3 id="多态的基本概念">多态的基本概念</h3>
<p>  <strong>多态是C++面向对象三大特性之一</strong></p>
<p>  多态分为两类</p>
<p>    静态多态：函数重载和运算符重载属于静态多态，复用函数名</p>
<p>    动态多态：派生类和虚函数实现运行时多态</p>
<p>  静态多态和动态多态区别：</p>
<p>    静态多态的函数地址早绑定 - 编译阶段确定函数地址</p>
<p>    动态多态的函数地址晚绑定 - 运行阶段确定函数地址</p>
<p>  动态多态满足条件：</p>
<p>    有继承关系</p>
<p>    子类重写父类的虚函数</p>
<p>  动态多态使用：</p>
<p>    父类的指针或引用指向子类对象</p>
<p>  重写：函数返回值类型 函数名 参数列表完全一致成为重写</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;猫说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;狗说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址早绑定 在编译阶段确定函数地址</span></span><br><span class="line"><span class="comment">//如果想让猫说话 那么这个函数地址就不能提前绑定 需要在运行阶段进行绑定 地址晚绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">doSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">doSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态案例一：计算器类">多态案例一：计算器类</h3>
<p>  案例描述：</p>
<p>    分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算机类</p>
<p>  多态的优点：</p>
<p>    代码组织结构清晰</p>
<p>    可读性强</p>
<p>    利于前期和后期的拓展和维护</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> num1 + num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> num1 - num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> num1 * num2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num1;</span><br><span class="line">	<span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Caculator c;</span><br><span class="line">	c.num1 = <span class="number">1</span>;</span><br><span class="line">	c.num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num1;</span><br><span class="line">	<span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> : <span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 + num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> : <span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> : <span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 * num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	AbstractCalculator* abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;num1 = <span class="number">1</span>;</span><br><span class="line">	abc-&gt;num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;num1 = <span class="number">1</span>;</span><br><span class="line">	abc-&gt;num2 = <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;num1 = <span class="number">1</span>;</span><br><span class="line">	abc-&gt;num2 = <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="纯虚函数和抽象类">纯虚函数和抽象类</h3>
<p>  在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>  因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>  纯虚函数语法：<code>virtual 返回值类型 函数名 (参数列表) = 0;</code></p>
<p>  当类中有了纯虚函数，这个类也称为<mark>抽象类</mark></p>
<p>  <strong>抽象类特点</strong></p>
<p>    无法实例化对象</p>
<p>    子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//只要有一个纯虚函数，这个类成为抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//无论堆区还是栈区，都无法实例化对象</span></span><br><span class="line">	<span class="comment">//Base b;</span></span><br><span class="line">	<span class="comment">//new Base;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//抽象类的子类必须重写父类中的纯虚函数，否则也属于抽象类，无法实例化对象</span></span><br><span class="line">	<span class="comment">//Son s;</span></span><br><span class="line"></span><br><span class="line">	Base* b = <span class="keyword">new</span> Son2;</span><br><span class="line">	b-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态案例二-制作饮品">多态案例二-制作饮品</h3>
<p>  案例描述</p>
<p>    制作饮品的大致流程为：煮水、冲泡、导入杯中、加入辅料</p>
<p>  利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><img src="/images/c++/c++_2/c++_2_3.png" alt=""></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">makeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮水&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;倒咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加糖&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮矿泉水&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;倒茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加枸杞&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(AbstractDrinking* a)</span> </span>&#123;</span><br><span class="line">	a-&gt;<span class="built_in">makeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">doWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	<span class="built_in">doWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚析构和纯虚析构">虚析构和纯虚析构</h3>
<p>  多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>  解决方式：</p>
<p>    将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>  虚析构和纯虚析构共性：</p>
<p>    可以解决父类指针释放子类对象</p>
<p>    都需要有具体的函数实现</p>
<p>  虚析构和纯虚析构区别：</p>
<p>    如果是纯虚析构，该类属于抽象类，无法实例化对象</p>
<p>  虚析构语法：<code>virtual ~类名()&#123;&#125;</code></p>
<p>  纯虚析构语法：<code>virtual ~类名()&#123;&#125; = 0;</code></p>
<p>         <code>类名::~类名()&#123;&#125;</code></p>
<p>  虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>  如果子类中没有堆区数据，可以不写为虚析构或者纯虚析构</p>
<p>  拥有纯虚析构函数的类也属于抽象类</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用虚析构可以解决 父类指针释放子类对象时不干净的问题</span></span><br><span class="line">	<span class="comment">//virtual ~Animal() &#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal析构函数&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//纯虚析构</span></span><br><span class="line">	<span class="comment">//需要声明也需要实现</span></span><br><span class="line">	<span class="comment">//有了纯虚析构之后，这个类也属于抽象类，无法实例化对象</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal :: ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal纯虚析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (m_name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Cat析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">delete</span> m_name;</span><br><span class="line">			m_name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_name &lt;&lt; <span class="string">&quot;猫叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string* m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Animal* a = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	a-&gt;<span class="built_in">speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//父类指针在析构的时候 不会调用子类中析构函数 导致子类中如果有堆区属性 出现内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态案例三-电脑组装">多态案例三-电脑组装</h3>
<p>  <strong>案例描述</strong>：</p>
<p>    电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>    将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Inter厂商和Lenovo厂商</p>
<p>    创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>    测试时组装三台不同的电脑进行工作</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(Cpu* m_Cpu, VideoCard* m_vc, Memory* m_mem) &#123;</span><br><span class="line">		cpu = m_Cpu;</span><br><span class="line">		vc = m_vc;</span><br><span class="line">		mem = m_mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line">		vc-&gt;<span class="built_in">display</span>();</span><br><span class="line">		mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Computer</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (cpu != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> cpu;</span><br><span class="line">			cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (vc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> vc;</span><br><span class="line">			vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mem != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> mem;</span><br><span class="line">			mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Cpu* cpu;</span><br><span class="line">	VideoCard* vc;</span><br><span class="line">	Memory* mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterCPU</span> : <span class="keyword">public</span> Cpu &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Inter Cpu&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterVideoCard</span> : <span class="keyword">public</span> VideoCard &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Inter VideoCard&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterMemory</span> : <span class="keyword">public</span> Memory &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Inter Memory&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> : <span class="keyword">public</span> Cpu &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo Cpu&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> : <span class="keyword">public</span> VideoCard &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo VideoCard&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> : <span class="keyword">public</span> Memory &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo Memory&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cpu* inter = <span class="keyword">new</span> InterCPU;</span><br><span class="line">	VideoCard* card = <span class="keyword">new</span> InterVideoCard;</span><br><span class="line">	Memory* mem = <span class="keyword">new</span> InterMemory;</span><br><span class="line">	Computer* c1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(inter, card, mem);</span><br><span class="line">	c1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> c1;</span><br><span class="line"></span><br><span class="line">	Computer* c2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">	c2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> c2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>文件操作</h1>
<p>  程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>  通过<strong>文件可以将数据持久化</strong></p>
<p>  C++中对文件操作需要包含头文件<mark>&lt;fstream&gt;</mark></p>
<p>  文件类型分为两种</p>
<p>    <strong>文本文件</strong>：文件以文本的<strong>ASCII码</strong>形式存储在计算机中</p>
<p>    <strong>二进制文件</strong>：文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</p>
<p>  操作文件的三大类</p>
<p>    ofstream：写操作</p>
<p>    ifstream：读操作</p>
<p>    fstream：读写操作</p>
<h2 id="文本文件">文本文件</h2>
<h3 id="写文件">写文件</h3>
<p>  写文件步骤如下：</p>
<p>    包含头文件 #include &lt;fstream&gt;</p>
<p>    创建流对象 ofstream ofs;</p>
<p>    打开文件 ofs.open(“文件路径”,打开方式);</p>
<p>    写数据 ofs &lt;&lt; “写入的数据”;</p>
<p>    关闭文件 ofs.close();</p>
<p>  文件打开方式</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::state</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody>
</table>
<p>  <strong>注意</strong>：文件打开方式可以配合使用，利用|操作符</p>
<p>  <strong>例如</strong>：用二进制方式写文件 <code>ios::binary | ios::out</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读文件">读文件</h3>
<p>  读文件与写文件步骤相似，但是读取方式相对较多</p>
<p>  读文件步骤如下：</p>
<p>    包含头文件 #include &lt;fstream&gt;</p>
<p>    创建流对象 ifstream ifs;</p>
<p>    打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式);</p>
<p>    读数据 四种方式读取</p>
<p>    关闭文件 ifs.close();</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种读取方法</span></span><br><span class="line">	<span class="comment">/*char buffer[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">	while (ifs &gt;&gt; buffer) &#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种读取方法</span></span><br><span class="line">	<span class="comment">/*char buffer[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">	while (ifs.getline(buffer, sizeof(buffer))) &#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种读取方法</span></span><br><span class="line">	string buffer;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buffer)) &#123;</span><br><span class="line">		cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第四种读取方法（不常用）</span></span><br><span class="line">	<span class="comment">/*char c;</span></span><br><span class="line"><span class="comment">	while ((c = ifs.get()) != EOF) &#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制文件">二进制文件</h2>
<p>  以二进制的方式对文件进行读写操作</p>
<p>  打开方式要指定<mark>ios::binary</mark></p>
<h3 id="写文件">写文件</h3>
<p>  二进制方式写文件主要利用流对象调用成员函数write</p>
<p>  函数原型：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>  参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">	Person p = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读文件">读文件</h3>
<p>  二进制方式读文件主要利用流对象调用成员函数read</p>
<p>  函数原型：<code>istream&amp; read(char*buffer,int len);</code></p>
<p>  参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	cout &lt;&lt; p.m_Name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityShader——基础篇之UnityShader基础</title>
    <url>/2024/04/26/UnityShader%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BUnityShader%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>UnityShader基础</h1>
<h2 id="unityshader概述">UnityShader概述</h2>
<h3 id="材质和unityshader">材质和UnityShader</h3>
<p>  总的来说，在Unity中需要配合使用<strong>材质</strong>(<strong>Material</strong>)和 Unity Shader 才能达到需要的效果，常见流程为：</p>
<ul>
<li>创建一个材质</li>
<li>创建一个 Unity Shader，并把它赋给上一步中创建的材质</li>
<li>把材质赋给需要渲染的对象</li>
<li>在材质面板中调整 Unity Shader 的属性，以得到满意的效果</li>
</ul>
<p><img src="/images/Shader/Shader_02/Shader_02_01.png" alt=""></p>
<p>  Unity Shader定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等）</p>
<p>  材质允许调节这些属性，将其最终赋给对应的模型</p>
<h3 id="unity-中的材质">Unity 中的材质</h3>
<p>  Unity 中的材质需要结合一个 GameObject 的 Mesh 或者 Particle systems 组件来工作，它决定了游戏对象看起来是什么样子的（也需要 Unity Shader 的配合）</p>
<p>  创建一个新的材质，可以在 Unity 的菜单栏中选择 Assets -&gt; Create -&gt; Material 来创建，也可以直接在 Project 视图中右击 -&gt; Create -&gt; Material 来创建</p>
<p>  当创建了一个材质后，就可以把它赋值给一个对象，这可以通过把材质直接拖拽到 Scene 视图中的对象来实现，或者在该对象的 Mesh Renderer 组件中直接赋值，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_02.png" alt=""></p>
<p>  在 Unity 的 2020.x 版本中，默认情况下，一个新建的材质将使用Unity内置的 Standard Shader，这是一种基于物理渲染的着色器</p>
<p>  Unity的材质和许多建模软件（如 Cinema 4D、Maya 等）中提供的材质工鞥呢类似，他们都提供了一个面板来调整材质的各个参数，这种可视化的方法使得开发者不再需要自行在代码中设置和改变所需的各种参数，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_03.png" alt=""></p>
<h3 id="unity-中的-shader">Unity 中的 Shader</h3>
<p>  创建一个新的 Unity Shader，可以在 Unity 的菜单栏中选择 Assets -&gt; Create -&gt; Shader 来创建，也可以直接在 Project 视图中右击 -&gt; Create -&gt; Shader 来创建，Unity 一共提供了5种 Unity Shader 模板供选择 —— Shader Surface Shader, Unlit Shader, Image Effect Shader, Compute Shader 以及 Ray Tracing Shader。</p>
<p>  Standard Surface Shader 会产生一个包含了标准光照模型的表面着色器模板</p>
<p>  Unlit Shader会产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器</p>
<p>  Image Effect Shader 为实现各种屏幕后处理效果提供了一个基本模板</p>
<p>  Compute Shader 会产生一种特殊的 Shader 文件，这类 Shader 旨在利用 GPU 的并行性来进行一些常规渲染流水线无关的计算</p>
<p>  Ray Tracing Shader是一种用于Unity中的实时光线追踪的Shader。光线追踪是一种通过追踪从相机到场景中各个像素的光线的技术，以模拟光线在真实世界中的传播和反射。Ray Tracing Shader可以帮助开发者实现更加逼真的光影效果，包括实时反射、折射、阴影和环境光照等效果。</p>
<br/>
<p>  一个单独的 Unity Shader 是无法发挥任何作用的，它必须和材质结合起来。</p>
<p>  所以，可以在材质面板最上方的下拉菜单中选择需要使用的 Unity Shader，当选择完毕后，材质面板中就会出现该 Unity Shader 可用的各种属性。这些属性可以是颜色、纹理、浮点数、滑动条（限制了范围的浮点数）、向量等</p>
<p>  当把材质赋给场景中的一个对象，就可以看到调整属性所发生的视觉变化</p>
<br/>
<p>  Unity Shader本质上就是一个文本文件，和 Unity 中的很多外部文件类似，Unity Shader 也有<strong>导入设置</strong>(Import Settings)面板，在 <strong>Project</strong>视图中选中某个 Unity Shader即可看到，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_04.png" alt=""></p>
<p>  在该面板上，可以在 <strong>Default Maps</strong> 中指定该 Unity Shader 使用的默认纹理。当任何材质第一次使用该 Unity Shader 时，这些纹理就会自动被赋予到相应的属性上。在下方的面板中，Unity 会显示出和该 Unity 相关的信息，例如它是否是一个表面着色器（Surface Shader）、是否是一个固定函数着色器（Fixed Function Shader）等，还有一些信息是和在 Unity Shader 中的标签设置有关，例如是否会投射阴影、使用的渲染队列、LOD值等</p>
<p>  对于表面着色器来说，可以通过单击 Show generated code 按钮来打开一个新的文件，在该文件里将显示 Unity 在背后为该表面着色器生成的顶点/片元着色器。这可以方便对这些生成的代码进行修改（需要复制到一个新的 Unity Shader 中才可保存）和研究</p>
<p>  如果 Unity Shader 使一个固定函数着色器，在 Fixed function 的后面也会出现一个 Show generated code 按钮，来查看该固定函数着色器生成的顶点/片元着色器。Compile and show code 下拉列表可以让开发者检查该 Unity Shader 针对不同图像编程接口（例如 OpenGL、D3D9、D3D11等）最终编译成的 Shader 代码，如图所示：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_05.png" alt=""></p>
<p>  直接单击该按钮可以查看生成的底层的汇编指令。可以利用这些代码来分析和优化着色器</p>
<p>  除此之外，Unity Shader 的导入面板还可以方便地查看其使用的渲染队列（Reder queue）、是否关闭批处理（Disable batching）、属性列表（Properties）等信息</p>
<h2 id="unity-shader-的基础：shaderlab">Unity Shader 的基础：ShaderLab</h2>
<h3 id="什么是-shaderlab">什么是 ShaderLab</h3>
<p>  Unity Shader 是 Unity 为研发者提供的高层记得渲染抽象层，Unity 希望以这种方式来让开发者更加轻松的控制渲染，见下图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_06.png" alt=""></p>
<p>  在 Unity 中，所有的 Unity Shader 都是使用 ShaderLab 来编写的</p>
<p>  ShaderLab 是 Unity 编写 Unity Shader 的一种说明性语言，它使用了一些嵌套在花括号内部的**语义&amp;&amp;（<strong>syntax</strong>）来描述一个 Unity Shader 文件的结构，这些结构包含了许多渲染所需的数据，例如 Properties 语句块中定义了着色器所需的各种属性，这些属性将会出现在材质面板中</p>
<p>  从设计上来说，ShaderLab 类似于 CgFX 和 Direct3D Effects（FX）语言，他们都定义了要显示一个材质所需的所有东西，而<strong>不仅仅是着色器代码</strong></p>
<p>  一个 Unity Shader 的基础结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        //属性</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        //显卡A使用的子着色器</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        //显卡B使用的子着色器</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unityshader的结构">UnityShader的结构</h2>
<h3 id="给shader起名字">给Shader起名字</h3>
<p>  每个Unity Shader文件的第一行都需要通过 Shader 语义来制定该 Unity Shader 的名字，这个名字由一个字符串来定义</p>
<p>  当为材质选择使用的 Unity Shader 时，这些名称就会出现在材质面板的下拉列表里，通过在字符串中添加斜杠(&quot;/&quot;)，可以控制 Unity Shader 在材质面板中出现的位置，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/001Shader&quot;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  那么，这个 Unity Shader在材质面板中的位置就是：Shader -&gt; Unlit -&gt; 001Shader，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_07.png" alt=""></p>
<h3 id="材质和-unity-shader-的桥梁：properties">材质和 Unity Shader 的桥梁：Properties</h3>
<p>  Properties语义块中包含了一系列<strong>属性</strong>(<strong>property</strong>)，这些属性将会出现在材质面板中</p>
<p>  Properties语义块的定义通常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">    Name(&quot;display name&quot;,PropertyType) = DefaultValue</span><br><span class="line">    Name(&quot;display name&quot;,PropertyType) = DefaultValue</span><br><span class="line">    //更多属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  开发者声明这些属性是为了在材质面板中能够方便的调整各种材质属性</p>
<p>  如果需要在 Shader 中访问它们，就需要使用每个属性的<strong>名字</strong>(<strong>Name</strong>)，Unity中，这些属性的名字通常由一个下划线开始，<strong>显示的名称</strong>(<strong>display name</strong>)则是出现在材质面板上的名字，需要为每个属性指定它的<strong>类型</strong>(<strong>PropertyType</strong>)，常见的属性如表：</p>
<table>
<thead>
<tr>
<th>属性类型</th>
<th>默认值的定义语法</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int</td>
<td>number</td>
<td>_Int(“Int”,Int) = 2</td>
</tr>
<tr>
<td>Float</td>
<td>number</td>
<td>_Float(“Float”,Float) = 1.5</td>
</tr>
<tr>
<td>Range(min,max)</td>
<td>number</td>
<td>_Range(“Range”,Range(0.0,5.0) = 3.0</td>
</tr>
<tr>
<td>Color</td>
<td>(number,number,number,number)</td>
<td>_Color(“Color”,Color) = (1,1,1,1)</td>
</tr>
<tr>
<td>Vector</td>
<td>(number,number,number,number)</td>
<td>_Verctor(“Vector”,Vector) = (2,3,6,1)</td>
</tr>
<tr>
<td>2D</td>
<td>“defaulttexture”{}</td>
<td>_2D(“2D”,2D) = “”{}</td>
</tr>
<tr>
<td>Cube</td>
<td>“defaulttexture”{}</td>
<td>_Cube(“Cube”,Cube) = “white”{}</td>
</tr>
<tr>
<td>3D</td>
<td>“defaulttexture”{}</td>
<td>_3D(“3D”,3D) = “black”</td>
</tr>
</tbody>
</table>
<p>  除此之外，还需要为每个属性指定一个默认值，在第一次把该 Unity Shader 赋给某个素材时，菜盒子面板显示的就是这些默认值</p>
<p>    对于 <strong>Int、Float、Range</strong> ，这些数字类型的属性，其默认值就是一个单独的数；</p>
<p>    对于 <strong>Color</strong> 和 <strong>Vector</strong> 这类属性，默认值是用圆括号包围的一个四维向量；</p>
<p>    对于 <strong>2D、Cube、3D</strong> 这3种纹理类型，默认值的类型稍微复杂，他们的默认值是通过一个字符串后跟一个花括号来指定的，其中，字符串要么是空的，要么是内置的纹理名称，如 “white”“black”“gray” 或者 “bump”。或括号的用处原本是用于制定一些纹理属性的。</p>
<p>  如果需要控制固定管线的纹理坐标的生成，就需要再顶点着色器中编写计算相应纹理坐标的代码</p>
<p>  如下方的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unlit/001Shader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Int(&quot;Int&quot;,int) = 2</span><br><span class="line">        _Float(&quot;Float&quot;,float) = 1.5</span><br><span class="line">        _Range(&quot;Range&quot;,range(0.0,5.0)) = 1.0</span><br><span class="line">        _Color(&quot;Color&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _Vector(&quot;Vector&quot;,Vector) = (2,3,6,1)</span><br><span class="line">        _2D(&quot;2D&quot;,2D) = &quot;&quot;&#123;&#125;</span><br><span class="line">        _Cube(&quot;Cube&quot;,Cube) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _3D(&quot;3D&quot;,3D) = &quot;black&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	FallBack &quot;diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  材质面板中的显示结果，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_08.png" alt=""></p>
<p>  Unity 允许重载默认的材质编辑面板，以提供更多自定义的数据类型</p>
<p>  为了在 Unity 中可以访问到这些属性，需要在 Cg 代码片中定义和这些属性类型相匹配的变量，需要说明的是，即使不在 Properties 语义块中生命这些属性，也可以直接在 Cg 代码片中定义变量</p>
<p>  此时，可以通过脚本向 Shader 中换地这些属性，因此，Properties与一块的作用仅仅是为了让这些属性可以出现在材质面板中</p>
<h3 id="subshader">SubShader</h3>
<p>  每一个 Unity Shader 文件可以包含多个 SubShader 语义块，但最少要有一个。</p>
<p>    当 Unity 需要加载这个 Unity Shader 时，Unity 会扫描所有的 SubShader 语义块，然后选择第一个能够在目标平台运行的SubShader</p>
<p>    如果都不支持的话，Unity 就会使用 Fallback 语义指定的 Unity Shader</p>
<p>  Unity 提供这种语义的原因在于，不同的显卡具有不同的能力。例如：一些旧的显卡仅能支持一定数目的操作指令，而一些更高级的显卡可以支持更多的指令数</p>
<p>  那么就希望在旧的显卡上使用计算复杂度低的着色器，在高级的显卡上使用计算复杂度较高的着色器，以便提供更出色的画面</p>
<p>  SubShader 语义块中包含的定义通常如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">    //可选</span><br><span class="line">    Tags</span><br><span class="line"></span><br><span class="line">    //可选</span><br><span class="line">    RenderSetup</span><br><span class="line"></span><br><span class="line">    Pass&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //Other Passes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  SubShader 中定义了一系列 Pass 以及可选的<strong>状态</strong>(RenderSetup)和<strong>标签</strong>(Tags)设置。</p>
<p>  每个 Pass 定义了一个完整的渲染流程，但如果 Pass 数目过多，往往会造成渲染性能的下降</p>
<p>  因此，应该尽量使用最小数目的 Pass，状态和标签同样可以在 Pass 声明，不同的是，SubShader 中的一些标签是特定的</p>
<p>  也就是说，这些标签设置和 Pass 中使用的标签是不一样的，对于状态设置来说，使用的语法是相同的</p>
<p>  但是如果在 SubShader 进行了这些设置，呢么将会用于所有的 Pass</p>
<p>  <strong>状态设置</strong></p>
<p>  ShaderLab 提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等</p>
<p>  ShaderLab 中常见的渲染状态设置选项如下表：</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>设置指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cull</td>
<td>Cull Back|Front|Off</td>
<td>设置剔除模式：剔除背面/正面/关闭剔除</td>
</tr>
<tr>
<td>ZTest</td>
<td>ZTest Less Greater|LEqqual|GEqual|Equal|NotEqual|Always</td>
<td>设置深度测试时使用的函数</td>
</tr>
<tr>
<td>ZWrite</td>
<td>ZWrite On|Off</td>
<td>开启/关闭深度写入</td>
</tr>
<tr>
<td>Blend</td>
<td>Blend SrcFactor DstFactor</td>
<td>开启并设置混合模式</td>
</tr>
</tbody>
</table>
<p>  当在 SubShader 块中设置了上述渲染状态时，将会应用到所有的 Pass，如果不想这样（如在双面渲染中，希望第一个 Pass 中剔除正面来对背面进行渲染，在第二个 Pass 中剔除背面来对正面进行渲染），可以在 Pass 语义块中单独进行上面的设置</p>
<p>  <strong>SubShader</strong>的标签</p>
<p>  SubShader 的标签（Tags）是一个<strong>键值对</strong>（Key/Value Pair），它的键和值都是字符串类型，这些键值对是 SubShader 和渲染引擎之间的沟通桥梁。它们用来告诉 Unity 的渲染引擎希望怎样以及何时渲染这个对象：</p>
<p>  标签的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tags&#123;&quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>  SubShader 的标签快支持的标签类型如表：</p>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Queue</td>
<td>控制渲染顺序，指定该物体属于哪一个渲染队列，通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染，也可以自定义使用的渲染队列来控制物体的渲染顺序</td>
<td>Tags{“Queue” = “Transparent”}</td>
</tr>
<tr>
<td>RenderTyep</td>
<td>对着色器进行分类，例如这是一个不同明德着色器，或是一个透明的着色器等，这可以被用于着色器替换(Shader Replacement)功能</td>
<td>Tags{“renderType”=“Opaque”}</td>
</tr>
<tr>
<td>DisableBatching</td>
<td>一些 SubShader 在使用 Unity 的批处理功能时会出现问题，例如使用了模型空间下的坐标进行顶点动画，这是可以通过该标签来直接指明是否对该 SubShader 使用批处理</td>
<td>Tags{“DisableBatching” = “True”</td>
</tr>
<tr>
<td>ForceNoShadowCasting</td>
<td>控制使用该 SubShader 的物体是否会投射阴影</td>
<td>Tags{“ForceNoShadowCasting”=“True”</td>
</tr>
<tr>
<td>IgnoreProjector</td>
<td>如果该标签为&quot;True&quot;，那么使用该 SubShader 的物体将不会受 Projector 的影响，通常用于半透明物体</td>
<td>Tags{“IgnoreProjector”=“True”}</td>
</tr>
<tr>
<td>CanUseSpriteAtlas</td>
<td>当该 SubShader 是用于精灵(sprite)时，将该标签设置为&quot;False&quot;</td>
<td>Tags{“CanUseSpriteAtlas”=“False”</td>
</tr>
<tr>
<td>PreviewType</td>
<td>知名材质面板将如何预览改材质。默认情况下，材质将显示为一个球形，可以通过把这些标签的值设为&quot;Plane&quot;&quot;SkyBox&quot;来改变预览类型</td>
<td>Tags{“PreviewType”=“Plane”}</td>
</tr>
</tbody>
</table>
<p>  需要注意的是，上述标签仅可以在 SubShader 中声明，而不可以在 Pass 块中声明。Pass 块虽然也可以定义标签，但这些标签是不同于 SubShader 的标签类型</p>
<p>  <strong>Pass</strong> 语义块</p>
<p>  Pass 语义块包含的语义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    Name</span><br><span class="line">    Tags</span><br><span class="line">    RenderSetup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  首先，可以在 Pass 中定义该 Pass 的名称，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name &quot;MyPassName&quot;</span><br></pre></td></tr></table></figure>
<p>  通过这个名称，可以使用 ShaderLab 的 UsePass 命令来直接使用其他 UnityShader 中的 Pass，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UsePass &quot;MyShader/MYPASSNAME&quot;</span><br></pre></td></tr></table></figure>
<p>  这样可以提高代码的复用性，需要注意的是，由于 Unity 内部会把所有 Pass 的名称转换成大写字母的表示，因此，在使用 UsePass 命令时必须使用大写形式的名字</p>
<p>  其次，可以对 Pass 设置渲染状态。SubShader 的状态设置同样适用于 Pass。除了上面提到的状态设置外，在 Pass 中我们还可以使用固定管线的着色器命令</p>
<p>  Pass 同样可以设置标签，但它的标签不同于 SubShader 的标签，这些标签也是用于告诉渲染引擎希望怎样来渲染该物体</p>
<p>  Pass 中使用的标签类型如下表：</p>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>LightMode</td>
<td>定义该 Pass 在 Unity 的渲染流水线中的角色</td>
<td>Tags{“LightMode”=“ForwardBase”}</td>
</tr>
<tr>
<td>RequireOptions</td>
<td>用于指定当满足某些条件时才渲染该 Pass，它的值是一个由空格分割的字符串。</td>
<td>Tags{“RequireOptions”=“SoftVegetation”}</td>
</tr>
</tbody>
</table>
<p>  除了上面普通的 Pass 定义外，UnityShader 还支持一些特殊的 Pass，以便进行代码复用或实现更复杂的效果：</p>
<p>    <strong>UsePass</strong>：如之前提到的一样，可以使用该命令来复用其他 UnityShader 中的 Pass</p>
<p>    <strong>GrabPass</strong>：该 Pass 负责抓取屏幕并将结果存储在一张纹理中，以用于后续的 Pass 处理</p>
<h3 id="fallback">Fallback</h3>
<p>  紧跟在各个 SubShader 语义块后面的，可以是一个 Fallback 指令，它用于告诉 Unity，“如果上面所有的 SubShader 在这块显卡上都不能运行，那么就是用这个最低级的 Shader”</p>
<p>  它的语义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fallback &quot;name&quot;</span><br><span class="line">//或者</span><br><span class="line">Fallback Off</span><br></pre></td></tr></table></figure>
<p>  如上所述，可以通过一个字符串来告诉 Unity 这个“最低级的 UnityShader”是谁，也可以关闭 Fallback 功能，但一旦这么做，那么意思就是“如果一块显卡跑不了上面所有的 Shader，那就不管他了”</p>
<p>  例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fallback &quot;VertexLit&quot;</span><br></pre></td></tr></table></figure>
<p>  事实上，Fallback还会影响阴影的投射</p>
<p>  在渲染阴影纹理时，Unity 会在每个 UnityShader 中寻找一个阴影投射的 Pass，通常情况下，不需要自己专门实现一个 Pass，这是因为 Fallback 使用的内置 Shader 中包含了这样一个通用的 Pass，因此，为每个 UnityShader 正确设置 Fallback 是非常重要的</p>
<h3 id="shaderlab还有其他的语义吗">ShaderLab还有其他的语义吗</h3>
<p>  除了上述的语义，还有一些不常用到的寓意。</p>
<p>  例如：如果不满足于 Unity 内置的属性类型，想要自定义材质面板的编辑界面，就可以使用 CustomEditor 语义来拓展编辑界面。还可以使用 Category 语义来对 UnityShader 中的命令进行分组。</p>
<h2 id="unitysahder-的形式">UnitySahder 的形式</h2>
<p>  尽管 UnityShader 可以做的事情很多（例如设置渲染状态等），但其最重要的任务还是指定各种着色器所需的代码。这些着色器代码可以写在 SubShader 语义块中（表面着色器的做法），也可以写在 Pass 语义块中（顶点/片元着色器和固定函数着色器的做法）</p>
<p>  在 Unity 中，可以使用下面 3 种形式来编写 UnityShader，而不管使用哪种形式，真正意义上的 Shader 代码都需要包含在 ShaderLab 语义块中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;MyShader&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        //所需的各种属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        //真正意义上的 Shader 代码会出现在这里</span><br><span class="line">        //表面着色器&#123;Surface Shader&#125;或者</span><br><span class="line">        //顶点/片元着色器&#123;Vertex/Fragment Shader&#125;或者</span><br><span class="line">        //固定函数着色器&#123;Fixed Function Shader&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        //和上一个 SubShader 类似</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表面着色器">表面着色器</h3>
<p>  <strong>表面着色器（Surface Shader）</strong> 是 Unity 自己创造的一种着色器代码类型，他需要的代码量很少，Unity 在背后做了很多工作，渲染的代价比较大。</p>
<p>  本质上和顶点/片元着色器是一样的，当给Unity提供一个便面着色器的时候，在背后仍旧需要把它装换成对应的顶点/片元着色器</p>
<p>  它的价值在于：Unity 处理了很多光照细节，不需要去操心这些“烦人的事情”</p>
<p>  示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot;&#123;</span><br><span class="line">    SubSHader&#123;</span><br><span class="line">        Tags&#123;&quot;RenderType&quot;=&quot;Opaque&quot;&#125;</span><br><span class="line">        CGPROGAM</span><br><span class="line">        #pragma surface surf Lambert</span><br><span class="line">        struct Input&#123;</span><br><span class="line">            float4 color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        void surf(Input IN,inout SurfaceOutput o)&#123;</span><br><span class="line">            o.Albedo = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  表面着色器被定义在 SubShader 语义块（不是 Pass 语义块）中的 CGPROGRAM 和 ENDCG 之间</p>
<p>  原因是表面着色器不需要开发者关心使用多少个 Pass，每个 Pass 如何渲染等问题，Unity 会在背后做好这些事情</p>
<p>  CGPROGRAM 和 ENDCG 之间的代码是使用 Cg/HLSL 编写的，也就是说，需要把 Cg/HLSL 语言嵌套在 ShaderLab 语言中</p>
<p>  这里的 Cg/HLSL 是 Unity 经封装后提供的，它的语法和标准的 Cg/HLSL 语法几乎一样，但还是有细微的不同</p>
<h3 id="顶点-片元着色器">顶点/片元着色器</h3>
<p>  Unity 中可以使用 Cg/HLSL 语言来编写<strong>顶点/片元着色器（Vertex/Fragment Shader）</strong>。它们更加复杂，但灵活性更高</p>
<p>  示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Custom/Simple VertexFragment Shader&quot;&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #progama vetex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            float4 vert(float4 v : POSITION) : SV_POSITON&#123;</span><br><span class="line">                return mul(UNITY_MATRIX_MVP,v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag() : SV_Target&#123;</span><br><span class="line">                return fixed4(1.0,0.0,0.0,1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  顶点/片元着色器的代码需要定义在 CGPROGRAM 和 ENDCG 之间，不同的是，顶点/片元着色器是写在 Pass 语义块内，而非 SubShader内的</p>
<p>  这样的原因是，需要自己定义每个 Pass 需要使用的 Shader 代码，虽然可能需要编写更多的代码，但好处是灵活性很高，更重要的是，可以空时渲染的实现细节</p>
<h3 id="固定函数着色器">固定函数着色器</h3>
<p>  对于一些较旧的设备（其GPU仅支持 DirectX 7.0、OpenGL 1.5 或 OpenGL ES 1.1），它们不支持可编程管线着色器，因此，这时候就需要使用<strong>固定函数着色器（Fixed Function Shader）</strong> 来完成渲染。这些着色器网网址可以完成一个非常简单的效果</p>
<p>  示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Tutorial/Basic&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color(&quot;Main Color&quot;,Color&#125; = &#123;1,0.5,0.5,1&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Material&#123;</span><br><span class="line">                Diffuse [_Color]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  固定着色器的代码被定义在 Pass 语义块中，这些代码相当于 Pass 中的一些渲染设置</p>
<p>  对于固定函数着色器来说，需要完全使用 ShaderLab 的语法（使用 ShaderLab 的渲染设置命令）来编写，而不是使用 Cg/HLSL</p>
<p>  由于现在绝大多数 GPU 都支持可编程的渲染管线，这种编程方式已经被逐渐抛弃，在新版的 Unity 中，所有固定函数着色器都会在背后被 Unity 编译成对应的顶点/片元着色器</p>
<h3 id="选择哪种-unityshader-形式">选择哪种 UnityShader 形式</h3>
<p>  如果有非常明确的需求必须要使用固定函数着色器，否则使用可编程管线的着色器，即表面着色器或顶点/片元着色器</p>
<p>  如果要和各种光源打交道，可能更需要使用表面着色器，但需要小新在移动平台中的性能表现</p>
<p>  如果需要使用的光照数目非常少，那么使用顶点/片元着色器使一个更好的选择</p>
<p>  如果有很多自定义的渲染效果，使用顶点/片元着色器</p>
<h2 id="其他的一些问题">其他的一些问题</h2>
<h3 id="unityshader-真正的shader">UnityShader != 真正的Shader</h3>
<p>  尽管UnityShader翻译过来就是Unity着色器，在Unity里，UnityShader实际上指的就是一个ShaderLab文件——硬盘上以.shader作为文件后缀的一种文件</p>
<p>  在UnityShader里，可以做的事情远多于一个传统意义上的Shader</p>
<p>    传统的Shader中，仅可以编写特定类型的Shader,例如顶点着色器、片元着色器等，在UnityShader中，可以在同一个文件里同时包含需要的顶点着色器和片元着色器代码</p>
<p>    在传统的Shader中，无法设置一些渲染设置，例如是否开启混合、深度测试等，这些是开发者在另外的代码中自行设置的。而在UnityShader中，通过一行特定的指令就可以完成这些设置</p>
<p>    在传统的Shader中，我们需要编写荣昌的代码来设置着色器的输入和输出，要小心的处理这些输入输出的位置对应关系等。而在UnityShader中，只需要在特定的语句块中生命一些属性，就可以依靠材质来方便的改变这些属性。而且对于模型自带的数据（如定点位置、纹理坐标、法线等），UnityShader也提供了直接访问的方法，不需要开发者自行编码来传给着色器</p>
<p>  UnityShader出了上述这些优点外，也有一些缺点。</p>
<p>    由于UnityShader的高度封装性，可以编写的Shader类型和语法都被限制了。对于一些类型的Shader，例如曲面细分着色器（Tessellation Shader）、几何着色器（Geometry Shader）等，Unity的支持就相对差一些。例如：Unity 4.x 仅在 DirectX 11平台下提供曲面细分着色器、几何着色器的相关功能，而对于OpenGL平台则没有这些支持。除此之外，一些高级的Shader语法UnityShader也不支持</p>
<p>  可以说，UnityShader提供了一种让开发者同时控制渲染流水线中多个阶段的一种方式，不仅仅是提供Shader代码。作为开发者而言，绝大部分时候只需要和UnityShader打交道，而不需要关心渲染引擎底层的实现细节</p>
<h3 id="unityshader和cg-hlsl之间的关系">UnityShader和Cg/HLSL之间的关系</h3>
<p>  UnityShader是用ShaderLab语言编写的，但对于表面着色器和顶点/片元着色器，可以在ShaderLab内部嵌套Cg/HLSL语言来编写这些着色器代码。这些Cg/HLSL代码是嵌套在 CGPROGRAM 和 ENDCG 之间的。由于Cg和DX9风格的HLSL从写法上来说几乎是同一种语言，因此在Unity里Cg和HLSL是等价的。可以说，Cg/HLSL代码是区别于ShaderLab的另一个世界</p>
<p>  通常，Cg的代码片段是位于Pass语义块内部的，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    //Pass的标签和状态设置</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    //编译指令，例如：</span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    //Cg代码</span><br><span class="line"></span><br><span class="line">    ENDCG</span><br><span class="line">    //其他一些设置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在提供给编程人员这些便利的背后，Unity编辑器会把这些Cg片段编译成低级语言，如汇编语言等。同城，Unity会自动把这些诶Cg片段编译到所有相关平台（这里的平台是指不同的渲染平台，如Dirext3D 9、OpenGL、Direct3D 11、OpenGL ES等）上。这些编译过程比较复杂，Unity会使用不同的编译器来吧Cg转换成对应平台的代码。这样就不会在切换平台时再重新编译，而且如果代码在某些平台上发生错误就可以立刻得到错误信息。</p>
<p>  可以在UnityShader的导入设置面板上查看这些编译后的代码，查看这些代码有助于进行Debug或优化等</p>
<p>  如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_09.png" alt="在UnityShader的导入设置面板中可以通过Compile and show code按钮来查看Unity对Cg片段编译后的代码，通过单击Compile and show按钮右侧的倒三角可以打开下拉菜单，在这个下拉菜单中可以选择变异的平台种类，如职位当前的显卡设备编译特定的汇编代码，或为所有的平台编译汇编代码，也可以自定义选择编译到哪些平台上"></p>
<p>  但当发布游戏的时候，游戏数据文件中质保函目标平台需要的编译代码，而那些在目标平台上不需要的代码部分就会被移除。例如，当发布到Mac OS X平台上时，DirectX对应的代码部分就会被移除。</p>
]]></content>
      <categories>
        <category>UnityShader</category>
      </categories>
      <tags>
        <tag>UnityShader</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityShader——基础篇之学习Shader所需的数学基础</title>
    <url>/2024/06/24/UnityShader%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%AD%A6%E4%B9%A0Shader%E6%89%80%E9%9C%80%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>学习Shder所需的数学基础</h1>
<h2 id="笛卡尔坐标系">笛卡尔坐标系</h2>
<p>  游戏制作中，使用数学绝大部分是为了计算位置、距离和角度等变量。而这些计算大部分都是在<strong>笛卡尔坐标系(Cartesian Coordinate System）</strong> 下进行的。</p>
<h3 id="二维笛卡尔坐标系">二维笛卡尔坐标系</h3>
<p>  一个二维的笛卡尔坐标系包含了两个部分的信息：</p>
<p>    一个特殊的位置，即原点，它是整个坐标系的中心；</p>
<p>    两条过原点的相互垂直的矢量，即 x 轴和 y 轴。这些坐标轴也被称为是该坐标系的基矢量</p>
<p><img src="/images/Shader/Shader_03/Shader_03_01.png" alt="一个二维笛卡尔坐标系"></p>
<p>  虽然上图中x轴和y轴分别是水平和垂直方向的，但这并不是必须的。虽然图中的x轴指向右、y轴指向上，但这也并不是必须的。</p>
<p>  有了这个坐标系就可以精确地定位一个点的位置。</p>
<h3 id="三维笛卡尔坐标系">三维笛卡尔坐标系</h3>
<p>  在三维笛卡尔坐标系中，需要定义3个坐标轴和一个原点，如下图所示</p>
<p><img src="/images/Shader/Shader_03/Shader_03_02.png" alt="一个三维笛卡尔坐标系"></p>
<p>  这3个坐标轴也被称为是该坐标系的<strong>基矢量（basis vector）</strong>。通常情况下，这3个坐标轴之间是相互垂直的，且长度为1，这样的基矢量被称为<strong>标准正交基（orthonormal basis）</strong>，但这并不是必须的。例如在一些坐标系中坐标轴之间相互垂直但长度不为1，这样的基矢量被称为<strong>正交基（orthogonal basis）</strong>。</p>
<p>  和二维笛卡尔坐标系类似，三维笛卡尔坐标系中的坐标轴方向也不是固定的。这种不同导致了两种不同种类的坐标系：<strong>左手坐标系（left-handed coordinate space）</strong> 和<strong>右手坐标系（right-handed coordinate space）</strong>。</p>
<h3 id="左手坐标系和右手坐标系">左手坐标系和右手坐标系</h3>
<p>  三维笛卡尔坐标系区分左手坐标系和右手坐标系而二维笛卡尔坐标系不区分的原因</p>
<p>    在二维笛卡尔坐标系中，x轴和y轴的指向虽然可能不同，但总可以通过一些旋转操作来使它们的坐标轴指向相同，从某种意义上来说，所有的二维笛卡尔坐标系都是等价的</p>
<p>    对于三维笛卡尔坐标系，靠旋转有时并不能使两个不同朝向的坐标系重合。也就是说，三维笛卡尔坐标系并不都是等价的。因此，就出现了两种不同的三维坐标系——左手坐标系和右手坐标系。如果两个坐标系具有相同的<strong>旋向性（handedness）</strong>，那么就可以通过旋转的方法来让他们的坐标轴指向重合。但是如果它们具有不同的旋向性，么么就无法达到重合的目的</p>
<p>  叫左手和右手坐标系的原因</p>
<p>    可以利用双手判断一个坐标系的旋向性，伸出左手，用使之和大拇指摆出一个“L”的手势，并且让食指向上，大拇指指向右，伸出中指，指向前方，这就是左手坐标系。大拇指、食指、中指分别对应了+x，+y，+z轴的方向。</p>
<p><img src="/images/Shader/Shader_03/Shader_03_03.png" alt="左手坐标系"></p>
<p><img src="/images/Shader/Shader_03/Shader_03_04.png" alt="右手坐标系"></p>
<p>  另外一个确定左手还是右手的坐标系的方法是，判断<strong>前向（forward）</strong> 的方向，伸直右手，右手方向就是x轴的正向，而头顶向上的方向就是y轴的正向。这时，如果正前方的方向是z轴的正向，那么本身所在的坐标系就是一个左手坐标系；反之则是右手坐标系</p>
<p>  出了坐标轴朝向不同，左手坐标系和右手坐标系对于正向旋转的定义也不同，即在初高中物理中学到的<strong>左手法则（left-hand rule）</strong> 和<strong>右手法则（right-hand rule）</strong>。假设在空间中有一条直线，还有一个点，希望把这个点以直线为旋转轴旋转某个角度，需要找一个旋转方向。这意味着，需要在坐标系中定义一个旋转的正方向，在左手坐标系中，这个旋转正方向是由左手法则定义的，而在右手坐标系中则是由右手法则定义的。</p>
<p><img src="/images/Shader/Shader_03/Shader_03_05.png" alt="用左手法则和右手法则来判断旋转正方向"></p>
<p>  图中可以看出，左手坐标系中，旋转的正方向是顺时针的，在右手坐标系中，旋转正方向是逆时针的</p>
<p>  左右手坐标系之间是可以进行相互转换的。最简单的办法就是把其中一个轴反转并保持其他两个轴不变。</p>
<p>  对于开发者来说，使用左右手坐标系都是可以的，它们之间并没有优劣之分。无论使用哪种坐标系，绝大多数情况下并不会影响底层的数学运算，而只是在映射到视觉上时会有差别</p>
<p>  这是因为，一个点或者旋转在空间内来说是绝对的。在数学的世界中，需要使用一种数学模型来准确描述它们，这个模型就是坐标系。一旦有了坐标系，每个点的位置就不再是绝对的，而是相对于这个坐标系来说的。这种相对关系导致，即便从数学表示上来说两种表示方式完全一样，但从视觉上来说是不一样的</p>
<p>  为了达到相同的视觉效果，左右手的坐标系在z轴上的移动以及旋转方向是不同的，如果使用相同的数学运算，那么的得到的视觉效果就是不一样的。因此，如果需要从左手坐标系迁移到右手坐标系，并且保持视觉上的不变，就需要进行一些转换</p>
<h3 id="unity使用的坐标系">Unity使用的坐标系</h3>
<p>  对于一个需要可视化虚拟的三维世界的应用（如Unity）来说，他的设计者就需要进行一个选择。对于模型空间和世界空间，Unity使用的是左手坐标系，这可以从Scene视图的坐标轴显示看出来</p>
<p><img src="/images/Shader/Shader_03/Shader_03_06.png" alt="在模型空间和世界空间中，Unity使用的是左手坐标系。图中，正方体的坐标轴显示了它在模型空间中的3个坐标轴（红色为x轴，绿色是y轴，蓝色为z轴）"></p>
<p>  这意味着，在模型空间中，一个物体的右侧（right）、上侧（up）、和前侧（forward）分别对应了x轴，y轴和z轴</p>
<p>  但是对于观察空间来说，Unity使用的是右手坐标系。观察空间，通俗来讲就是以摄像机为原点的坐标系。在这个坐标系中，摄像机的前向是z轴的负方向，这与在模型空间中和世界空间中的定义相反。也就是说，z轴坐标的减少意味着场景深度的增加</p>
<p><img src="/images/Shader/Shader_03/Shader_03_07.png" alt="在Unity中，观察空间使用的是右手坐标系，摄像机的前向是z轴的负方向，z轴越小，物体的深度越大，离摄像机越远"></p>
<h2 id="点和矢量">点和矢量</h2>
<p>  <strong>点（point）</strong> 是n维空间（游戏中主要使用二维和三维空间）中的一个位置，他没有大小、宽度这类概念。在笛卡尔坐标系中，可以使用2个或3个实体来表示一个点的坐标，如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>P</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>P</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P = (P_x,P_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，表示二维空间的点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>P</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>P</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>P</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P = (P_x,P_y,P_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示三维空间中的点</p>
<p>  <strong>矢量（vector，也被称为向量）</strong> 的定义则复杂一些。矢量存在的意义更多是为了和<strong>标量（scalar）</strong> 区分开来。通常来讲，矢量是指n维空间中的一种包含了<strong>模（magnitude）</strong> 和<strong>方向（direction）</strong> 的<strong>有向线段</strong>，二标量只有模没有方向。</p>
<p>  具体来说</p>
<p>    矢量的模指的是这个矢量的长度。一个矢量的长度可以使任意的非负数</p>
<p>    矢量的方向则描述了这个矢量在空间中的指向</p>
<p>  矢量的表示方法和点类似。可以使用<strong>v</strong> = (x,y)来表示二维矢量，用<strong>v</strong> = (x,y,z)来表示三维矢量，用<strong>v</strong> = (x,y,z,w)来表示四维矢量</p>
<p>  一个矢量通常由一个箭头来表示，如图</p>
<p><img src="/images/Shader/Shader_03/Shader_03_08.png" alt="一个二维向量以及它的头和尾"></p>
<p>  矢量的<strong>头（head）</strong> 指的是它的箭头所在的端点处，而<strong>尾（tail）</strong> 指的是另一个端点处</p>
<p>  矢量要放在哪里？</p>
<p>    通常，矢量被用于表示相对于某个点的<strong>偏移（displacement）</strong>，也就是说它是一个相对量。只要矢量的模和方向保持不变，无论放在哪里，都是同一个矢量</p>
<h3 id="点和矢量的区别">点和矢量的区别</h3>
<p>  点是一个没有大小之分的空间中的位置，矢量是一个有模和方向但没有位置的量，从这点看，点和矢量具有不同的意义。但是，从表示方式上二者非常相似</p>
<p>  适量通常用于描述偏移量，因此，他们可以用于描述相对位置，即一个点对于另一个点的位置，此时矢量的尾是一个位置，那么矢量的头就可以表示另一个位置。而一个点可以用于指定空间中的一个位置（即相对于原点的位置）。如果把矢量的尾固定在坐标原点，那么这个矢量的表示就和点的表示重合了，如图</p>
<p><img src="/images/Shader/Shader_03/Shader_03_09.png" alt="点和矢量之间的关系"></p>
<p>  区分点和矢量之间的不同是非常重要的。如果一定要给它们之间建立一个联系，可以认为，每个点都可以表示成一个从原点出发的矢量。</p>
<h3 id="矢量运算">矢量运算</h3>
<h4 id="矢量和标量乘法-除法">矢量和标量乘法/除法</h4>
<p>  公式非常简单，只需要把矢量的每个分量和标量相乘即可：</p>
<p>  k<strong>v</strong> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><msub><mi>v</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>k</mi><msub><mi>v</mi><mi>y</mi></msub><mo separator="true">,</mo><mi>k</mi><msub><mi>v</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(kv_x,kv_y,kv_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>  类似的，一个矢量也可以被一个非零的标量除，这等同于和这个标量的倒数相乘：</p>
<p>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>v</mi><mi>k</mi></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><mi>k</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>k</mi></mfrac><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mo fence="false">(</mo><mfrac><mi>x</mi><mi>k</mi></mfrac><mo separator="true">,</mo><mfrac><mi>y</mi><mi>k</mi></mfrac><mo separator="true">,</mo><mfrac><mi>z</mi><mi>k</mi></mfrac><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>k</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{v}{k} = \frac{(x,y,z)}{k} = \frac{1}{k}(x,y,z) = \big(\frac{x}{k},\frac{y}{k},\frac{z}{k}),k \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>  注意，对于乘法来说，矢量和标量的位置可以互换，但对于出发，只能是矢量被标量除，而不能是标量被矢量除，这没有意义</p>
<p>  从几何意义上看，把一个矢量 <strong>v</strong> 和一个标量k相乘，这意味着对矢量 <strong>v</strong> 进行一个大小为|k|的缩放。当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k \leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，矢量的方向也会取反，如图：</p>
<p><img src="/images/Shader/Shader_03/Shader_03_10.png" alt="二维矢量和一些标量的乘法和除法"></p>
<h4 id="矢量的加法和减法">矢量的加法和减法</h4>
<p>  对两个矢量进行相加或相减，其结果使一个相同维度的新矢量</p>
<p>  只需要把两个矢量的对应分量进行相加或相减即可，公式如下：</p>
<p>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">→</mo></mover><mo>+</mo><mover accent="true"><mi>b</mi><mo stretchy="true">→</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>x</mi></msub><mo>+</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>y</mi></msub><mo>+</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>z</mi></msub><mo>+</mo><msub><mi>b</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\overrightarrow{a} + \overrightarrow{b} = (a_x+b_x,a_y+b_y,a_z+b_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03589em;vertical-align:-0.08333em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9525600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.21644em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.21644em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span class="svg-align" style="top:-3.69444em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">→</mo></mover><mo>−</mo><mover accent="true"><mi>b</mi><mo stretchy="true">→</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>x</mi></msub><mo>−</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>y</mi></msub><mo>−</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>z</mi></msub><mo>−</mo><msub><mi>b</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\overrightarrow{a} - \overrightarrow{b} = (a_x-b_x,a_y-b_y,a_z-b_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03589em;vertical-align:-0.08333em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9525600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.21644em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.21644em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span class="svg-align" style="top:-3.69444em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>  注意：一个矢量不可以和一个标量相加或相减，或者是和不同维度的食量进行运算</p>
<p>  从几何意义上来看，对于假发，可以把适量 <strong>a</strong> 的头连接到 <strong>b</strong> 的尾，然后画一条从 <strong>a</strong> 的尾到 <strong>b</strong> 的头的矢量，来得到 <strong>a</strong> 和 <strong>b</strong> 相加后的矢量。也就是说，如果从一个起点开始进行了一个位置偏移 <strong>a</strong>，然后又进行了一个位置偏移 <strong>b</strong>，那么就等同于进行了一个 <strong>a+b</strong> 的位置偏移。这被称为是矢量加法的<strong>三角形定责(triangle rule)</strong>。矢量的减法是类似的，如图：</p>
<p><img src="/images/Shader/Shader_03/Shader_03_11.png" alt="二维矢量的加法和减法"></p>
<p>  图形学中矢量通常用于描述位置偏移（简称位移）。因此，可以利用矢量的加法和减法来计算一点相对于另一点的位移</p>
<h4 id="矢量的模">矢量的模</h4>
<p>  三维矢量的模的计算公式如下：</p>
<p>  |<strong>v</strong>| = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><msubsup><mi>v</mi><mi>x</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>v</mi><mi>y</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>v</mi><mi>z</mi><mn>2</mn></msubsup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{v^2_x+v^2_y+v^2_z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.6765000000000001em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1635em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7401079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.1235em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90
l0 -0
c4,-6.7,10,-10,18,-10 H400000v40
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6765000000000001em;"><span></span></span></span></span></span></span></span></span></p>
<p>  其他维度的矢量的模计算类似，都是对每个分量的平方相加后再开根号得到</p>
<p>  可以从几何意义来理解上述公式。对于二维向量来说，可以对任意矢量构建一个三角形，如图：</p>
<p><img src="/images/Shader/Shader_03/Shader_03_12.png" alt="矢量的模"></p>
<p>  由图可以看出，对于二维矢量，其实就是使用了勾股定理，矢量的两个分量的绝对值对应了三角形两个直角边的长度，而写变得铲毒就是矢量的模</p>
<h4 id="单位矢量">单位矢量</h4>
<p>  单位矢量指的是那些模为1的食量。<strong>单位矢量(unit vector)</strong> 也被称为 <strong>归一化的矢量(normalized vector)</strong>。对任何给定的非零矢量，把他转换成单位矢量的过程就被称为 <strong>归一化(normalization)</strong></p>
<p>  给定任意非零矢量 <strong>v</strong>，可以计算和 <strong>v</strong> 方向相同的单位矢量。为了对矢量进行归一化，可以用矢量除以该矢量的模来得到，公示如下：</p>
<p>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo stretchy="true">^</mo></mover><mo>=</mo><mfrac><mi>v</mi><mrow><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\widehat{v} = \frac{v}{|v|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.67056em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.67056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span class="svg-align" style="width:calc(100% - 0.05556em);margin-left:0.05556em;top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.215392em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,v是任意非零矢量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.67056em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.67056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span class="svg-align" style="width:calc(100% - 0.05556em);margin-left:0.05556em;top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span>是该向量的单位向量</p>
<p>  <strong>零矢量</strong>（即适量的每个分量值都为0，如 <strong>v</strong> = (0,0,0)）是不可以被归一化的，这是因为做除法运算时分母不能为0</p>
<p>  从几何意义上看，对二维空间来说，可以通过画一个单位元，那么单位矢量就可以是从圆心出发，到圆边界的矢量，在三维空间中，单位矢量就是从一个单位求得球心出发，到达球面的食量，如图</p>
<p><img src="/images/Shader/Shader_03/Shader_03_13.png" alt="二维空间的单位矢量都会落在单位圆上"></p>
<h4 id="矢量的点积">矢量的点积</h4>
<p>  矢量之间可以进行乘法，但是和标量之间的乘法有很大不同。矢量的乘法有两种最常用的种类：<strong>点乘(dot product，也被称为内积，inner product)</strong> 和 <strong>叉积(cross product，也被称为外积，outer product)</strong></p>
<p>  点积的名称来源于这个运算的符号：<strong>a · b</strong>，中间的这个圆点符号是不可以省略的。点积的公式有两种形式：</p>
<p>    第一种：两个三维矢量的点积是把两个矢量对应分量相乘后再取和，最后的结果是一个标量。</p>
<p>    公式：</p>
<p>    <strong>a · b</strong> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo separator="true">⋅</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>x</mi></msub><msub><mi>b</mi><mi>x</mi></msub><mo>+</mo><msub><mi>a</mi><mi>y</mi></msub><msub><mi>b</mi><mi>y</mi></msub><mo>+</mo><msub><mi>a</mi><mi>z</mi></msub><msub><mi>b</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">(a_x,a_y,a_z) · (b_x,b_y,b_z) = a_xb_x + a_yb_y + a_zb_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>    矢量的点积满足交换律，即 <strong>a · b = b · a</strong></p>
<p>    点积的几何意义很重要，因为点积几乎应用到了图形学的各个方面，其中一个几何意义就是<strong>投影(projection)</strong></p>
<p>    投影是什么？举例来说，可以认为，现在有一个光源，它发出的光线是垂直于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.67056em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.67056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span> 方向的，那么 <strong>b</strong> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.67056em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.67056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span> 方向上的投影就是 <strong>b</strong> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.67056em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.67056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span> 方向上的影子，如图</p>
<p><img src="/images/Shader/Shader_03/Shader_03_14.png" alt="矢量b在单位矢量a方向上的投影"></p>
<p>    需要注意的是，投影的值可能是负数，投影结果的正负号与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.67056em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.67056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span> 和 <strong>b</strong> 的方向有关：当它们的方向相反（夹角大于90°）时，结果小于0；当他们的方向相互垂直（夹角为90°）时，结果等于0；当它们的方向相同（夹角小于90°）时，结果大于0，如图</p>
<p><img src="/images/Shader/Shader_03/Shader_03_15.png" alt="点积的符号"></p>
<p>    也就是说，点积的符号可以知道两个矢量的方向关系</p>
<p>    那么，推广到任何两个向量的点积 <strong>a · b</strong> 等同于 <strong>b</strong> 在 <strong>a</strong> 方向上的投影值，在乘以 <strong>a</strong> 的长度</p>
<p>    点积还有一些很重要的性质：</p>
<p>      性质一：点积可结合标量乘法</p>
<p>        结合是说，点积的操作数之一可以使另一个运算的结果，即适量和标量相乘的结果，公示如下：</p>
<p>        (ka)·b = a·(kb) = k(a·b)</p>
<p>        也就是说，对点积其中一个矢量进行缩放的结果，相当于对最后的点积结果进行缩放</p>
<p>      性质二：点积可结合矢量加法和减法，和性质一类似</p>
<p>        结合指的是，点积的操作数可以是矢量相加或相减后的结果。公示如下：</p>
<p>        a·(b + c) = a·b + a · c</p>
<p>        把上面的 <strong>c</strong> 换成 <strong>-c</strong>可以得到减法的版本</p>
<p>      性质三：一个矢量和本身点积的结果，是该矢量的模的平方</p>
<p>        如下公式证明：</p>
<p>        v·v = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>x</mi></msub><msub><mi>v</mi><mi>x</mi></msub><mo>+</mo><msub><mi>v</mi><mi>y</mi></msub><msub><mi>v</mi><mi>y</mi></msub><mo>+</mo><msub><mi>v</mi><mi>z</mi></msub><msub><mi>v</mi><mi>z</mi></msub><mo>=</mo><mi mathvariant="normal">∣</mi><mi>v</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">v_xv_x+v_yv_y+v_zv_z = |v|^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p>        这意味着，可以直接利用点积来求矢量的模，而不需要使用模的计算公式。当然，需要对点积结果进行开平方的操作来得到真正的模。但很多情况下，只是想要比较两个矢量的长度大小，因此可以直接使用点积的结果。因为开平方的运算需要消耗一定性能</p>
<p>    第二种公式：</p>
<p>    a·b = |a||b|cosθ</p>
<p>    从这个公式可以看出，计算投影时两个矢量的方向不同会得到不同符号的投影值的原因：当夹角小于90°时，cosθ &gt; 0，当夹角等于90°时，cosθ = 0，夹角大于90°时，cosθ &lt; 0</p>
<p>    利用这个公式还可以求得两个向量之间的夹角（在0°~180°）</p>
<p>    θ = arcos(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>b</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{a},\widehat{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1288799999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.67056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9344399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span class="svg-align" style="top:-3.69444em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span>)，假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.67056em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.67056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>b</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9344399999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9344399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span class="svg-align" style="top:-3.69444em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span>是单位向量</p>
<h4 id="向量的叉积">向量的叉积</h4>
<p>  <strong>叉积(cross product)</strong>，也被称为<strong>外积(outer product)</strong>。与点积不同的是，矢量叉积的结果仍是一个矢量，而非标量</p>
<p>  和点积类似，茶几的名臣来源于他的符号：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \times b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>。同样，这个叉号也是不可省略的，两个矢量的叉积可以用如下公式计算：</p>
<p>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>y</mi></msub><msub><mi>b</mi><mi>z</mi></msub><mo>−</mo><msub><mi>a</mi><mi>z</mi></msub><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>z</mi></msub><msub><mi>b</mi><mi>x</mi></msub><mo>−</mo><msub><mi>a</mi><mi>x</mi></msub><msub><mi>b</mi><mi>z</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>x</mi></msub><msub><mi>b</mi><mi>y</mi></msub><mo>−</mo><msub><mi>a</mi><mi>y</mi></msub><msub><mi>b</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \times b = (a_x,a_y,a_z) \times (b_x,b_y,b_z) = (a_yb_z - a_zb_y,a_zb_x - a_xb_z,a_xb_y - a_yb_x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>  公式看起来复杂，但其实是有一定规律的，如图：</p>
<p><img src="/images/Shader/Shader_03/Shader_03_16.png" alt="三维向量叉积的计算规律。不同颜色的线表示了计算结果矢量中对应颜色的分量的计算路径。以最深的颜色为例，结果矢量的第一个分量，它是从第一个矢量的y分量出发乘以第二个矢量的z分量，再减去第一个矢量的z分量和第二个矢量的y分量的乘积"></p>
<p>  注意：叉积不满足交换律，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi><mo mathvariant="normal">≠</mo><mi>b</mi><mo>×</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \times b \neq b \times a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。实际上，叉积是满足反交换律的，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi><mo>=</mo><mo>−</mo><mo stretchy="false">(</mo><mi>b</mi><mo>×</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \times b = -(b \times a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span>。而且叉积也不满足结合律，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo stretchy="false">)</mo><mo>×</mo><mi>c</mi><mo mathvariant="normal">≠</mo><mi>a</mi><mo>×</mo><mo stretchy="false">(</mo><mi>b</mi><mo>×</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \times b) \times c \neq a \times (b \times c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span></p>
<p>  从叉积的几何意义出发，可以更加深入理解它的用处。对两个矢量进行叉积的结果会得到一个同时垂直于这两个矢量的新矢量，可以知道，矢量是由一个模和方向来定义的。</p>
<p>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \times b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的长度等于 <strong>a</strong> 和 <strong>b</strong> 的模的乘积在乘以他们之间的夹角的正弦值，公式如下：</p>
<p>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo>×</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">|a \times b| = |a||b|sinθ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></p>
<p>  矢量的方向就要和左手坐标系和右手坐标系联系起来了，如图</p>
<p><img src="/images/Shader/Shader_03/Shader_03_17" alt="分别使用左手坐标系和右手坐标系得到的叉积结果"></p>
<p>  需要注意的是，虽然看起来左右手坐标系的选择会影响叉积的结果，但仅仅是“看起来”而已。从叉积的数学表达式可以发现，使用左手坐标系还是右手坐标系不会对计算结果产生任何影响，它影响的只是数字在三维空间中的视觉化表现而已。当从右手坐标系转换为左手坐标系时，所有点和矢量的表达和计算方式都会保持不变，只是当呈现到屏幕上时，会发现图像反过来了。</p>
<p>  叉积的用处：最常见的应用就是计算垂直于一个平面、三角形的矢量。另外，还可以用于判断三角面片的朝向</p>
<h2 id="矩阵">矩阵</h2>
<p>1</p>
]]></content>
      <categories>
        <category>UnityShader</category>
      </categories>
      <tags>
        <tag>UnityShader</tag>
      </tags>
  </entry>
</search>
