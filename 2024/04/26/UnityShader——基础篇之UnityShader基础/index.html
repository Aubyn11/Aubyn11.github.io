<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>UnityShader——基础篇之UnityShader基础 |  Aubyn</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-UnityShader——基础篇之UnityShader基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  UnityShader——基础篇之UnityShader基础
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/04/26/UnityShader%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BUnityShader%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2024-04-26T00:19:25.000Z" itemprop="datePublished">2024-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/UnityShader/">UnityShader</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">5.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">21 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1>UnityShader基础</h1>
<h2 id="unityshader概述">UnityShader概述</h2>
<h3 id="材质和unityshader">材质和UnityShader</h3>
<p>  总的来说，在Unity中需要配合使用<strong>材质</strong>(<strong>Material</strong>)和 Unity Shader 才能达到需要的效果，常见流程为：</p>
<ul>
<li>创建一个材质</li>
<li>创建一个 Unity Shader，并把它赋给上一步中创建的材质</li>
<li>把材质赋给需要渲染的对象</li>
<li>在材质面板中调整 Unity Shader 的属性，以得到满意的效果</li>
</ul>
<p><img src="/images/Shader/Shader_02/Shader_02_01.png" alt=""></p>
<p>  Unity Shader定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等）</p>
<p>  材质允许调节这些属性，将其最终赋给对应的模型</p>
<h3 id="unity-中的材质">Unity 中的材质</h3>
<p>  Unity 中的材质需要结合一个 GameObject 的 Mesh 或者 Particle systems 组件来工作，它决定了游戏对象看起来是什么样子的（也需要 Unity Shader 的配合）</p>
<p>  创建一个新的材质，可以在 Unity 的菜单栏中选择 Assets -&gt; Create -&gt; Material 来创建，也可以直接在 Project 视图中右击 -&gt; Create -&gt; Material 来创建</p>
<p>  当创建了一个材质后，就可以把它赋值给一个对象，这可以通过把材质直接拖拽到 Scene 视图中的对象来实现，或者在该对象的 Mesh Renderer 组件中直接赋值，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_02.png" alt=""></p>
<p>  在 Unity 的 2020.x 版本中，默认情况下，一个新建的材质将使用Unity内置的 Standard Shader，这是一种基于物理渲染的着色器</p>
<p>  Unity的材质和许多建模软件（如 Cinema 4D、Maya 等）中提供的材质工鞥呢类似，他们都提供了一个面板来调整材质的各个参数，这种可视化的方法使得开发者不再需要自行在代码中设置和改变所需的各种参数，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_03.png" alt=""></p>
<h3 id="unity-中的-shader">Unity 中的 Shader</h3>
<p>  创建一个新的 Unity Shader，可以在 Unity 的菜单栏中选择 Assets -&gt; Create -&gt; Shader 来创建，也可以直接在 Project 视图中右击 -&gt; Create -&gt; Shader 来创建，Unity 一共提供了5种 Unity Shader 模板供选择 —— Shader Surface Shader, Unlit Shader, Image Effect Shader, Compute Shader 以及 Ray Tracing Shader。</p>
<p>  Standard Surface Shader 会产生一个包含了标准光照模型的表面着色器模板</p>
<p>  Unlit Shader会产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器</p>
<p>  Image Effect Shader 为实现各种屏幕后处理效果提供了一个基本模板</p>
<p>  Compute Shader 会产生一种特殊的 Shader 文件，这类 Shader 旨在利用 GPU 的并行性来进行一些常规渲染流水线无关的计算</p>
<p>  Ray Tracing Shader是一种用于Unity中的实时光线追踪的Shader。光线追踪是一种通过追踪从相机到场景中各个像素的光线的技术，以模拟光线在真实世界中的传播和反射。Ray Tracing Shader可以帮助开发者实现更加逼真的光影效果，包括实时反射、折射、阴影和环境光照等效果。</p>
<br/>
<p>  一个单独的 Unity Shader 是无法发挥任何作用的，它必须和材质结合起来。</p>
<p>  所以，可以在材质面板最上方的下拉菜单中选择需要使用的 Unity Shader，当选择完毕后，材质面板中就会出现该 Unity Shader 可用的各种属性。这些属性可以是颜色、纹理、浮点数、滑动条（限制了范围的浮点数）、向量等</p>
<p>  当把材质赋给场景中的一个对象，就可以看到调整属性所发生的视觉变化</p>
<br/>
<p>  Unity Shader本质上就是一个文本文件，和 Unity 中的很多外部文件类似，Unity Shader 也有<strong>导入设置</strong>(Import Settings)面板，在 <strong>Project</strong>视图中选中某个 Unity Shader即可看到，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_04.png" alt=""></p>
<p>  在该面板上，可以在 <strong>Default Maps</strong> 中指定该 Unity Shader 使用的默认纹理。当任何材质第一次使用该 Unity Shader 时，这些纹理就会自动被赋予到相应的属性上。在下方的面板中，Unity 会显示出和该 Unity 相关的信息，例如它是否是一个表面着色器（Surface Shader）、是否是一个固定函数着色器（Fixed Function Shader）等，还有一些信息是和在 Unity Shader 中的标签设置有关，例如是否会投射阴影、使用的渲染队列、LOD值等</p>
<p>  对于表面着色器来说，可以通过单击 Show generated code 按钮来打开一个新的文件，在该文件里将显示 Unity 在背后为该表面着色器生成的顶点/片元着色器。这可以方便对这些生成的代码进行修改（需要复制到一个新的 Unity Shader 中才可保存）和研究</p>
<p>  如果 Unity Shader 使一个固定函数着色器，在 Fixed function 的后面也会出现一个 Show generated code 按钮，来查看该固定函数着色器生成的顶点/片元着色器。Compile and show code 下拉列表可以让开发者检查该 Unity Shader 针对不同图像编程接口（例如 OpenGL、D3D9、D3D11等）最终编译成的 Shader 代码，如图所示：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_05.png" alt=""></p>
<p>  直接单击该按钮可以查看生成的底层的汇编指令。可以利用这些代码来分析和优化着色器</p>
<p>  除此之外，Unity Shader 的导入面板还可以方便地查看其使用的渲染队列（Reder queue）、是否关闭批处理（Disable batching）、属性列表（Properties）等信息</p>
<h2 id="unity-shader-的基础：shaderlab">Unity Shader 的基础：ShaderLab</h2>
<h3 id="什么是-shaderlab">什么是 ShaderLab</h3>
<p>  Unity Shader 是 Unity 为研发者提供的高层记得渲染抽象层，Unity 希望以这种方式来让开发者更加轻松的控制渲染，见下图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_06.png" alt=""></p>
<p>  在 Unity 中，所有的 Unity Shader 都是使用 ShaderLab 来编写的</p>
<p>  ShaderLab 是 Unity 编写 Unity Shader 的一种说明性语言，它使用了一些嵌套在花括号内部的**语义&amp;&amp;（<strong>syntax</strong>）来描述一个 Unity Shader 文件的结构，这些结构包含了许多渲染所需的数据，例如 Properties 语句块中定义了着色器所需的各种属性，这些属性将会出现在材质面板中</p>
<p>  从设计上来说，ShaderLab 类似于 CgFX 和 Direct3D Effects（FX）语言，他们都定义了要显示一个材质所需的所有东西，而<strong>不仅仅是着色器代码</strong></p>
<p>  一个 Unity Shader 的基础结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        //属性</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        //显卡A使用的子着色器</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        //显卡B使用的子着色器</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unityshader的结构">UnityShader的结构</h2>
<h3 id="给shader起名字">给Shader起名字</h3>
<p>  每个Unity Shader文件的第一行都需要通过 Shader 语义来制定该 Unity Shader 的名字，这个名字由一个字符串来定义</p>
<p>  当为材质选择使用的 Unity Shader 时，这些名称就会出现在材质面板的下拉列表里，通过在字符串中添加斜杠(&quot;/&quot;)，可以控制 Unity Shader 在材质面板中出现的位置，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/001Shader&quot;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  那么，这个 Unity Shader在材质面板中的位置就是：Shader -&gt; Unlit -&gt; 001Shader，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_07.png" alt=""></p>
<h3 id="材质和-unity-shader-的桥梁：properties">材质和 Unity Shader 的桥梁：Properties</h3>
<p>  Properties语义块中包含了一系列<strong>属性</strong>(<strong>property</strong>)，这些属性将会出现在材质面板中</p>
<p>  Properties语义块的定义通常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">    Name(&quot;display name&quot;,PropertyType) = DefaultValue</span><br><span class="line">    Name(&quot;display name&quot;,PropertyType) = DefaultValue</span><br><span class="line">    //更多属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  开发者声明这些属性是为了在材质面板中能够方便的调整各种材质属性</p>
<p>  如果需要在 Shader 中访问它们，就需要使用每个属性的<strong>名字</strong>(<strong>Name</strong>)，Unity中，这些属性的名字通常由一个下划线开始，<strong>显示的名称</strong>(<strong>display name</strong>)则是出现在材质面板上的名字，需要为每个属性指定它的<strong>类型</strong>(<strong>PropertyType</strong>)，常见的属性如表：</p>
<table>
<thead>
<tr>
<th>属性类型</th>
<th>默认值的定义语法</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int</td>
<td>number</td>
<td>_Int(“Int”,Int) = 2</td>
</tr>
<tr>
<td>Float</td>
<td>number</td>
<td>_Float(“Float”,Float) = 1.5</td>
</tr>
<tr>
<td>Range(min,max)</td>
<td>number</td>
<td>_Range(“Range”,Range(0.0,5.0) = 3.0</td>
</tr>
<tr>
<td>Color</td>
<td>(number,number,number,number)</td>
<td>_Color(“Color”,Color) = (1,1,1,1)</td>
</tr>
<tr>
<td>Vector</td>
<td>(number,number,number,number)</td>
<td>_Verctor(“Vector”,Vector) = (2,3,6,1)</td>
</tr>
<tr>
<td>2D</td>
<td>“defaulttexture”{}</td>
<td>_2D(“2D”,2D) = “”{}</td>
</tr>
<tr>
<td>Cube</td>
<td>“defaulttexture”{}</td>
<td>_Cube(“Cube”,Cube) = “white”{}</td>
</tr>
<tr>
<td>3D</td>
<td>“defaulttexture”{}</td>
<td>_3D(“3D”,3D) = “black”</td>
</tr>
</tbody>
</table>
<p>  除此之外，还需要为每个属性指定一个默认值，在第一次把该 Unity Shader 赋给某个素材时，菜盒子面板显示的就是这些默认值</p>
<p>    对于 <strong>Int、Float、Range</strong> ，这些数字类型的属性，其默认值就是一个单独的数；</p>
<p>    对于 <strong>Color</strong> 和 <strong>Vector</strong> 这类属性，默认值是用圆括号包围的一个四维向量；</p>
<p>    对于 <strong>2D、Cube、3D</strong> 这3种纹理类型，默认值的类型稍微复杂，他们的默认值是通过一个字符串后跟一个花括号来指定的，其中，字符串要么是空的，要么是内置的纹理名称，如 “white”“black”“gray” 或者 “bump”。或括号的用处原本是用于制定一些纹理属性的。</p>
<p>  如果需要控制固定管线的纹理坐标的生成，就需要再顶点着色器中编写计算相应纹理坐标的代码</p>
<p>  如下方的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/001Shader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Int(&quot;Int&quot;,int) = 2</span><br><span class="line">        _Float(&quot;Float&quot;,float) = 1.5</span><br><span class="line">        _Range(&quot;Range&quot;,range(0.0,5.0)) = 1.0</span><br><span class="line">        _Color(&quot;Color&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _Vector(&quot;Vector&quot;,Vector) = (2,3,6,1)</span><br><span class="line">        _2D(&quot;2D&quot;,2D) = &quot;&quot;&#123;&#125;</span><br><span class="line">        _Cube(&quot;Cube&quot;,Cube) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _3D(&quot;3D&quot;,3D) = &quot;black&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	FallBack &quot;diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  材质面板中的显示结果，如图：</p>
<p><img src="/images/Shader/Shader_02/Shader_02_08.png" alt=""></p>
<p>  Unity 允许重载默认的材质编辑面板，以提供更多自定义的数据类型</p>
<p>  为了在 Unity 中可以访问到这些属性，需要在 Cg 代码片中定义和这些属性类型相匹配的变量，需要说明的是，即使不在 Properties 语义块中生命这些属性，也可以直接在 Cg 代码片中定义变量</p>
<p>  此时，可以通过脚本向 Shader 中换地这些属性，因此，Properties与一块的作用仅仅是为了让这些属性可以出现在材质面板中</p>
<h3 id="subshader">SubShader</h3>
<p>  每一个 Unity Shader 文件可以包含多个 SubShader 语义块，但最少要有一个。</p>
<p>    当 Unity 需要加载这个 Unity Shader 时，Unity 会扫描所有的 SubShader 语义块，然后选择第一个能够在目标平台运行的SubShader</p>
<p>    如果都不支持的话，Unity 就会使用 Fallback 语义指定的 Unity Shader</p>
<p>  Unity 提供这种语义的原因在于，不同的显卡具有不同的能力。例如：一些旧的显卡仅能支持一定数目的操作指令，而一些更高级的显卡可以支持更多的指令数</p>
<p>  那么就希望在旧的显卡上使用计算复杂度低的着色器，在高级的显卡上使用计算复杂度较高的着色器，以便提供更出色的画面</p>
<p>  SubShader 语义块中包含的定义通常如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">    //可选</span><br><span class="line">    Tags</span><br><span class="line"></span><br><span class="line">    //可选</span><br><span class="line">    RenderSetup</span><br><span class="line"></span><br><span class="line">    Pass&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //Other Passes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  SubShader 中定义了一系列 Pass 以及可选的<strong>状态</strong>(RenderSetup)和<strong>标签</strong>(Tags)设置。</p>
<p>  每个 Pass 定义了一个完整的渲染流程，但如果 Pass 数目过多，往往会造成渲染性能的下降</p>
<p>  因此，应该尽量使用最小数目的 Pass，状态和标签同样可以在 Pass 声明，不同的是，SubShader 中的一些标签是特定的</p>
<p>  也就是说，这些标签设置和 Pass 中使用的标签是不一样的，对于状态设置来说，使用的语法是相同的</p>
<p>  但是如果在 SubShader 进行了这些设置，呢么将会用于所有的 Pass</p>
<p>  <strong>状态设置</strong></p>
<p>  ShaderLab 提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等</p>
<p>  ShaderLab 中常见的渲染状态设置选项如下表：</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>设置指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cull</td>
<td>Cull Back|Front|Off</td>
<td>设置剔除模式：剔除背面/正面/关闭剔除</td>
</tr>
<tr>
<td>ZTest</td>
<td>ZTest Less Greater|LEqqual|GEqual|Equal|NotEqual|Always</td>
<td>设置深度测试时使用的函数</td>
</tr>
<tr>
<td>ZWrite</td>
<td>ZWrite On|Off</td>
<td>开启/关闭深度写入</td>
</tr>
<tr>
<td>Blend</td>
<td>Blend SrcFactor DstFactor</td>
<td>开启并设置混合模式</td>
</tr>
</tbody>
</table>
<p>  当在 SubShader 块中设置了上述渲染状态时，将会应用到所有的 Pass，如果不想这样（如在双面渲染中，希望第一个 Pass 中剔除正面来对背面进行渲染，在第二个 Pass 中剔除背面来对正面进行渲染），可以在 Pass 语义块中单独进行上面的设置</p>
<p>  <strong>SubShader</strong>的标签</p>
<p>  SubShader 的标签（Tags）是一个<strong>键值对</strong>（Key/Value Pair），它的键和值都是字符串类型，这些键值对是 SubShader 和渲染引擎之间的沟通桥梁。它们用来告诉 Unity 的渲染引擎希望怎样以及何时渲染这个对象：</p>
<p>  标签的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;&quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>  SubShader 的标签快支持的标签类型如表：</p>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Queue</td>
<td>控制渲染顺序，指定该物体属于哪一个渲染队列，通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染，也可以自定义使用的渲染队列来控制物体的渲染顺序</td>
<td>Tags{“Queue” = “Transparent”}</td>
</tr>
<tr>
<td>RenderTyep</td>
<td>对着色器进行分类，例如这是一个不同明德着色器，或是一个透明的着色器等，这可以被用于着色器替换(Shader Replacement)功能</td>
<td>Tags{“renderType”=“Opaque”}</td>
</tr>
<tr>
<td>DisableBatching</td>
<td>一些 SubShader 在使用 Unity 的批处理功能时会出现问题，例如使用了模型空间下的坐标进行顶点动画，这是可以通过该标签来直接指明是否对该 SubShader 使用批处理</td>
<td>Tags{“DisableBatching” = “True”</td>
</tr>
<tr>
<td>ForceNoShadowCasting</td>
<td>控制使用该 SubShader 的物体是否会投射阴影</td>
<td>Tags{“ForceNoShadowCasting”=“True”</td>
</tr>
<tr>
<td>IgnoreProjector</td>
<td>如果该标签为&quot;True&quot;，那么使用该 SubShader 的物体将不会受 Projector 的影响，通常用于半透明物体</td>
<td>Tags{“IgnoreProjector”=“True”}</td>
</tr>
<tr>
<td>CanUseSpriteAtlas</td>
<td>当该 SubShader 是用于精灵(sprite)时，将该标签设置为&quot;False&quot;</td>
<td>Tags{“CanUseSpriteAtlas”=“False”</td>
</tr>
<tr>
<td>PreviewType</td>
<td>知名材质面板将如何预览改材质。默认情况下，材质将显示为一个球形，可以通过把这些标签的值设为&quot;Plane&quot;&quot;SkyBox&quot;来改变预览类型</td>
<td>Tags{“PreviewType”=“Plane”}</td>
</tr>
</tbody>
</table>
<p>  需要注意的是，上述标签仅可以在 SubShader 中声明，而不可以在 Pass 块中声明。Pass 块虽然也可以定义标签，但这些标签是不同于 SubShader 的标签类型</p>
<p>  <strong>Pass</strong> 语义块</p>
<p>  Pass 语义块包含的语义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    Name</span><br><span class="line">    Tags</span><br><span class="line">    RenderSetup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  首先，可以在 Pass 中定义该 Pass 的名称，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name &quot;MyPassName&quot;</span><br></pre></td></tr></table></figure>
<p>  通过这个名称，可以使用 ShaderLab 的 UsePass 命令来直接使用其他 UnityShader 中的 Pass，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsePass &quot;MyShader/MYPASSNAME&quot;</span><br></pre></td></tr></table></figure>
<p>  这样可以提高代码的复用性，需要注意的是，由于 Unity 内部会把所有 Pass 的名称转换成大写字母的表示，因此，在使用 UsePass 命令时必须使用大写形式的名字</p>
<p>  其次，可以对 Pass 设置渲染状态。SubShader 的状态设置同样适用于 Pass。除了上面提到的状态设置外，在 Pass 中我们还可以使用固定管线的着色器命令</p>
<p>  Pass 同样可以设置标签，但它的标签不同于 SubShader 的标签，这些标签也是用于告诉渲染引擎希望怎样来渲染该物体</p>
<p>  Pass 中使用的标签类型如下表：</p>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>LightMode</td>
<td>定义该 Pass 在 Unity 的渲染流水线中的角色</td>
<td>Tags{“LightMode”=“ForwardBase”}</td>
</tr>
<tr>
<td>RequireOptions</td>
<td>用于指定当满足某些条件时才渲染该 Pass，它的值是一个由空格分割的字符串。</td>
<td>Tags{“RequireOptions”=“SoftVegetation”}</td>
</tr>
</tbody>
</table>
<p>  除了上面普通的 Pass 定义外，UnityShader 还支持一些特殊的 Pass，以便进行代码复用或实现更复杂的效果：</p>
<p>    <strong>UsePass</strong>：如之前提到的一样，可以使用该命令来复用其他 UnityShader 中的 Pass</p>
<p>    <strong>GrabPass</strong>：该 Pass 负责抓取屏幕并将结果存储在一张纹理中，以用于后续的 Pass 处理</p>
<h3 id="fallback">Fallback</h3>
<p>  紧跟在各个 SubShader 语义块后面的，可以是一个 Fallback 指令，它用于告诉 Unity，“如果上面所有的 SubShader 在这块显卡上都不能运行，那么就是用这个最低级的 Shader”</p>
<p>  它的语义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fallback &quot;name&quot;</span><br><span class="line">//或者</span><br><span class="line">Fallback Off</span><br></pre></td></tr></table></figure>
<p>  如上所述，可以通过一个字符串来告诉 Unity 这个“最低级的 UnityShader”是谁，也可以关闭 Fallback 功能，但一旦这么做，那么意思就是“如果一块显卡跑不了上面所有的 Shader，那就不管他了”</p>
<p>  例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback &quot;VertexLit&quot;</span><br></pre></td></tr></table></figure>
<p>  事实上，Fallback还会影响阴影的投射</p>
<p>  在渲染阴影纹理时，Unity 会在每个 UnityShader 中寻找一个阴影投射的 Pass，通常情况下，不需要自己专门实现一个 Pass，这是因为 Fallback 使用的内置 Shader 中包含了这样一个通用的 Pass，因此，为每个 UnityShader 正确设置 Fallback 是非常重要的</p>
<h3 id="shaderlab还有其他的语义吗">ShaderLab还有其他的语义吗</h3>
<p>  除了上述的语义，还有一些不常用到的寓意。</p>
<p>  例如：如果不满足于 Unity 内置的属性类型，想要自定义材质面板的编辑界面，就可以使用 CustomEditor 语义来拓展编辑界面。还可以使用 Category 语义来对 UnityShader 中的命令进行分组。</p>
<h2 id="unitysahder-的形式">UnitySahder 的形式</h2>
<p>  尽管 UnityShader 可以做的事情很多（例如设置渲染状态等），但其最重要的任务还是指定各种着色器所需的代码。这些着色器代码可以写在 SubShader 语义块中（表面着色器的做法），也可以写在 Pass 语义块中（顶点/片元着色器和固定函数着色器的做法）</p>
<p>  在 Unity 中，可以使用下面 3 种形式来编写 UnityShader，而不管使用哪种形式，真正意义上的 Shader 代码都需要包含在 ShaderLab 语义块中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;MyShader&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        //所需的各种属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        //真正意义上的 Shader 代码会出现在这里</span><br><span class="line">        //表面着色器&#123;Surface Shader&#125;或者</span><br><span class="line">        //顶点/片元着色器&#123;Vertex/Fragment Shader&#125;或者</span><br><span class="line">        //固定函数着色器&#123;Fixed Function Shader&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        //和上一个 SubShader 类似</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表面着色器">表面着色器</h3>
<p>  <strong>表面着色器（Surface Shader）</strong> 是 Unity 自己创造的一种着色器代码类型，他需要的代码量很少，Unity 在背后做了很多工作，渲染的代价比较大。</p>
<p>  本质上和顶点/片元着色器是一样的，当给Unity提供一个便面着色器的时候，在背后仍旧需要把它装换成对应的顶点/片元着色器</p>
<p>  它的价值在于：Unity 处理了很多光照细节，不需要去操心这些“烦人的事情”</p>
<p>  示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot;&#123;</span><br><span class="line">    SubSHader&#123;</span><br><span class="line">        Tags&#123;&quot;RenderType&quot;=&quot;Opaque&quot;&#125;</span><br><span class="line">        CGPROGAM</span><br><span class="line">        #pragma surface surf Lambert</span><br><span class="line">        struct Input&#123;</span><br><span class="line">            float4 color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        void surf(Input IN,inout SurfaceOutput o)&#123;</span><br><span class="line">            o.Albedo = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  表面着色器被定义在 SubShader 语义块（不是 Pass 语义块）中的 CGPROGRAM 和 ENDCG 之间</p>
<p>  原因是表面着色器不需要开发者关心使用多少个 Pass，每个 Pass 如何渲染等问题，Unity 会在背后做好这些事情</p>
<p>  CGPROGRAM 和 ENDCG 之间的代码是使用 Cg/HLSL 编写的，也就是说，需要把 Cg/HLSL 语言嵌套在 ShaderLab 语言中</p>
<p>  这里的 Cg/HLSL 是 Unity 经封装后提供的，它的语法和标准的 Cg/HLSL 语法几乎一样，但还是有细微的不同</p>
<h3 id="顶点-片元着色器">顶点/片元着色器</h3>
<p>  Unity 中可以使用 Cg/HLSL 语言来编写<strong>顶点/片元着色器（Vertex/Fragment Shader）</strong>。它们更加复杂，但灵活性更高</p>
<p>  示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple VertexFragment Shader&quot;&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #progama vetex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            float4 vert(float4 v : POSITION) : SV_POSITON&#123;</span><br><span class="line">                return mul(UNITY_MATRIX_MVP,v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag() : SV_Target&#123;</span><br><span class="line">                return fixed4(1.0,0.0,0.0,1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  顶点/片元着色器的代码需要定义在 CGPROGRAM 和 ENDCG 之间，不同的是，顶点/片元着色器是写在 Pass 语义块内，而非 SubShader内的</p>
<p>  这样的原因是，需要自己定义每个 Pass 需要使用的 Shader 代码，虽然可能需要编写更多的代码，但好处是灵活性很高，更重要的是，可以空时渲染的实现细节</p>
<h3 id="固定函数着色器">固定函数着色器</h3>
<p>  对于一些较旧的设备（其GPU仅支持 DirectX 7.0、OpenGL 1.5 或 OpenGL ES 1.1），它们不支持可编程管线着色器，因此，这时候就需要使用<strong>固定函数着色器（Fixed Function Shader）</strong> 来完成渲染。这些着色器网网址可以完成一个非常简单的效果</p>
<p>  示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Tutorial/Basic&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color(&quot;Main Color&quot;,Color&#125; = &#123;1,0.5,0.5,1&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Material&#123;</span><br><span class="line">                Diffuse [_Color]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  固定着色器的代码被定义在 Pass 语义块中，这些代码相当于 Pass 中的一些渲染设置</p>
<p>  对于固定函数着色器来说，需要完全使用 ShaderLab 的语法（使用 ShaderLab 的渲染设置命令）来编写，而不是使用 Cg/HLSL</p>
<p>  由于现在绝大多数 GPU 都支持可编程的渲染管线，这种编程方式已经被逐渐抛弃，在新版的 Unity 中，所有固定函数着色器都会在背后被 Unity 编译成对应的顶点/片元着色器</p>
<h3 id="选择哪种-unityshader-形式">选择哪种 UnityShader 形式</h3>
<p>  如果有非常明确的需求必须要使用固定函数着色器，否则使用可编程管线的着色器，即表面着色器或顶点/片元着色器</p>
<p>  如果要和各种光源打交道，可能更需要使用表面着色器，但需要小新在移动平台中的性能表现</p>
<p>  如果需要使用的光照数目非常少，那么使用顶点/片元着色器使一个更好的选择</p>
<p>  如果有很多自定义的渲染效果，使用顶点/片元着色器</p>
<h2 id="其他的一些问题">其他的一些问题</h2>
<p>1</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://aubyn11.github.io/2024/04/26/UnityShader%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BUnityShader%E5%9F%BA%E7%A1%80/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UnityShader/" rel="tag">UnityShader</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/04/25/C-%E8%BF%9B%E4%BF%AE%E2%80%94%E2%80%94C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">C++进修——C++核心编程</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2024
        <i class="ri-heart-fill heart_icon"></i> Aubyn
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Aubyn"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.15.1/katex.min.css">
        <script src="https://cdn.staticfile.org/KaTeX/0.15.1/katex.min.js"></script>
        <script src="https://cdn.staticfile.org/KaTeX/0.15.1/contrib/auto-render.min.js"></script>
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>